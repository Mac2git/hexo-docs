<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis基础 | Lazy的个人博客</title><meta name="author" content="Lazy"><meta name="copyright" content="Lazy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="什么是Redis？Redis 是一个内存数据存储，被数百万开发者用作缓存、向量数据库、文档数据库、流式引擎和消息代理。Redis 具有内置的复制和不同级别的磁盘持久化。它支持复杂的数据类型（例如，字符串、散列、列表、集合、有序集合和 JSON），并为这些数据类型定义了原子操作。 Redis 通常被称为数据结构服务器。这意味着 Redis 通过一组命令提供对可变数据结构的访问，这些命令通过 TCP">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis基础">
<meta property="og:url" content="https://mac2git.github.io/hexo-docs/2025/08/13/redis/index/index.html">
<meta property="og:site_name" content="Lazy的个人博客">
<meta property="og:description" content="什么是Redis？Redis 是一个内存数据存储，被数百万开发者用作缓存、向量数据库、文档数据库、流式引擎和消息代理。Redis 具有内置的复制和不同级别的磁盘持久化。它支持复杂的数据类型（例如，字符串、散列、列表、集合、有序集合和 JSON），并为这些数据类型定义了原子操作。 Redis 通常被称为数据结构服务器。这意味着 Redis 通过一组命令提供对可变数据结构的访问，这些命令通过 TCP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.crazytaxii.com/Redis_Logo.png">
<meta property="article:published_time" content="2025-08-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-22T17:03:24.637Z">
<meta property="article:author" content="Lazy">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.crazytaxii.com/Redis_Logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis基础",
  "url": "https://mac2git.github.io/hexo-docs/2025/08/13/redis/index/",
  "image": "https://pic.crazytaxii.com/Redis_Logo.png",
  "datePublished": "2025-08-12T16:00:00.000Z",
  "dateModified": "2025-08-22T17:03:24.637Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lazy",
      "url": "https://mac2git.github.io/hexo-docs"
    }
  ]
}</script><link rel="shortcut icon" href="/hexo-docs/images/webImages/logo.svg"><link rel="canonical" href="https://mac2git.github.io/hexo-docs/2025/08/13/redis/index/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/hexo-docs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/hexo-docs/',
  algolia: undefined,
  localSearch: {"path":"/hexo-docs/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Lazy","link":"链接: ","source":"来源: Lazy的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic.crazytaxii.com/Redis_Logo.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/hexo-docs/"><span class="site-name">Lazy的个人博客</span></a><a class="nav-page-title" href="/hexo-docs/"><span class="site-name">Redis基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-12T16:00:00.000Z" title="发表于 2025-08-13 00:00:00">2025-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-22T17:03:24.637Z" title="更新于 2025-08-23 01:03:24">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/hexo-docs/categories/%E5%90%8E%E7%AB%AF-Redis/">后端 Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><p>Redis 是一个内存数据存储，被数百万开发者用作缓存、向量数据库、文档数据库、流式引擎和消息代理。Redis 具有内置的复制和不同级别的磁盘持久化。它支持复杂的数据类型（例如，字符串、散列、列表、集合、有序集合和 JSON），并为这些数据类型定义了原子操作。</p>
<p>Redis 通常被称为数据结构服务器。这意味着 Redis 通过一组命令提供对可变数据结构的访问，这些命令通过 TCP 套接字和简单协议使用服务器-客户端模型发送。因此，不同的进程可以以共享的方式查询和修改相同的数据结构。</p>
<p>Redis 实现的数据结构具有一些特殊的属性：</p>
<ol>
<li>Redis 会将其存储在磁盘上，即使它们总是被服务器内存中读取和修改。这意味着 Redis 速度快，但同时也非易失性。</li>
<li>数据结构的实现强调内存效率，因此 Redis 内部的数据结构可能比使用高级编程语言建模的相同数据结构模型使用更少的内存。</li>
<li>Redis 提供了一系列数据库中常见的功能，如复制、可调的持久性级别、集群和高度可用性。</li>
</ol>
<h2 id="下载Redis"><a href="#下载Redis" class="headerlink" title="下载Redis"></a>下载Redis</h2><blockquote>
<p><strong>命名规则：</strong></p>
<p>​	版本号第二位如果是奇数，则为非稳定版本，如2.7、2.9、3.1</p>
<p>​	版本号第二位如果是偶数，则为文档版本，如2.6、2.8、3.0、3.2</p>
<p>​	当前奇数版本就是下一个稳定版本的开发版本，如2.9版本是3.0版本的开发版本</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://redis.io/downloads/">下载Redis</a></p>
<h2 id="redis解决中文乱码"><a href="#redis解决中文乱码" class="headerlink" title="redis解决中文乱码"></a>redis解决中文乱码</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-cli -a 密码 --raw</span><br></pre></td></tr></table></figure>



<h2 id="Linux安装Redis"><a href="#Linux安装Redis" class="headerlink" title="Linux安装Redis"></a>Linux安装Redis</h2><ol>
<li><p><code>getconf LONG_BIT</code>命令先看看是多少位的，一定要是64位</p>
</li>
<li><p>Centos7安装<code>Redis</code>，先具备gcc环境</p>
<ol>
<li><p>查看是否具有<code>gcc</code>环境<code>gcc -v</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406143055527.png" alt="image-20250406143055527"></p>
</li>
<li><p>如果没有<code>gcc</code>环境，则通过<code>yum -y install gcc-c++</code>命令来安装<code>gcc</code></p>
</li>
</ol>
</li>
<li><p><code>Redis</code>官方建议版本升级到6.0.8以上</p>
<p><img src="/hexo-docs/images/redisImages/redis.png"></p>
</li>
<li><p>下载命令<code>wget https://download.redis.io/releases/redis-7.0.0.tar.gz</code></p>
<p><img src="/hexo-docs/images/redisImages/redis%E5%AE%89%E8%A3%85.png"></p>
</li>
<li><p>进入<code>/opt</code>目录下解压<code>redis</code>，解压命令<code>tar -zxvf redis-7.0.0.tar.gz</code></p>
<ol>
<li><p>解压后</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406143750928.png" alt="image-20250406143750928"></p>
</li>
</ol>
</li>
<li><p>进入目录<code>cd redis-7.0.0</code></p>
</li>
<li><p>在<code>redis-7.0.0</code>目录执行<code>make</code>命令</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406144027413.png" alt="image-20250406144027413"></p>
</li>
<li><p>查看默认安装目录：<code>usr/local/bin</code></p>
<ol>
<li><p>安装完后查看</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406144621148.png" alt="image-20250406144621148"></p>
</li>
<li><p><code>redis-benchmark</code>：性能测试工具，服务启动后运行该命令，看看自己笔记本性能如何</p>
</li>
<li><p><code>redis-check-aof</code>：修复有问题的AOF文件</p>
</li>
<li><p><code>redis-check-dump</code>：修复有问题的dump.rdb文件</p>
</li>
<li><p><span style="color:#990000;"><code>redis-cli</code>：客户端，操作入口</span></p>
</li>
<li><p><code>redis-sentinel</code>：redis集群使用</p>
</li>
<li><p><span style="color:#990000;"><code>redis-server</code>：redis服务器启动命令</span></p>
</li>
</ol>
</li>
<li><p>将默认的<code>redis.conf</code>拷贝到自己定义好的一个路径下，比如<code>/myredis</code>(如果改坏的话有备份)</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406144745776.png" alt="image-20250406144745776"></p>
</li>
<li><p>修改<code>/myredis</code>目录下<code>redis.conf</code>配置文件做初始化设置</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis.conf配置文件，改完后确保生效，记得重启，记得重启</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> 默认daemonize no              改为  daemonize yes</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span> 默认protected-<span class="built_in">mode</span>  yes    改为  protected-<span class="built_in">mode</span> no</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span> 默认bind <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>             改为  直接注释掉(默认bind <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>只能本机访问)或改成本机IP地址，否则影响远程IP连接</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span> 添加redis密码                      改为 requirepass 你自己设置的密码</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406144910139.png" alt="image-20250406144910139"></p>
<p><code>daemonize yes</code>：在后台启动</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406144931933.png" alt="image-20250406144931933"></p>
<p><code>proteccted-mode no</code>：关闭保护模式</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406144946561.png" alt="image-20250406144946561"></p>
<p><code>requirepass 密码</code>：添加redis密码</p>
</li>
<li><p>启动服务</p>
<p><code>/usr/local/bin</code>目录下运行<code>redis-server</code>，启用<code>/myredis</code>目录下的<code>redis.conf</code>文件</p>
</li>
<li><p>连接服务</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406145135039.png" alt="image-20250406145135039"></p>
<p>Warning: Using a password with ‘-a’ or ‘-u’ option on the command line interface may not be safe.</p>
<p>我看着不爽，怎么办？</p>
<p>warning 这串输出并不是普通输出，</p>
<p>shell的标准输出包含两种：</p>
<p>1（标准输出）</p>
<p>2（标准错误）我们的命令，即包含1也包含2，2即是我们想要去除的提示。</p>
<p>解决办法将标准错误去除即可，追加2&gt;&#x2F;dev&#x2F;null，将标准错误丢弃即可，就没有烦人的警告了。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406145229817.png" alt="image-20250406145229817"></p>
</li>
<li><p>关闭</p>
<ol>
<li>单实例关闭：<code>redis-cli -a redis密码 shutdown</code></li>
<li>多实例关闭，指定端口关闭：<code>redis-cli -p 6379 shutdown</code></li>
</ol>
</li>
</ol>
<h2 id="Redis卸载步骤"><a href="#Redis卸载步骤" class="headerlink" title="Redis卸载步骤"></a>Redis卸载步骤</h2><ol>
<li><p>停止<code>redis-server</code>服务</p>
<p><img src="/hexo-docs/images/redisImages/image-20250406145603470.png" alt="image-20250406145603470"></p>
</li>
<li><p>删除<code>/usr/local/lib</code>目录下与<code>redis</code>相关的文件</p>
<ol>
<li>ls -l &#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-*</li>
<li>rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-*</li>
<li><img src="/hexo-docs/images/redisImages/image-20250406145719940.png" alt="image-20250406145719940"></li>
</ol>
</li>
</ol>
<p>​</p>
<h2 id="Redis7新特性"><a href="#Redis7新特性" class="headerlink" title="Redis7新特性"></a>Redis7新特性</h2><table>
<thead>
<tr>
<th>多AOF文件支持</th>
<th>7.0 版本中一个比较大的变化就是 aof 文件由一个变成了多个，主要分为两种类型：基本文件(base files)、增量文件(incr files)，请注意这些文件名称是复数形式说明每一类文件不仅仅只有一个。在此之外还引入了一个清单文件(manifest) 用于跟踪文件以及文件的创建和应用顺序（恢复）</th>
</tr>
</thead>
<tbody><tr>
<td>config命令增强</td>
<td>对于Config Set 和Get命令，支持在一次调用过程中传递多个配置参数。例如，现在我们可以在执行一次Config Set命令中更改多个参数： config set maxmemory 10000001 maxmemory-clients 50% port 6399</td>
</tr>
<tr>
<td>限制客户端内存使用Client-eviction</td>
<td>一旦 Redis 连接较多，再加上每个连接的内存占用都比较大的时候， Redis总连接内存占用可能会达到maxmemory的上限，可以增加允许限制所有客户端的总内存使用量配置项，redis.config 中对应的配置项&#x2F;&#x2F; 两种配置形式：指定内存大小、基于 maxmemory 的百分比。maxmemory-clients 1gmaxmemory-clients 10%</td>
</tr>
<tr>
<td>listpack紧凑列表调整</td>
<td>listpack 是用来替代 ziplist 的新数据结构，在 7.0 版本已经没有 ziplist 的配置了（6.0版本仅部分数据类型作为过渡阶段在使用）listpack 已经替换了 ziplist 类似 hash-max-ziplist-entries 的配置</td>
</tr>
<tr>
<td>访问安全性增强ACLV2</td>
<td>在redis.conf配置文件中，protected-mode默认为yes，只有当你希望你的客户端在没有授权的情况下可以连接到Redis server的时候可以将protected-mode设置为no</td>
</tr>
<tr>
<td>Redis Functions</td>
<td>Redis函数，一种新的通过服务端脚本扩展Redis的方式，函数与数据本身一起存储。简言之，redis自己要去抢夺Lua脚本的饭碗</td>
</tr>
<tr>
<td>RDB保存时间调整</td>
<td>将持久化文件RDB的保存规则发生了改变，尤其是时间记录频度变化</td>
</tr>
<tr>
<td>命令新增和变动</td>
<td>Zset (有序集合)增加 ZMPOP、BZMPOP、ZINTERCARD 等命令Set (集合)增加 SINTERCARD 命令LIST (列表)增加 LMPOP、BLMPOP ，从提供的键名列表中的第一个非空列表键中弹出一个或多个元素。</td>
</tr>
<tr>
<td>性能资源利用率、安全、等改进</td>
<td>自身底层部分优化改动，Redis核心在许多方面进行了重构和改进主动碎片整理V2：增强版主动碎片整理，配合Jemalloc版本更新，更快更智能，延时更低HyperLogLog改进：在Redis5.0中，HyperLogLog算法得到改进，优化了计数统计时的内存使用效率，7更加优秀更好的内存统计报告</td>
</tr>
</tbody></table>
<p>Redis 命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis  执行了make install后，redis的课执行文件都会自动复制到 /usr/local/bin 目录</span><br><span class="line">redis-server        redis服务器</span><br><span class="line">redis-cli            redis命令行客户端</span><br><span class="line">redis-benchmark        redis性能测试工具</span><br><span class="line">redis-check-aof        aof文件修复工具</span><br><span class="line">redis-check-dump    rdb文件检查工具</span><br></pre></td></tr></table></figure>

<h2 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h2><ol>
<li><p>启动配置文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-server /myredis/redis7.conf # /myredis/redis7.conf 为配置文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">auth 用户名</span><br></pre></td></tr></table></figure>
</li>
<li><p>或</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-cli -a 用户名 -p 端口号</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>不输入 <code>-p 端口号</code> 默认会找 <code>6379</code></p>
</blockquote>
<p>停止</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>



<h2 id="添加中文支持"><a href="#添加中文支持" class="headerlink" title="添加中文支持"></a>添加中文支持</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-cli -a 密码 -p 端口号 --raw  # --raw 添加中文支持</span><br></pre></td></tr></table></figure>



<h2 id="Redis十大数据类型："><a href="#Redis十大数据类型：" class="headerlink" title="Redis十大数据类型："></a>Redis十大数据类型：</h2><h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><code>String</code>是<code>redis</code>最基本的类型，一个<code>key</code>对应一个<code>value</code></p>
<p><code>String</code>类型是二进制安全的（支持序列号），意思是<code>redis</code>的<code>String</code>可以包含任何数据，比如<code>jpg</code>图片或者序列号对象</p>
<p><code>String</code>类型是<code>Redis</code>最基本的数据类型，一个<code>Redis</code>中字符串<code>value</code>最多可以是512MB</p>
<h4 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h4><p><img src="/hexo-docs/images/redisImages/key.png"></p>
<ol>
<li><code>keys *</code>：查看当前库所有的key</li>
<li><code>exists key</code>：判断某个key是否存在</li>
<li><code>type key</code>：查看你的key是什么类型</li>
<li><code>del key</code>：删除指定的key数据</li>
<li><code>unlink key</code>：非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</li>
<li><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li><code>expire key 秒钟</code>：为给定的key设置过期时间</li>
<li><code>move key dbindex【0-15】</code>：将当前数据库的key移动到给定的数据库<code>dbindex【0-15】</code>当中</li>
<li><code>select dbindex</code>：切换数据库【0-15】，默认为0</li>
<li><code>dbsize</code>：查看当前数据库key的数量</li>
<li><code>flushdb</code>：清空当前库</li>
<li><code>flushall</code>：通杀全部库</li>
<li><code>help @*</code>：* 表示所有命令，都可以通过help来查看帮助文档</li>
</ol>
<blockquote>
<p>命令不区分大小写，但是名字区分大小写</p>
</blockquote>
<h4 id="String-类型的-API"><a href="#String-类型的-API" class="headerlink" title="String 类型的 API"></a>String 类型的 API</h4><p><img src="/hexo-docs/images/redisImages/string%E5%91%BD%E4%BB%A4.png"></p>
<h5 id="set-指令"><a href="#set-指令" class="headerlink" title="set 指令"></a>set 指令</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-<span class="built_in">time</span>-seconds|PXAT unix-<span class="built_in">time</span>-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406163641212.png" alt="image-20250406163641212"></p>
<ol>
<li><code>set key value [ex seconds]</code> ：设置带有过期时间的键值对 单位：秒,效果等同于<code>setex key seconds value</code>，成功返回“OK”，如果对在有效时间内存在的键值对重新使用该命令，则value会被覆盖，有效时间也会被覆盖，并重新开始计时。</li>
<li><code>set key value [px milliseconds] </code>：设置带有过期时间的键值对  单位：毫秒,效果等同于<code>psetex key milliseconds value</code>，成功返回“OK”。如果对在有效时间内存在的键值对重新使用该命令，则value会被覆盖，有效时间也会被覆盖，并重新开始计时。</li>
<li><code>set key value nx</code>： 设置key-value的键值对，如果之前该键key不存在，则设置执行操作，返回值“OK”,如果之前键值对存在，则不会执行操作，返回“（nil）”，效果等同于<code>setnx key value</code>，但是后者成功返回值1，失败返回值0。</li>
<li><code>set key value xx</code>： 设置key-value的键值对,只有之前该键值key对已经存在的时候才会执行操作（value会被覆盖），返回“OK”，若之前不存在则不会执行，返回“nil”。</li>
</ol>
<h5 id="同时设置-获取多个键值"><a href="#同时设置-获取多个键值" class="headerlink" title="同时设置&#x2F;获取多个键值"></a>同时设置&#x2F;获取多个键值</h5><p>设置多个值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mset k1 v1 k2 v2 .... #输出 v1 v2</span><br></pre></td></tr></table></figure>

<p><code>msetnx</code>：如果不存在创建成功</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">msetnx k1 v1 k2 v2 ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假如k1已经存在，k4不存在，则都不执行成功</p>
</blockquote>
<p>获取多个值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mget k1 k2 ...</span><br></pre></td></tr></table></figure>

<p><code>mget</code>：都存在才会执行成功</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mget k1 k2 k3 k4 k5 ....</span><br></pre></td></tr></table></figure>

<h5 id="获取指定区间范围内的值"><a href="#获取指定区间范围内的值" class="headerlink" title="获取指定区间范围内的值"></a>获取指定区间范围内的值</h5><p><code>getrange</code>：获取指定区间的值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">getrange k1 <span class="number">0</span> <span class="number">4</span> # 获取k1的 <span class="number">0</span> <span class="number">5</span>是区间的范围，默认从<span class="number">0</span>开始</span><br></pre></td></tr></table></figure>

<p><code>setrange</code>：设置指定区间的值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">setrange k1 <span class="number">3</span> xxxx #设置k1从<span class="number">3</span>往后的值为xxx</span><br></pre></td></tr></table></figure>

<h5 id="数值的增减"><a href="#数值的增减" class="headerlink" title="数值的增减"></a>数值的增减</h5><blockquote>
<p>注意：一定要是数字才能进行加减</p>
</blockquote>
<h6 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a>递增数字</h6><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure>

<h6 id="增加指定的整数"><a href="#增加指定的整数" class="headerlink" title="增加指定的整数"></a>增加指定的整数</h6><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">incrby key x</span><br><span class="line"><span class="function">key: 代表变量名</span></span><br><span class="line"><span class="function"><span class="title">x</span>：代表增加的数字</span></span><br></pre></td></tr></table></figure>

<h6 id="递减数值"><a href="#递减数值" class="headerlink" title="递减数值"></a>递减数值</h6><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">decr key</span><br></pre></td></tr></table></figure>

<h6 id="减少指定的整数"><a href="#减少指定的整数" class="headerlink" title="减少指定的整数"></a>减少指定的整数</h6><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">decrby key x</span><br><span class="line">key：代表变量名</span><br><span class="line">x：代表递减的数字</span><br></pre></td></tr></table></figure>

<h5 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">strlen key</span><br><span class="line">key：表示变量名</span><br></pre></td></tr></table></figure>

<h5 id="字符串长度和内容追加"><a href="#字符串长度和内容追加" class="headerlink" title="字符串长度和内容追加"></a>字符串长度和内容追加</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">append</span> key value</span><br><span class="line">key：表示变量名</span><br><span class="line">value：表示要增加的字符</span><br></pre></td></tr></table></figure>

<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">setnx key value # 如果不存在把变量和值加上</span><br><span class="line">key：变量名</span><br><span class="line">value：值</span><br><span class="line">setex(<span class="built_in">set</span> with expire)键秒值/setnx(<span class="built_in">set</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span>)</span><br></pre></td></tr></table></figure>

<p><code>set key vlaue 【ex seconds】【px milliseconds】 【nx|xx】</code></p>
<p><code>ex：key在多少秒后过期</code><br><code>px：key在多少毫秒之后过期</code><br><code>nx：当key不存在的时候，才创建key，效果等同于setnx</code><br><code>xx：当key存在的时候，覆盖key</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">setex k1 <span class="built_in">time</span> value</span><br><span class="line">k1：表示变量名</span><br><span class="line"><span class="built_in">time</span>：表示过期事件</span><br><span class="line">value：表示变量名的值</span><br></pre></td></tr></table></figure>

<p><code>setnx</code>：只有在key不存在设置key值</p>
<h6 id="getset-先get在set-先获取值，在设置值"><a href="#getset-先get在set-先获取值，在设置值" class="headerlink" title="getset(先get在set)先获取值，在设置值"></a>getset(先get在set)先获取值，在设置值</h6><p>getset：将给定key的值设为value，并返回key的旧值（old value）。简单一句话，先get然后立即set</p>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><blockquote>
<p>特点：单key多value</p>
</blockquote>
<p><code>Redis</code>列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>它的底层实际是个双端链表，最多可以包含 2³²-1 个元素（4294967295，每个列表超过40亿个元素）,主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加：</p>
<p>如果键不存在，创建新的链表</p>
<p>如果键已存在，新增内容</p>
<p>如果值全移除，对应的键也就消失了。</p>
<blockquote>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差</p>
</blockquote>
<p><img src="/hexo-docs/images/redisImages/list.png"></p>
<p><img src="/hexo-docs/images/redisImages/list%E5%91%BD%E4%BB%A4.png"></p>
<h4 id="常用操作命令-L是从左到右，R是从右到左"><a href="#常用操作命令-L是从左到右，R是从右到左" class="headerlink" title="常用操作命令(L是从左到右，R是从右到左)"></a>常用操作命令(L是从左到右，R是从右到左)</h4><ol>
<li><code>lpop key count</code>：移除并获取到第count个元素</li>
<li><code>lpush key value 【value2】</code>：将一个或多个值插入到列表头部</li>
<li><code>lpushx key value</code>：将一个或多个值插入到已存在的列表头部</li>
<li><code>lrange key start stop</code>：获取列表指定范围内的元素，start是开始，stop结束</li>
<li><code>lrem key count value</code>：移除列表重复的元素，count移除几个重复的元素，value元素值</li>
<li><code>lset key index value</code>：通过索引设置列表元素的值，index索引，value要设定的值</li>
<li><code>ltrim key start stop</code>：截取指定索引区间的元素，格式是 ltrim list的key 起始索引，结束索引</li>
<li><code>rpop key count</code>：移除并获取列表最后count个元素</li>
<li><code>rpoplpush source destination</code>：移除列表的最后一个元素，并将该元素添加到另一个列表并返回，就是将source的头一个元素，给destination的尾元素</li>
<li><code>rpush key value [value2]</code>：在列表中添加一个或多个值</li>
<li><code>rpushx key value</code>：为已存在的列表添加值</li>
<li><code>llen key</code>：获取列表中元素的个数</li>
<li><code>lindex key index</code>：按照索引下标获得元素（从上到下），key表示变量名，index表示索引</li>
<li><code>linsert key before/after oldValue newValue</code>：已有值插入的新值，key变量名，before&#x2F;after 前或后，oldValue：key的已有值，newValue要插入的值</li>
</ol>
<p><code>rpush/lpush/lrange</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406172123946.png" alt="image-20250406172123946"></p>
<p><code>rpop/lpop</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406172356511.png" alt="image-20250406172356511"></p>
<p><code>lrem/lset</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406172732940.png" alt="image-20250406172732940"></p>
<p><code>ltrim</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406173052157.png" alt="image-20250406173052157"></p>
<p><code>rpoplpush</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406173317366.png" alt="image-20250406173317366"></p>
<p><code>llen/lindex</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406173508097.png" alt="image-20250406173508097"></p>
<p><code>linsert</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250406173742983.png" alt="image-20250406173742983"></p>
<h3 id="哈希表（Hash）"><a href="#哈希表（Hash）" class="headerlink" title="哈希表（Hash）"></a>哈希表（Hash）</h3><p>特点：KV模式不变，但V是一个键值对</p>
<p><code>Redis hash</code>是一个<code>String</code>类型的<code>field</code>（字段）和<code>value</code>（值）的映射表，hash特别适合用于存储对象。</p>
<p><code>Redis</code>中每个<code>hash</code>可以存储  键值对（40多亿）</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><img src="/hexo-docs/images/redisImages/hash%E5%91%BD%E4%BB%A4.png"></p>
<p><code>hset key filed value</code>：设置值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hset user:<span class="number">001</span> id <span class="number">11</span> name z3 age <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p><code>hget key filed value</code> ：获取值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hget user:<span class="number">001</span> name</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406175251833.png" alt="image-20250406175251833"></p>
<p><strong><code>hmset/hmget</code>可以进行批处理</strong></p>
<p><code>hmset key filed value</code>：设置值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hmest user:<span class="number">001</span> id <span class="number">12</span> name li4 age <span class="number">26</span> </span><br></pre></td></tr></table></figure>

<p><code>hmget key filed value</code>：获取值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hmget user:<span class="number">001</span> id name age</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406175459761.png" alt="image-20250406175459761"></p>
<p><code>hgetall key</code>：遍历key的所有属性和值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hgetall user:<span class="number">001</span></span><br></pre></td></tr></table></figure>

<p><code>hdel key filed value</code>：删除指定的元素</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hdel user:<span class="number">001</span> age</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406175551830.png" alt="image-20250406175551830"></p>
<p><code>hlen key</code>：获取key的长度</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hlen user:<span class="number">001</span></span><br></pre></td></tr></table></figure>

<p><code>hexists key</code>：在key里面的某个值的key</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexists user:<span class="number">001</span> name</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406175725012.png" alt="image-20250406175725012"></p>
<p><code>hkeys key</code>：获取key里面的属性</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hkeys hash1</span><br></pre></td></tr></table></figure>

<p><code>hvals key</code>：获取key里面的所有value值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hvals hash2</span><br></pre></td></tr></table></figure>

<p><code>hincrby key filed value</code>：对某个整数的值加value</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hincrby user:<span class="number">001</span> age <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406175903212.png" alt="image-20250406175903212"></p>
<p><code>hincrbyfloat key filed value</code>：对某个浮点数的值加value</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hincrbyfloat user:<span class="number">001</span> score <span class="number">0</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>hsetnx key fuked value</code>：不存在赋值成功&#x2F;新建成功，存在了无效</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hsetnx user:<span class="number">001</span> email zzssww@qq.com</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250406180220994.png" alt="image-20250406180220994"></p>
<h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>特点：单值多value，且无重复</p>
<p><code>Redis</code>的<code>Set</code>是<code>String</code>类型的无序集合，集合成员是唯一的，这就意味着不能出现重复的数据，集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code></p>
<p><code>Redis</code> 中 <code>Set</code>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1) 。</p>
<p>集合中最大的成员数 2³²-1 (4294967295，每个集合可存储40多亿个成员)</p>
<p><code>sadd key member[member ...]</code>：添加元素，自动去重</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sadd set1 <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>smembers key</code>：遍历集合中的所有元素</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">smembers set1</span><br></pre></td></tr></table></figure>

<p><code>sismember key member</code>：判断member属性值是否在集合中</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sismember set1 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409154617663.png" alt="image-20250409154617663"></p>
<p><code>srem key member[member ...]</code>：删除member元素</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">srem set1 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>scard key</code>：获取集合里面的元素个数</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">scard set1</span><br></pre></td></tr></table></figure>

<p><code>srandmember key [数字]</code>：从集合中随机展现设置的数字个数元素，元素不删除</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">srandomember set1 <span class="number">1</span> # 从set1集合展现<span class="number">1</span>个元素</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409154749391.png" alt="image-20250409154749391"></p>
<p><code>spop key [数字]</code>：从集合中随机弹出一个元素，出一个删一个</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">spop set1 <span class="number">1</span> #随机弹出一个元素</span><br></pre></td></tr></table></figure>

<p><code>smove key1 key2 member</code>：在key1里已存在的某个值，将key1里已存在的某个值赋值给key2集合运算</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">smove set1 set2 <span class="number">7</span> #将set1中的<span class="number">7</span>移动到set2里面</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409154951035.png" alt="image-20250409154951035"></p>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><p>A、B 两个集合，A的元素是abc12，B的元素是123ax</p>
<ol>
<li><p>集合的差集运算 A-B</p>
<p>属于A但不属于B的元素构成的集合</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sdiff key [key...]</span><br><span class="line">例：</span><br><span class="line">sdiff set2 set1 # set2 和 set1 的差集</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409155136630.png" alt="image-20250409155136630"></p>
</li>
<li><p>集合的并集运算 A ∪ B</p>
<p>属于A或者属于B的元素合并后的集合</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sunion key [key...]</span><br><span class="line">例：</span><br><span class="line">sunion set1 set2 # set1 和 set2 的并集</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合的交集运算 A ∩ B</p>
<p>属于 A 同时也属于 B 的共同拥有的元素构成的集合</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sinter key [key...]</span><br><span class="line">例：</span><br><span class="line">sinter set1 set2 # set1 和 set2 的交集</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409155245778.png" alt="image-20250409155245778"></p>
</li>
</ol>
<p><code>sintercard numkeys key [key...][limit limit]</code></p>
<p>redis7新命令</p>
<p>它不返回结果集，而只返回结果的基数（去重以后的数字个数）。返回由所有给定集合的交集产生的集合的基数（返回重复的个数）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sinetercard <span class="number">2</span> set1 set2 limit <span class="number">1</span> # <span class="number">2</span>个key set1 和 set2 只显示 <span class="number">1</span>个</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409155446974.png" alt="image-20250409155446974"></p>
<h3 id="有序集合（ZSet（sorted-set））"><a href="#有序集合（ZSet（sorted-set））" class="headerlink" title="有序集合（ZSet（sorted set））"></a>有序集合（ZSet（sorted set））</h3><p><code>zset</code>(<code>sorted set</code>：有序集合)</p>
<p>在 set 基础上，每个val值前加一个score分数值。之前set是k1 v1 v2 v3</p>
<p>现在zset是k1 score v1 score2 v2</p>
<p><code>Redis zset</code>和<code>set</code>一样也是<code>String</code>类型元素的集合，且不允许重复的成员。</p>
<blockquote>
<p>不同的是每个元素都会关联一个<code>double</code>类型的分数，<code>redis</code>正是通过分数来为集合中的成员进行从小到大的排序。</p>
</blockquote>
<blockquote>
<p><code>zset</code>的成员是唯一的，但分数<code>(score)</code>却可以重复</p>
</blockquote>
<blockquote>
<p><code>zset</code>集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O（1）。集合中最大的成员数为 2³²-1</p>
</blockquote>
<p>向有序集合中加入一个元素和该元素的分数</p>
<p>添加元素：</p>
<p><code>zadd key score member [score member...]</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zadd zset1 <span class="number">60</span> v1 <span class="number">80</span> v2 <span class="number">90</span> v3 <span class="number">100</span> v5</span><br></pre></td></tr></table></figure>



<p>按照元素分数从小到大的顺序，返回索引从start到stop之间的所有元素：</p>
<p><code>zrange key start stop [withscores]</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zrange zset <span class="number">0</span> -<span class="number">1</span> # 遍历所有</span><br><span class="line">zrange zset <span class="number">0</span> -<span class="number">1</span> withscores # 遍历所有包括分数</span><br></pre></td></tr></table></figure>



<p>逆序按照元素分数从小到大的顺序，返回索引从start到stop之间的所有元素</p>
<p><code>zrevrange</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zrevrange zset <span class="number">0</span> -<span class="number">1</span> withscores # 逆序遍历包括分数</span><br><span class="line">zrevrange zset <span class="number">0</span> -<span class="number">1</span> # 逆序遍历所有</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409170419443.png" alt="image-20250409170419443"></p>
<p>获取指定分数范围的元素：</p>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code></p>
<p>withscores：包括变量名</p>
<p>(：不包含</p>
<p>limit：作用是返回限制，limit开始下标步，多少步</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zrangebyscore zset1 <span class="number">60</span> <span class="number">90</span> # 按照分数找变量名</span><br><span class="line">zrangebyscore zset1 <span class="number">60</span> <span class="number">90</span> withscores # 按照分数遍历变量和值</span><br><span class="line">zrangebyscore zset1 （<span class="number">60</span> <span class="number">90</span> withscores # 按分数遍历变量和值，不包含<span class="number">60</span></span><br><span class="line">zrangebyscore zset1 （<span class="number">60</span> <span class="number">90</span> withscores limit <span class="number">0</span> <span class="number">1</span>  # 按照分数遍历变量和值，不包含<span class="number">60</span>，返回一个键值对</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409171225792.png" alt="image-20250409171225792"></p>
<p>获取元素的分数：</p>
<p><code>zscore key member</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zscore zset1 v1 # 获取 v1 元素的分数</span><br></pre></td></tr></table></figure>



<p>获取集合中元素的数量：</p>
<p><code>zcard key</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zcard zset1 # 获取 zset1 的集合数量</span><br></pre></td></tr></table></figure>



<p>某score下对应的value值，作用是删除元素</p>
<p><code>zrem key</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zrem zset1 v5 # 删除 v5 元素</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409171654381.png" alt="image-20250409171654381"></p>
<p>增加某个元素的分数：</p>
<p><code>zincrby key incrmenet member</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zincrby zset1 <span class="number">3</span> v1 # 给v1的值增加<span class="number">3</span>分</span><br></pre></td></tr></table></figure>



<p>获得指定分数范围内的元素个数：</p>
<p><code>zcount key min max</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zcount zset1 <span class="number">60</span> <span class="number">100</span> # 获取 <span class="number">60</span> 到 <span class="number">100</span> 分数的值有多少个</span><br></pre></td></tr></table></figure>



<p>从键名列表中的第一个非空排序集中弹出一个或多个元素，它们是成员分数对</p>
<p><code>zmpop</code> redis 7.0 新命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zmpop <span class="number">1</span> zset min count <span class="number">1</span> # 把最小的键值对给弹出，显示弹出的键值对</span><br></pre></td></tr></table></figure>



<p>获得下标值：</p>
<p><code>zrange key values</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zrange zset <span class="number">0</span> -<span class="number">1</span> # 获得 zset的变量名</span><br></pre></td></tr></table></figure>



<p>逆序获得下标值</p>
<p><code>zrevrank key values</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">zrevrank zset v1 # 获得逆序的下标值</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409172544136.png" alt="image-20250409172544136"></p>
<h3 id="位图（bitmap）"><a href="#位图（bitmap）" class="headerlink" title="位图（bitmap）"></a>位图（bitmap）</h3><p><code>Bit arrays （or simply bitmaps，我们可以称之为位图）</code></p>
<img src="/images/redisImages/bitmaps.png" style="zoom:60%;" />

<p>一个字节(一个byte)&#x3D;8位</p>
<p>上图由许许多多的小格子组成，每一个格子里面只能放1或者0，用它来判断Y&#x2F;N状态，说的专业点，就是每一个小格子就是一个个bit</p>
<p>由0和1状态表现的二进制位的bit数组</p>
<p>说明：用String类型作为底层数据结构实现的一种统计二值状态的数据类型</p>
<p>位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们称之为一个索引)。</p>
<p>Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2^32 &#x3D; 4294967296)</p>
<p><code>setbit</code>设置bit：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409180618769.png" alt="image-20250409180618769"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250409180842482.png" alt="image-20250409180842482"></p>
<p><code>gitbit</code>获取某个bit的值：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409180948310.png" alt="image-20250409180948310"></p>
<p><code>strlen</code>统计字节占用多少：</p>
<p>不是字符串长度而是占据几个字节，超过8位后自己按照8位一组一byte再扩容</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409181059541.png" alt="image-20250409181059541"></p>
<p><code>bitcount</code>全部键里面含有多少1：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bitcount key</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250409181139433.png" alt="image-20250409181139433"></p>
<p><code>bitop</code>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bitop and destkey key key # 两个key合并放到destkey里面</span><br></pre></td></tr></table></figure>



<p><img src="/hexo-docs/images/redisImages/image-20250409181646736.png" alt="image-20250409181646736"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250409181818185.png" alt="image-20250409181818185"></p>
<h3 id="基数统计（HyperLogLog）属于String-类型"><a href="#基数统计（HyperLogLog）属于String-类型" class="headerlink" title="基数统计（HyperLogLog）属于String 类型"></a>基数统计（HyperLogLog）属于String 类型</h3><p><img src="/hexo-docs/images/redisImages/image-20250409182113564.png" alt="image-20250409182113564"></p>
<p><code>HyperLogLog</code>是用来做**<u>基数统计</u>**的算法，<code>HyperLogLog</code>的优点是，在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定且很小的。</p>
<p>在<code>Redis</code>里面，每个<code>HyperLogLog</code>键只需要花费 12KB 内存，就可以计算接近 2^64 个不同元素的基数，这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为<code>HyperLogLog</code>只会根据输入元素来计算基数，而不会存储元素本身，所以<code>HyperLogLog</code>不能像集合那样，返回输入的各个元素。</p>
<p><code>PFADD</code>将所有元素参数添加到 HyperLogLog 数据结构中：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PFADD key element [element ...]</span><br></pre></td></tr></table></figure>

<p><code>PFCOUNT</code>返回给定 HyperLogLog 的基数估算值：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PFCOUNT key [key ...]</span><br></pre></td></tr></table></figure>

<p><code>PFMERGE</code>将多个 HyperLogLog 合并为一个 HyperLogLog ，合并后的 HyperLogLog 的基数估算值是通过对所有 给定 HyperLogLog 进行并集计算得出的：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410160818942.png" alt="image-20250410160818942"></p>
<h3 id="地理空间（GEO）"><a href="#地理空间（GEO）" class="headerlink" title="地理空间（GEO）"></a>地理空间（GEO）</h3><p>移动互联网时代LBS应用越来越多，交友软件中附近的小姐姐、外卖软件中附近的美食店铺、高德地图附近的核酸检查点等等，那这种附近各种形形色色的XXX地址位置选择是如何实现的？</p>
<p>地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。</p>
<p>例如滴滴打车，最直观的操作就是实时记录更新各个车的位置，</p>
<p>然后当我们要找车时，在数据库中查找距离我们(坐标x0,y0)附近r公里范围内部的车辆</p>
<p>使用如下SQL即可：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">select taxi from position where x0-r &lt; x &lt; x0 + r and y0-r &lt; y &lt; y0+r</span><br></pre></td></tr></table></figure>

<p>但是这样会有什么问题呢？</p>
<p>1.查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的</p>
<p>2.这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。</p>
<p>3.精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差</p>
<p><code>Redis GEO</code>主要用于存储地理位置信息，并对于存储的信息进行操作，包括：</p>
<ol>
<li>添加地理位置的坐标</li>
<li>获取地理位置的坐标</li>
<li>计算两个位置之间的距离</li>
<li>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410162957806.png" alt="image-20250410162957806"></p>
<p>命令：</p>
<p><strong>GEOADD</strong>：添加地理位置</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410163315401.png" alt="image-20250410163315401"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GEOADD city <span class="number">116</span>.<span class="number">403963</span> <span class="number">39</span>.<span class="number">915119</span> &quot;天安门&quot; <span class="number">116</span>.<span class="number">403414</span> <span class="number">39</span>.<span class="number">924091</span> &quot;故宫&quot; <span class="number">116</span>.<span class="number">024067</span> <span class="number">40</span>.<span class="number">362639</span> &quot;长城&quot;</span><br></pre></td></tr></table></figure>

<p><strong>GEOPOS</strong>：获取指定的经纬度</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410163507481.png" alt="image-20250410163507481"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GEOPOS city 天安门 故宫 长城</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250410163723293.png" alt="image-20250410163723293"></p>
<p><strong>GEOHASN</strong>：使用hash值来保存地理位置的坐标</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410163750436.png" alt="image-20250410163750436"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GEOHASH city 天安门 故宫 长城</span><br></pre></td></tr></table></figure>

<p><strong>GEOLIST</strong>：返回两个给定位置之间的距离</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410164012610.png" alt="image-20250410164012610"></p>
<p>后面参数是距离单位：</p>
<ol>
<li>m 米</li>
<li>km 千米</li>
<li>ft 英尺</li>
<li>mi 英里</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GEODIST city 天安门 故宫 km</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250410164156033.png" alt="image-20250410164156033"></p>
<p>**GEORADIUS(以半径为中心)**： 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GEORADIUS city <span class="number">116</span>.<span class="number">418017</span> <span class="number">39</span>.<span class="number">914402</span> <span class="number">10</span> km withdist withcoord count <span class="number">10</span> withhash desc</span><br><span class="line">GEORADIUS city <span class="number">116</span>.<span class="number">418017</span> <span class="number">39</span>.<span class="number">914402</span> <span class="number">10</span> km withdist withcoord withhash count <span class="number">10</span> desc</span><br></pre></td></tr></table></figure>

<ol>
<li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li>
<li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大COUNT 限定返回的记录数。</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410164811698.png" alt="image-20250410164811698"></p>
<p><strong>GEORADIUSBYMEMBER</strong>：找出位于指定范围内的元素，中心点是由给定的位置元素决定的</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">GEORADIUSBYMEMBER  city 天安门 <span class="number">10</span> km withdist withcoord count <span class="number">10</span> withhash # 找出以天安门为中心，附近<span class="number">10</span>km的地方</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250410165223579.png" alt="image-20250410165223579"></p>
<h3 id="流（Stream"><a href="#流（Stream" class="headerlink" title="流（Stream)"></a>流（Stream)</h3><p><code>Redis Stream</code>是 <code>Redis 5.0</code>版本新增加的数据结构。</p>
<p><code>Redis Stream</code>主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 （pub&#x2F;sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开，Redis 宕机等，消息就会被丢弃。</p>
<p>简单来说发布订阅（pub&#x2F;sub）可以分发消息，但无法记录历史消息。</p>
<p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<p>Redis版的MQ消息中间件+阻塞队列</p>
<p><strong>能干嘛？</strong></p>
<p>实现消息队列，它支持消息的持久化，支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠</p>
<h4 id="底层结构和原理说明"><a href="#底层结构和原理说明" class="headerlink" title="底层结构和原理说明"></a>底层结构和原理说明</h4><p><img src="/hexo-docs/images/redisImages/image-20250410172029685.png" alt="image-20250410172029685"></p>
<table>
<thead>
<tr>
<th>1</th>
<th>Message Content</th>
<th>消息内容</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>Consumer group</td>
<td>消费组，通过XGROUP CREATE 命令创建，同一个消费组可以有多个消费者</td>
</tr>
<tr>
<td>3</td>
<td>Last_delivered_id</td>
<td>游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</td>
</tr>
<tr>
<td>4</td>
<td>Consumer</td>
<td>消费者，消费组中的消费者</td>
</tr>
<tr>
<td>5</td>
<td>Pending_ids</td>
<td>消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息Id，如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之为 PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</td>
</tr>
</tbody></table>
<h4 id="基本命令理论简介"><a href="#基本命令理论简介" class="headerlink" title="基本命令理论简介"></a>基本命令理论简介</h4><p><strong>队列相关指令</strong></p>
<p><img src="/hexo-docs/images/redisImages/image-20250410172141313.png" alt="image-20250410172141313"></p>
<p><strong>消费组相关指令</strong></p>
<p><img src="/hexo-docs/images/redisImages/image-20250410172214112.png" alt="image-20250410172214112"></p>
<p><strong>四个特殊符号</strong></p>
<ol>
<li>-：最小可能出现的id</li>
<li>+：最大可能出现的id</li>
<li>$：$表示只消费新的消息，当前流中最大的id，可用于将要到来的信息</li>
<li>&gt;：用于<code>XREADGROUP</code>命令，表现迄今还没有发送组中使用者的消息，会更新消费组的最后ID</li>
<li>*：用于<code>XADD</code>命令中，让系统自动生成id</li>
</ol>
<h4 id="基本命令实操"><a href="#基本命令实操" class="headerlink" title="基本命令实操"></a>基本命令实操</h4><h5 id="队列相关指令"><a href="#队列相关指令" class="headerlink" title="队列相关指令"></a>队列相关指令</h5><p><strong>XADD</strong>：添加消息队列到末尾</p>
<p>XADD 用于向Stream 队列中添加消息，如果指定的Stream 队列不存在，则该命令执行时会新建一个Stream 队列</p>
<p>* 号表示服务器自动生成 MessageID(类似mysql里面主键auto_increment)，后面顺序跟着一堆 业务key&#x2F;value</p>
<p>信息条目指的是序列号，在相同的毫秒下序列号从0开始递增，序列号是64位长度，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。millisecondsTime指的是Redis节点服务器的本地时间，如果存在当前的毫秒时间戳比以前已经存在的数据的时间戳小的话（本地时间钟后跳），那么系统将会采用以前相同的毫秒创建新的ID，也即redis 在增加信息条目时会检查当前 id 与上一条目的 id， 自动纠正错误的情况，一定要保证后面的 id 比前面大，一个流中信息条目的ID必须是单调增的，这是流的基础。<br><strong>客户端显示传入规则:</strong></p>
<p>Redis对于ID有强制要求，格式必须是时间戳-自增Id这样的方式，且后续ID不能小于前一个ID<br>Stream的消息内容，也就是图中的Message Content它的结构类似Hash结构，以key-value的形式存在。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410174747266.png" alt="image-20250410174747266"></p>
<blockquote>
<p>注意：</p>
<ol>
<li>消息ID必须要比上个ID大</li>
<li>默认用型号表示自动生成规矩</li>
<li>*：用于XDD命令中，让系统自动生成ID</li>
</ol>
</blockquote>
<p><strong>xrange</strong>：用于获取消息列表（可以指定范围），忽略删除的消息</p>
<ol>
<li>start 表示开始值，- 代表最小值</li>
<li>end 表示结束值，+ 代表最大值</li>
<li>count 表示最多获取多少个值</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410175418702.png" alt="image-20250410175418702"></p>
<p><strong>xrevrange</strong>：与<code>xrange</code>的区别在于，获取消息列表元素的方向是相反的，end在前，start在后</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410175614939.png" alt="image-20250410175614939"></p>
<p><strong>xdel</strong>：删除一条消息</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410175725471.png" alt="image-20250410175725471"></p>
<p><strong>xlen</strong>：用于获取stream队列的消息的长度</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410175746217.png" alt="image-20250410175746217"></p>
<p><strong>xtrim</strong>：用于对stream的长度进行截取，如超长会进行截取</p>
<ol>
<li><code>maxlen</code>：允许的最大长度，对流进行修剪限制长度</li>
<li><code>minid</code>：允许的最小id，从某id值开始比该id值小的将会被抛弃</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410180149257.png" alt="image-20250410180149257"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250410181006834.png" alt="image-20250410181006834"></p>
<p><strong>xread</strong>：用于获取消息（阻塞&#x2F;非阻塞），只会返回大于指定ID的消息</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410173811155.png" alt="image-20250410173811155"></p>
<ol>
<li><p>非阻塞</p>
<ol>
<li>$代表特殊ID，表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil</li>
<li>0-0代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0（00&#x2F;000也都是可以的……）</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410181716134.png" alt="image-20250410181716134"></p>
</li>
<li><p>阻塞</p>
</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410182230965.png" alt="image-20250410182230965"></p>
<p>总结：</p>
<p>​	Stream的基础方法，使用xadd存入消息和xread循环阻塞读取消息的方式可以实现简易版的消息队列，交互流程如下</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410173936545.png" alt="image-20250410173936545"></p>
<p>对比list结构</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410173951159.png" alt="image-20250410173951159"></p>
<h5 id="消费组相关指令"><a href="#消费组相关指令" class="headerlink" title="消费组相关指令"></a>消费组相关指令</h5><p><code>xgroup create</code>：用于创建消费组</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410184052182.png" alt="image-20250410184052182"></p>
<ol>
<li>$表示从Stream尾部开始消费</li>
<li>0表示从Stream头部开始消费</li>
<li>创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息，队尾新来</li>
</ol>
<p><code>xreadgroup group</code></p>
<ol>
<li><p>“&gt;”，表示从第一条尚未被消费的消息开始读取</p>
</li>
<li><p>消费组group内的消费组consumer从mystream消息队列中读取所有消息</p>
</li>
<li><p>但是，不同消费组的消费者可以消费同一条消息</p>
<p><img src="/hexo-docs/images/redisImages/image-20250410184654314.png" alt="image-20250410184654314"></p>
</li>
<li><p>消费组的目的？</p>
<p>让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</p>
</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410185005071.png" alt="image-20250410185005071"></p>
<table>
<thead>
<tr>
<th>1问题</th>
<th>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息保底措施，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</td>
</tr>
<tr>
<td>3</td>
<td>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成</td>
</tr>
</tbody></table>
<p><img src="/hexo-docs/images/redisImages/image-20250410183229300.png" alt="image-20250410183229300"></p>
<p><code>xpending</code>：</p>
<ol>
<li>查询每个消费组内所有消费者”已读取，但尚未确认”的消息</li>
<li>查看某个消费者具体读取了哪些数据</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250410185349874.png" alt="image-20250410185349874"></p>
<p><code>xack</code>：向消息队列确认消息处理已完成</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411220813033.png" alt="image-20250411220813033"></p>
<p><code>xinfo</code>：用于打印 stream\consumer\group\的详细信息</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411220856782.png" alt="image-20250411220856782"></p>
<h3 id="位域（bitfield）"><a href="#位域（bitfield）" class="headerlink" title="位域（bitfield）"></a>位域（bitfield）</h3><p>通过 <code>bitfield</code>命令可以一次性操作多个比特位域（指的是连续的多个比特位），它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</p>
<p>说白了就是通过<code>bitfield</code>命令我们可以一次性对比多个比特位域进行操作。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411223808858.png" alt="image-20250411223808858"></p>
<p>能干嘛？</p>
<ol>
<li>位域修改</li>
<li>溢出控制</li>
</ol>
<p><img src="/hexo-docs/images/redisImages/image-20250411221002550.png" alt="image-20250411221002550"></p>
<p><a target="_blank" rel="noopener" href="https://ascii.org.cn/">ascii码 | ascii码对照表</a></p>
<p>返回指定位域：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bitfield key [get <span class="built_in">type</span> offset]</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250411221551010.png" alt="image-20250411221551010"></p>
<ol>
<li>i：有符号数</li>
<li>u：无符号数</li>
<li>i8：读取8位</li>
</ol>
<p>hello 等价于 01101000 01100101 01101100 01101100 01101111</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411221656767.png" alt="image-20250411221656767"></p>
<p>设置指定位域并返回它的原值</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bitfield key [<span class="built_in">set</span> <span class="built_in">type</span> offset value]</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250411222138274.png" alt="image-20250411222138274"></p>
<p>二进制加一，默认情况下，<code>incrby</code> 使用wrap参数：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bitfield key [incrby <span class="built_in">type</span> offset increment]</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/redisImages/image-20250411222525532.png" alt="image-20250411222525532"></p>
<p>溢出控制<code>overflow[wrap|sat|fail]</code></p>
<ol>
<li><p>wrap：使用回绕（wrap around）方法处理有符号数和无符号数的溢出情况</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411223252108.png" alt="image-20250411223252108"></p>
</li>
<li><p>sat：使用饱和计算（saturation arithmetic）方法处理溢出，下溢计算的结果为最小的整数值，而上溢计算的结果为最大的整数值</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411223309327.png" alt="image-20250411223309327"></p>
</li>
<li><p>fail：命令将拒绝执行哪些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行</p>
<p><img src="/hexo-docs/images/redisImages/image-20250411223324513.png" alt="image-20250411223324513"></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs">Lazy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs/2025/08/13/redis/index/">https://mac2git.github.io/hexo-docs/2025/08/13/redis/index/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mac2git.github.io/hexo-docs" target="_blank">Lazy的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/hexo-docs/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://pic.crazytaxii.com/Redis_Logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/replica/" title="Replica(主从复制)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Replica(主从复制)</div></div><div class="info-2"><div class="info-item-1">复制（replica）就是主从复制，master以写为主，slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库 优点：  读写分离 容灾恢复 数据备份 水平扩容支撑高并发  如何使用  配从（库）不配主（库） 权限细节，重要 master 如果配置了 requirepass 参数，需要密码登录 那么 slave 就要配置 masterauth 来设置校验密码，否则的话 master 会拒绝 slave的访问请求      基本操作命令 info replication：可以查看复制节点的主从关系和配置信息 replicaof 主库IP 主库端口：一般写入进 redis.conf 配置文件内 slaveof 主库IP 主库端口 每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜主数据库   slaveof no one：使当前数据库停止与其他数据库的同步，转成...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/epoll%E5%87%BD%E6%95%B0%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="epoll函数和IO多路复用深度解析"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">epoll函数和IO多路复用深度解析</div></div><div class="info-2"><div class="info-item-1">epoll 函数和 IO 多路复用深度解析没有 epoll 和 IO 多路复用之前多路复用要解决的问题并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型 这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。 直接调用 recv 函数从一个 socket 上读取数据。 int main()&#123; ... recv(sock, ...) //从用户角度来看非常简单，一个recv一用，要接收的数据就到我们手里了。&#125;  我们来总结一下这种方式： 优点： 就是这种方式非常容易让人理解，写起代码来非常的自然，符合人的直线型思维。 缺点： 就是性能差，每个用户请求到来都得占用一个进程来处理，来一个请求就要分配一个进程跟进处理， 类似一个学生配一个老师，一位患者配一个医生，可能吗？进程是一个很笨重的东西。一台服务器上创建不了多少个进程。 结论进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理很多个 tcp 连接才行。现在假...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/Redlock%E7%AE%97%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="RedLock算法和底层源码分析和缓存淘汰策略"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">RedLock算法和底层源码分析和缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">上一章自研的redis锁对于一般中小公司，不是特别高并发场景足够用了，单机redis小业务也撑得住。但是对于特别高并发场景的话，就得使用Redisson了 Redis分布式锁-RedLock红锁算法（Distributed locks with Redis）官网：Redis 的分布式锁 |文档 说明：  为什么学习这个？怎样产生的？   线程 1 首先获取锁成功，将键值对写入 redis 的 master 节点，在 redis 将该键值对同步到 slave 节点之前，master 发生了故障；redis 触发故障转移，其中一个 slave 升级为新的 master，此时新上位的master并不包含线程1写入的键值对，因此线程 2 尝试获取锁也可以成功拿到锁，此时相当于有两个线程获取到了锁，可能会导致各种预期之外的情况发生，例如最常见的脏数据。  我们加的是排它独占锁，同一时间只能有一个建redis锁成功并持有锁，严禁出现2个以上的请求线程拿到锁。危险的！ RedLock算法设计理念Redis也提供了Redlock算法，用来实现基于多个实例的分布式锁。锁变量由多个实例维护，即使有实...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/RDB+AOF/" title="RDB+AOF"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">RDB+AOF</div></div><div class="info-2"><div class="info-item-1">redis数据数据持久化 为什么要用数据持久化？ 数据持久化可以在内存丢失或其他灾难性故障的情况下实现恢复。 数据持久化的两种方式  AOF：以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写入指令从前到后执行一次以完成数据的恢复工作。 RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。  rdb（redis database）能干嘛？ 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将硬盘快照文件直接读回到内存里。Redis的数据都在内存中，保存备份时它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，一锅端。 Rdb保存的是dump.rdb文件  Redis6.0.16以下  Redis6.2以及Redis-7.0.0  自动触发 redis7版本，按照redis.conf里配置的save&lt;seconds&gt;&lt...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/bigkey%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99/" title="BigKey和缓存双写"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">BigKey和缓存双写</div></div><div class="info-2"><div class="info-item-1">Redis为什么是单线程这种问法其实并不严谨，为啥这么说呢? Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。  版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。  版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是开始加了点多线程的东西(异步删除)。—貌似  2020年5月版本的6.0.x后及2022年出的7.0版本后，告别了大家印象中的单线程，用一种全新的多线程来解决问题。—实锤   几个里程碑的redis版本！  5.0版本是直接升级到6.0版本，对于这个激进的升级，Redis之父antirez表现得很有信心和兴奋， 所以第一时间发文来阐述6.0的一些重大功能”Redis 6.0.0 GA is out!” 当然，Redis7.0后版本更加厉害  Redis是单线程 主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/hyperloglogGeoBitmap/" title="HyperLogLog&amp;Geo&amp;Bitmap"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">HyperLogLog&amp;Geo&amp;Bitmap</div></div><div class="info-2"><div class="info-item-1">统计类型有哪些？ 亿级系统中常见的四种统计  聚合统计 统计多个集合元素的聚合结果，就是前面的交集差集等集合统计   排序统计（zset） 在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用ZSet  因为可以使用分页，正反排序  二值统计（bitmap） 集合元素的取值就只有0和1两种，在钉钉上班签到打开的场景中，我们只用记录有签到（1）和没签到（0）  基数统计（hyperloglog） 指 统计一个集合不重复元素个数     HyperLogLog名词解释  什么是UV?  Unique Visitor，独立访客，一般理解为客户端IP 需要去重考虑，例如一个人一天访问了10次网站，一天的UV就是1   什么是PV?  Page View，页面浏览量 不用去重，例如一个人一天访问了10次网站，一天的PV就是10   什么是DAU?  Daily  Active User  日活跃用户量 登录或者使用了某个产品的用户数（去重复登录的用户），避免恶意刷单  常用于反映网站，互联网应用或者网络游戏的运营情况      什么是MAU？  Monthly...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/pub&sub/" title="pub&amp;sub(发布&amp;订阅)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">pub&amp;sub(发布&amp;订阅)</div></div><div class="info-2"><div class="info-item-1">发布&#x2F;订阅是一种消息通信模式：发送者（publish）发送消息，订阅者（subscribe）接受消息，可以实现进程间的消息传递 Redis  可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。不推荐使用该功能，专业的事情交给专业的中间件，redis就做好分布式缓存功能 能干嘛？  redis 客户端可以订阅任意数量的频道，类似我们微信关注多个公众号   当有新的消息通过 publish 命令发送给频道 channel1 时     总结： 发布&#x2F;订阅其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理实时性较高的异步消息    常用命令  subscribe channel [channel...]   订阅给定的一个或多个频道的信息 推荐先执行订阅后再发布，订阅成功之前发布的消息是收不到的 订阅的客户端每次可以收到一个3个参数的消息 消息的种类 始发频道的名称 实际的消息内容         publish channel message    发布消息到指定的频道    psubscribe pattern[pattern...] ...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/epoll%E5%87%BD%E6%95%B0%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="epoll函数和IO多路复用深度解析"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">epoll函数和IO多路复用深度解析</div></div><div class="info-2"><div class="info-item-1">epoll 函数和 IO 多路复用深度解析没有 epoll 和 IO 多路复用之前多路复用要解决的问题并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型 这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。 直接调用 recv 函数从一个 socket 上读取数据。 int main()&#123; ... recv(sock, ...) //从用户角度来看非常简单，一个recv一用，要接收的数据就到我们手里了。&#125;  我们来总结一下这种方式： 优点： 就是这种方式非常容易让人理解，写起代码来非常的自然，符合人的直线型思维。 缺点： 就是性能差，每个用户请求到来都得占用一个进程来处理，来一个请求就要分配一个进程跟进处理， 类似一个学生配一个老师，一位患者配一个医生，可能吗？进程是一个很笨重的东西。一台服务器上创建不了多少个进程。 结论进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理很多个 tcp 连接才行。现在假...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lazy</div><div class="author-info-description">归途也还可爱</div><div class="site-data"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mac2git"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mac2git" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/wx_00ba6ce280" target="_blank" title="Gitee"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客正在施工，请先随便逛逛。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F"><span class="toc-text">什么是Redis？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDRedis"><span class="toc-text">下载Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81"><span class="toc-text">redis解决中文乱码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%AE%89%E8%A3%85Redis"><span class="toc-text">Linux安装Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8D%B8%E8%BD%BD%E6%AD%A5%E9%AA%A4"><span class="toc-text">Redis卸载步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis7%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">Redis7新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Redis"><span class="toc-text">启动Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81"><span class="toc-text">添加中文支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8D%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">Redis十大数据类型：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-text">字符串（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E9%94%AE%EF%BC%88key%EF%BC%89"><span class="toc-text">Redis键（key）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B%E7%9A%84-API"><span class="toc-text">String 类型的 API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set-%E6%8C%87%E4%BB%A4"><span class="toc-text">set 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE-%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC"><span class="toc-text">同时设置&#x2F;获取多个键值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%80%BC"><span class="toc-text">获取指定区间范围内的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E5%A2%9E%E5%87%8F"><span class="toc-text">数值的增减</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E6%95%B0%E5%AD%97"><span class="toc-text">递增数字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0"><span class="toc-text">增加指定的整数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%87%8F%E6%95%B0%E5%80%BC"><span class="toc-text">递减数值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0"><span class="toc-text">减少指定的整数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">获取字符串的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E5%92%8C%E5%86%85%E5%AE%B9%E8%BF%BD%E5%8A%A0"><span class="toc-text">字符串长度和内容追加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#getset-%E5%85%88get%E5%9C%A8set-%E5%85%88%E8%8E%B7%E5%8F%96%E5%80%BC%EF%BC%8C%E5%9C%A8%E8%AE%BE%E7%BD%AE%E5%80%BC"><span class="toc-text">getset(先get在set)先获取值，在设置值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-text">列表（List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-L%E6%98%AF%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%EF%BC%8CR%E6%98%AF%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6"><span class="toc-text">常用操作命令(L是从左到右，R是从右到左)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash%EF%BC%89"><span class="toc-text">哈希表（Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-text">集合（Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-text">集合运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88ZSet%EF%BC%88sorted-set%EF%BC%89%EF%BC%89"><span class="toc-text">有序集合（ZSet（sorted set））</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%EF%BC%88bitmap%EF%BC%89"><span class="toc-text">位图（bitmap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%88HyperLogLog%EF%BC%89%E5%B1%9E%E4%BA%8EString-%E7%B1%BB%E5%9E%8B"><span class="toc-text">基数统计（HyperLogLog）属于String 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%88GEO%EF%BC%89"><span class="toc-text">地理空间（GEO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%EF%BC%88Stream"><span class="toc-text">流（Stream)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E"><span class="toc-text">底层结构和原理说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B"><span class="toc-text">基本命令理论简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D"><span class="toc-text">基本命令实操</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">队列相关指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%BB%84%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">消费组相关指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%EF%BC%88bitfield%EF%BC%89"><span class="toc-text">位域（bitfield）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/11/17/other/springboot3%E6%96%B0%E7%89%B9%E6%80%A7/" title="SpringBoot3新特性"><img src="https://spring.io/img/projects/spring-boot.svg" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="SpringBoot3新特性"/></a><div class="content"><a class="title" href="/hexo-docs/2025/11/17/other/springboot3%E6%96%B0%E7%89%B9%E6%80%A7/" title="SpringBoot3新特性">SpringBoot3新特性</a><time datetime="2025-11-17T10:19:12.000Z" title="发表于 2025-11-17 18:19:12">2025-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/10/28/other/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" title="MySQL索引优化"><img src="/hexo-docs/images/mysql_idImages/cover.svg" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="MySQL索引优化"/></a><div class="content"><a class="title" href="/hexo-docs/2025/10/28/other/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" title="MySQL索引优化">MySQL索引优化</a><time datetime="2025-10-27T16:00:00.000Z" title="发表于 2025-10-28 00:00:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/10/22/MinIO/MinIO/" title="MinIO"><img src="https://www.minio.org.cn/resources/img/logo.svg" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="MinIO"/></a><div class="content"><a class="title" href="/hexo-docs/2025/10/22/MinIO/MinIO/" title="MinIO">MinIO</a><time datetime="2025-10-21T16:00:00.000Z" title="发表于 2025-10-22 00:00:00">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/24/pay/ali_pay/" title="支付宝沙箱环境支付"><img src="/hexo-docs/images/payImages/alipay.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="支付宝沙箱环境支付"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/24/pay/ali_pay/" title="支付宝沙箱环境支付">支付宝沙箱环境支付</a><time datetime="2025-09-23T16:00:00.000Z" title="发表于 2025-09-24 00:00:00">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/22/nginx/nginx/" title="Nginx"><img src="https://nginx.org/img/nginx_logo.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/22/nginx/nginx/" title="Nginx">Nginx</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Lazy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/hexo-docs/js/utils.js"></script><script src="/hexo-docs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="14px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/hexo-docs/js/search/local-search.js"></script></div></div></body></html>