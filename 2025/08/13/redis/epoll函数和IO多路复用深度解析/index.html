<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>epoll函数和IO多路复用深度解析 | Lazy的个人博客</title><meta name="author" content="Lazy"><meta name="copyright" content="Lazy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="epoll 函数和 IO 多路复用深度解析没有 epoll 和 IO 多路复用之前多路复用要解决的问题并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型 这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。 直接调用 recv 函数从一个 socket 上读取数据。 int main()&#123; ... recv(sock, ...">
<meta property="og:type" content="article">
<meta property="og:title" content="epoll函数和IO多路复用深度解析">
<meta property="og:url" content="https://mac2git.github.io/hexo-docs/2025/08/13/redis/epoll%E5%87%BD%E6%95%B0%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Lazy的个人博客">
<meta property="og:description" content="epoll 函数和 IO 多路复用深度解析没有 epoll 和 IO 多路复用之前多路复用要解决的问题并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型 这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。 直接调用 recv 函数从一个 socket 上读取数据。 int main()&#123; ... recv(sock, ...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.crazytaxii.com/Redis_Logo.png">
<meta property="article:published_time" content="2025-08-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-22T17:03:19.520Z">
<meta property="article:author" content="Lazy">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.crazytaxii.com/Redis_Logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "epoll函数和IO多路复用深度解析",
  "url": "https://mac2git.github.io/hexo-docs/2025/08/13/redis/epoll%E5%87%BD%E6%95%B0%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/",
  "image": "https://pic.crazytaxii.com/Redis_Logo.png",
  "datePublished": "2025-08-12T16:00:00.000Z",
  "dateModified": "2025-08-22T17:03:19.520Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lazy",
      "url": "https://mac2git.github.io/hexo-docs"
    }
  ]
}</script><link rel="shortcut icon" href="/hexo-docs/images/webImages/logo.svg"><link rel="canonical" href="https://mac2git.github.io/hexo-docs/2025/08/13/redis/epoll%E5%87%BD%E6%95%B0%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/hexo-docs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/hexo-docs/',
  algolia: undefined,
  localSearch: {"path":"/hexo-docs/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Lazy","link":"链接: ","source":"来源: Lazy的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'epoll函数和IO多路复用深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic.crazytaxii.com/Redis_Logo.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/hexo-docs/"><span class="site-name">Lazy的个人博客</span></a><a class="nav-page-title" href="/hexo-docs/"><span class="site-name">epoll函数和IO多路复用深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">epoll函数和IO多路复用深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-12T16:00:00.000Z" title="发表于 2025-08-13 00:00:00">2025-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-22T17:03:19.520Z" title="更新于 2025-08-23 01:03:19">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/hexo-docs/categories/%E5%90%8E%E7%AB%AF-Redis/">后端 Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="epoll-函数和-IO-多路复用深度解析"><a href="#epoll-函数和-IO-多路复用深度解析" class="headerlink" title="epoll 函数和 IO 多路复用深度解析"></a>epoll 函数和 IO 多路复用深度解析</h2><h3 id="没有-epoll-和-IO-多路复用之前"><a href="#没有-epoll-和-IO-多路复用之前" class="headerlink" title="没有 epoll 和 IO 多路复用之前"></a>没有 epoll 和 IO 多路复用之前</h3><h4 id="多路复用要解决的问题"><a href="#多路复用要解决的问题" class="headerlink" title="多路复用要解决的问题"></a>多路复用要解决的问题</h4><p>并发多客户端连接，在多路复用之前最简单和典型的方案：同步阻塞网络IO模型</p>
<p>这种模式的特点就是用一个进程来处理一个网络连接(一个用户请求)，比如一段典型的示例代码如下。</p>
<p>直接调用 <code>recv</code> 函数从一个 socket 上读取数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> recv(sock, ...) <span class="comment">//从用户角度来看非常简单，一个recv一用，要接收的数据就到我们手里了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来总结一下这种方式：</p>
<p>优点：</p>
<p>就是这种方式非常容易让人理解，写起代码来非常的自然，符合人的直线型思维。</p>
<p>缺点：</p>
<p>就是性能差，每个用户请求到来都得占用一个进程来处理，来一个请求就要分配一个进程跟进处理，</p>
<p>类似一个学生配一个老师，一位患者配一个医生，可能吗？进程是一个很笨重的东西。一台服务器上创建不了多少个进程。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理很多个 tcp 连接才行。现在假设一个进程保持了 10000 条连接，那么如何发现哪条连接上有数据可读了、哪条连接可写了 ？</p>
<p>我们当然可以采用循环遍历的方式来发现 IO 事件，但这种方式太低级了。</p>
<p>我们希望有一种更高效的机制，在很多连接中的某条上有 IO 事件发生的时候直接快速把它找出来。</p>
<p>其实这个事情 Linux 操作系统已经替我们都做好了，它就是我们所熟知的 IO 多路复用机制。</p>
<p>这里的复用指的就是对进程的复用</p>
<h3 id="IO-多路复用模型"><a href="#IO-多路复用模型" class="headerlink" title="IO 多路复用模型"></a>IO 多路复用模型</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul>
<li><p>IO：网络 I&#x2F;O</p>
</li>
<li><p>多路：多个客户端连接（连接就是套接字描述符，即 socket 或者 channel），指的是多条 TCP 连接</p>
</li>
<li><p>复用：用一个进程来处理多条的连接，使用单进程就能实现同时处理多个客户端的连接</p>
</li>
<li><p>一句话</p>
<ul>
<li><p>实现了用一个进程来处理大量的用户连接</p>
</li>
<li><p>IO 多路复用类似于一个规范和接口，落地实现</p>
<ul>
<li>可以分 <code>select -&gt; poll -&gt; epoll</code>三个阶段来描述</li>
</ul>
</li>
<li><p>动画演示</p>
<p><code>IO multiplexing.gif</code></p>
<p><img src="data:image/gif;base64,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" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h4 id="redis-单线程如何处理那么多并发客户端连接，为什么单线程，为什么块"><a href="#redis-单线程如何处理那么多并发客户端连接，为什么单线程，为什么块" class="headerlink" title="redis 单线程如何处理那么多并发客户端连接，为什么单线程，为什么块"></a>redis 单线程如何处理那么多并发客户端连接，为什么单线程，为什么块</h4><p>Redis的IO多路复用</p>
<p>Redis利用epoll函数来实现IO多路复用，将连接信息和事件放到队列中，一次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721165723132.png" alt="image-20250721165723132"></p>
<p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I&#x2F;O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I&#x2F;O 阻塞导致整个进程无法对其它客户提供服务，而 I&#x2F;O 多路复用就是为了解决这个问题而出现</p>
<p>所谓 I&#x2F;O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 select 、 poll 、 epoll 来配合。多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符） </p>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：</p>
<p>多个套接字、</p>
<p>IO多路复用程序、</p>
<p>文件事件分派器、</p>
<p>事件处理器。</p>
<p>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型</p>
<h4 id="参考《Redis-设计与实现》"><a href="#参考《Redis-设计与实现》" class="headerlink" title="参考《Redis 设计与实现》"></a>参考《<code>Redis</code> 设计与实现》</h4><p><img src="/hexo-docs/images/redisImages/image-20250721165833527.png" alt="image-20250721165833527"></p>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>从Redis6开始，将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用单线程操作，一举两得，便宜占尽！！！ o(￣▽￣)ｄ</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721165857096.png" alt="image-20250721165857096"></p>
<h4 id="从吃米线开始，读读read…"><a href="#从吃米线开始，读读read…" class="headerlink" title="从吃米线开始，读读read…"></a>从吃米线开始，读读read…</h4><h5 id="从吃米线开始，读读read…-1"><a href="#从吃米线开始，读读read…-1" class="headerlink" title="从吃米线开始，读读read…"></a>从吃米线开始，读读read…</h5><p>上午开会，错过了公司食堂的饭点， 中午就和公司的首席架构师一起去楼下的米线店去吃米线。我们到了一看，果然很多人在排队。</p>
<p>架构师马上发话了：嚯，请求排队啊！你看这位收银点菜的，像不像nginx的反向代理？只收请求，不处理，把请求都发给后厨去处理。</p>
<p>我们交了钱，拿着号离开了点餐收银台，找了个座位坐下等餐。</p>
<p>架构师：你看，这就是异步处理，我们下了单就可以离开等待，米线做好了会通过小喇叭“回调”我们去取餐；</p>
<p>如果同步处理，我们就得在收银台站着等餐，后面的请求无法处理，客户等不及肯定会离开了。</p>
<p>接下里架构师盯着手中的纸质号牌。</p>
<p>架构师：你看，这个纸质号牌在后厨“服务器”那里也有，这不就是表示会话的ID吗？</p>
<p>有了它就可以把大家给区分开，就不会把我的排骨米线送给别人了。过了一会， 排队的人越来越多，已经有人表示不满了，可是收银员已经满头大汗，忙到极致了。</p>
<p>架构师：你看他这个系统缺乏弹性扩容， 现在这么多人，应该增加收银台，可以没有其他收银设备，老板再着急也没用。</p>
<p>老板看到在收银这里帮不了忙，后厨的订单也累积得越来越多， 赶紧跑到后厨亲自去做米线去了。</p>
<p>架构师又发话了：幸亏这个系统的后台有并行处理能力，可以随意地增加资源来处理请求（做米线）。</p>
<p>我说：他就这点儿资源了，除了老板没人再会做米线了。</p>
<p>不知不觉，我们等了20分钟， 但是米线还没上来。</p>
<p>架构师：你看，系统的处理能力达到极限，超时了吧。</p>
<p>这时候收银台前排队的人已经不多了，但是还有很多人在等米线。</p>
<p>老板跑过来让这个打扫卫生的去收银，让收银小妹也到后厨帮忙。打扫卫生的做收银也磕磕绊绊的，没有原来的小妹灵活。</p>
<p>架构师：这就叫服务降级，为了保证米线的服务，把别的服务都给关闭了。</p>
<p>又过了20分钟，后厨的厨师叫道：237号， 您点的排骨米线没有排骨了，能换成番茄的吗？</p>
<p>架构师低声对我说：瞧瞧， 人太多， 系统异常了。然后他站了起来：不行，系统得进行补偿操作：退费。</p>
<p>说完，他拉着我，饿着肚子，头也不回地走了。</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>调用者要一直等待调用结果的通知后才能进行后续的执行，现在就要，我可以等，等出结果为止</p>
<h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><ul>
<li>指被调用方先返回应答让调用者先回去，然后再计算调用结果，计算完最终结果后再通知并返回给调用方</li>
<li>异步调用要想获得结果一般通过回调</li>
</ul>
<h5 id="同步与异步的理解"><a href="#同步与异步的理解" class="headerlink" title="同步与异步的理解"></a>同步与异步的理解</h5><p>同步、异步的讨论对象是被调用者（服务提供者），重点在于获得调用结果的消息通知方式上</p>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>调用方一直在等待而且别的事情什么都不做，当前进&#x2F;线程会被挂起，啥都不干</p>
<h5 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h5><p>调用在发出去后，调用方先去忙别的事情，不会阻塞当前进&#x2F;线程，而会立即返回</p>
<h5 id="阻塞与非阻塞的理解"><a href="#阻塞与非阻塞的理解" class="headerlink" title="阻塞与非阻塞的理解"></a>阻塞与非阻塞的理解</h5><p>阻塞、非阻塞的讨论对象是调用者（服务请求者），重点在于等消息时候的行为，调用者是否能干其他事</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>4种组合方式</p>
<ul>
<li>同步阻塞：<ul>
<li>服务员说快到你了，先别离开我后台看一眼马上通知你。客户在海底捞火锅前台干等着，啥都不干</li>
</ul>
</li>
<li>同步非阻塞：<ul>
<li>服务员说快到你了，先别离开。客户在海底捞火锅前台边刷抖音边等着叫号</li>
</ul>
</li>
<li>异步阻塞：<ul>
<li>服务员说还要再等等，你先去逛逛，一会儿通知你。客户怕过号在海底捞火锅前台拿着排号小票啥都不干，一直等着店员通知</li>
</ul>
</li>
<li>异步非阻塞<ul>
<li>服务员说还要再等等，你先去逛逛，一会儿通知你。拿着排号小票+刷着抖音，等着店员通知</li>
</ul>
</li>
</ul>
<h4 id="Unix-网络编程中的五种-IO-模型"><a href="#Unix-网络编程中的五种-IO-模型" class="headerlink" title="Unix 网络编程中的五种 IO 模型"></a>Unix 网络编程中的五种 IO 模型</h4><ol>
<li>Blocking IO ：阻塞 IO</li>
<li>NoneBlocking：非阻塞 IO</li>
<li>IO multiplexing：IO 多路复用</li>
<li>signal driven IO：信号驱动 IO</li>
<li>asynchronous IO：异步 IO</li>
</ol>
<h3 id="java验证"><a href="#java验证" class="headerlink" title="java验证"></a>java验证</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>一个redisServer+2个Client</p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，<strong>BIO的特点就是在IO执行的两个阶段都被block了。</strong></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722171743375.png" alt="image-20250722171743375"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722171804256.png" alt="image-20250722171804256"></p>
<h5 id="先演示-accept"><a href="#先演示-accept" class="headerlink" title="先演示 accept"></a>先演示 accept</h5><ul>
<li><p>accept监听</p>
</li>
<li><p>代码案例</p>
<p><code>RedisServer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6380</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==== 111 等待连接 ====&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;==== 222 成功连接 ====&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient01</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=== RedisClient01 connection success ====&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=== RedisClient02 connection success ====&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动我们的<code>RedisServer</code>，在依次启动<code>RedisClient01</code>和<code>RedisClient02</code>测试</p>
</li>
</ul>
<p><code>RedisServer</code></p>
<p>  <img src="/hexo-docs/images/redisImages/image-20250722173327027.png" alt="image-20250722173327027"></p>
<p><code>RedisClient01</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722173346354.png" alt="image-20250722173346354"></p>
<p><code>RedisClient02</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722173409433.png" alt="image-20250722173409433"></p>
<p>再看看我们的<code>RedisServer</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722173429815.png" alt="image-20250722173429815"></p>
<p>我们启动了<code>RedisClient01</code>和<code>RedisClient02</code>，应该显示，两个连接成功，为什么只显示一个连接成功？接着看我们的read</p>
<h5 id="在演示-read"><a href="#在演示-read" class="headerlink" title="在演示 read"></a>在演示 read</h5><ul>
<li><p>read 读取</p>
</li>
<li><p>代码案例</p>
<ul>
<li><p>1</p>
<p>先启动 <code>RedisServerBIO</code>，在启动<code>RedisClient01</code>验证后再启动2号客户端</p>
<p><code>RedisServerBIO</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio.read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisServerBIO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6380</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=== 111 等待连接 ===&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();<span class="comment">//阻塞 1 ，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;=== 222 成功连接 ====&quot;</span>);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();<span class="comment">//获得输入流</span></span><br><span class="line">            <span class="type">int</span> length;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;=== 333 等待读取&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> ((length = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;<span class="comment">//阻塞 2 ，等待客户端发送数据</span></span><br><span class="line">                System.out.println(<span class="string">&quot;=== 444 成功读取：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line">                System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient01</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio.read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6380</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;RedisClient01 Connected to RedisServerBIO&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (string.equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            socket.getOutputStream().write(string.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;输入quit退出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio.read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6380</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;RedisClient02 Connected to RedisServerBIO&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (string.equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>))&#123; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            socket.getOutputStream().write(string.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;输入quit退出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动<code>RedisServerBIO</code>，再启动<code>RedisClient01</code>和<code>RedisClient02</code>，测试</p>
<p><code>RedisServerBIO</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722175025041.png" alt="image-20250722175025041"></p>
<p><code>RedisClient01</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722175228055.png" alt="image-20250722175228055"></p>
<p>输入内容</p>
<p><img src="/hexo-docs/images/redisImages/image-20250722175250860.png" alt="image-20250722175250860"></p>
<p><code>RedisServerBIO</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722175310389.png" alt="image-20250722175310389"></p>
<p>再启动<code>RedisClient02</code>，并输入内容</p>
<p><img src="/hexo-docs/images/redisImages/image-20250722175347302.png" alt="image-20250722175347302"></p>
<p><code>RedisServerBIO</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722175418138.png" alt="image-20250722175418138"></p>
</li>
<li><p>存在的问题</p>
<p>上面的模型存在很大的问题，如果客户端与服务端建立了连接，</p>
<p>如果这个连接的客户端迟迟不发数据，程就会一直堵塞在read()方法上，这样其他客户端也不能进行连接，</p>
<p>也就是一次只能处理一个客户端，对客户很不友好</p>
<p>知道问题所在了，请问如何解决？？</p>
</li>
<li><p>2</p>
<p>多线程模式</p>
<p>​	利用多线程</p>
<p>​	只要连接了一个socket，操作系统分配一个线程来处理，这样read()方法堵塞在每个具体线程上而不堵塞主线程，</p>
<p>​	就能操作多个socket了，哪个线程中的socket有数据，就读哪个socket，各取所需，灵活统一。</p>
<p>​	程序服务端只负责监听是否有客户端连接，使用 accept() 阻塞</p>
<p>​	客户端1连接服务端，就开辟一个线程（thread1）来执行 read() 方法，程序服务端继续监听</p>
<p>​	客户端2连接服务端，也开辟一个线程（thread2）来执行 read() 方法，程序服务端继续监听</p>
<p>​	客户端3连接服务端，也开辟一个线程（thread3）来执行 read() 方法，程序服务端继续监听</p>
<p>​	。。。。。。</p>
<p>​	任何一个线程上的socket有数据发送过来，read()就能立马读到，cpu就能进行处理。</p>
<p><code>RedisServerBIOMultiThread</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio.mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisServerBIOMultiThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6380</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=== 等待连接 ===&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();<span class="comment">//阻塞，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;=== 成功连接 ===&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    System.out.println(<span class="string">&quot;=== 等待读取 ===&quot;</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((length = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;=== 成功读取 ===&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;内容为：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,length));</span><br><span class="line">                    &#125;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,Thread.currentThread().getName()).start();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient01</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio.mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RedisClient01 连接 RedisServerBIOMultiThread 成功&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (string.equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.write(string.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;输入quit退出！&quot;</span>);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.bio.mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RedisClient02 连接 RedisServerBIOMultiThread 成功&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (string.equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.write(string.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;输入quit退出！&quot;</span>);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisServerBIOMultiThread</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722181457966.png" alt="image-20250722181457966"></p>
<p><code>RedisClient01</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722181536938.png" alt="image-20250722181536938"></p>
<p><code>RedisServerBIOMultiThread</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722181701254.png" alt="image-20250722181701254"></p>
<p><code>RedisClient02</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722181626426.png" alt="image-20250722181626426"></p>
<p><code>RedisServerBIOMultiThread</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250722181732453.png" alt="image-20250722181732453"></p>
</li>
<li><p>存在的问题</p>
<p>多线程模型</p>
<p>每来一个客户端，就要开辟一个线程，如果来1万个客户端，那就要开辟1万个线程。</p>
<p>在操作系统中用户态不能直接开辟线程，需要调用内核来创建的一个线程，</p>
<p>这其中还涉及到用户状态的切换（上下文的切换），十分耗资源。</p>
<p>知道问题所在了，请问如何解决？？</p>
<ul>
<li><p>解决</p>
<p>第一个办法：使用线程池</p>
<p>这个在客户端连接少的情况下可以使用，但是用户量大的情况下，你不知道线程池要多大，太大了内存可能不够，也不可行。</p>
<p>第二个办法：NIO（非阻塞式IO）方式</p>
<p>因为read()方法堵塞了，所有要开辟多个线程，如果什么方法能使read()方法不堵塞，这样就不用开辟多个线程了，这就用到了另一个IO模型，NIO（非阻塞式IO）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>tomcat7之前就是用 BIO 多线程来解决多连接</p>
<h5 id="目前我们的两个痛点"><a href="#目前我们的两个痛点" class="headerlink" title="目前我们的两个痛点"></a>目前我们的两个痛点</h5><p>两个痛点</p>
<ul>
<li>accept</li>
<li>read</li>
<li>在阻塞式 I&#x2F;O 模型中，应用程序在调用 <code>recvfrom</code> 开始到它返回有数据报准备好这段时间是阻塞的，<code>recvfrom</code> 返回成功后，应用程序才能开始处理数据报</li>
</ul>
<p>阻塞式 IO 小总结</p>
<p><img src="/hexo-docs/images/redisImages/image-20250722182156454.png" alt="image-20250722182156454"></p>
<p>思考</p>
<p>每个线程分配一个连接，必然会产生多个，既然是多个 <code>socket</code> 连接必然需要放入进容器，纳入统一管理</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<strong>所以，NIO特点是用户进程需要不断的主动询问内核数据准备好了吗？一句话，用轮询替代阻塞！</strong></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723165325836.png" alt="image-20250723165325836"></p>
<p>在NIO模式中，一切都是非阻塞的：</p>
<p>accept()方法是非阻塞的，如果没有客户端连接，就返回无连接标识</p>
<p>read()方法是非阻塞的，如果read()方法读取不到数据就返回空闲中标识，如果读取到数据时只阻塞read()方法读数据的时间</p>
<p>在NIO模式中，只有一个线程：</p>
<p>当一个客户端与服务端进行连接，这个socket就会加入到一个数组中，隔一段时间遍历一次，</p>
<p>看这个socket的read()方法能否读到数据，这样一个线程就能处理多个客户端的连接和读取了</p>
<h5 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h5><p>上述以前的socket是阻塞的，另外发开了一套 <code>API</code> ServerSocketChannel</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723165450855.png" alt="image-20250723165450855"></p>
<p><code>RedisServerNIO</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisServerNIO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;SocketChannel&gt; socketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=== Redis Server NIO 启动等待中...===&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>));</span><br><span class="line">        serverSocket.configureBlocking(<span class="literal">false</span>);<span class="comment">//设置为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SocketChannel element : socketList) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> element.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;<span class="comment">//当有数据的时候</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;=== 读取数据：&quot;</span>+read);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[read];</span><br><span class="line">                    buffer.get(bytes);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="literal">null</span>) &#123; <span class="comment">//如果不等于空，成功连接</span></span><br><span class="line">                System.out.println(<span class="string">&quot;=== 成功连接：&quot;</span>);</span><br><span class="line">                socketChannel.configureBlocking(<span class="literal">false</span>);<span class="comment">//设置为非阻塞模式</span></span><br><span class="line">                socketList.add(socketChannel);</span><br><span class="line">                System.out.println(<span class="string">&quot;socketList 容量为：&quot;</span>+socketList.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient01</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RedisClient01 开始&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (string.equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.write(string.getBytes());<span class="comment">//写入数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入quit退出！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedisClient02</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.iomultiplex.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RedisClient01 开始&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6380</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (string.equalsIgnoreCase(<span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream.write(string.getBytes());<span class="comment">//写入数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入quit退出！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><code>RedisServerNIO</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723170650738.png" alt="image-20250723170650738"></p>
<p><code>RedisClient01</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723170726565.png" alt="image-20250723170726565"></p>
<p><code>RedisClient02</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723170743851.png" alt="image-20250723170743851"></p>
<p><code>RedisServerNIO</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723170805419.png" alt="image-20250723170805419"></p>
<h5 id="存在的问题和优缺点"><a href="#存在的问题和优缺点" class="headerlink" title="存在的问题和优缺点"></a>存在的问题和优缺点</h5><p>NIO成功的解决了BIO需要开启多线程的问题，NIO中一个线程就能解决多个socket，但是还存在2个问题。</p>
<p><strong>问题一：</strong></p>
<p>这个模型在客户端少的时候十分好用，但是客户端如果很多，</p>
<p>比如有1万个客户端进行连接，那么每次循环就要遍历1万个socket，如果一万个socket中只有10个socket有数据，也会遍历一万个socket，就会做很多无用功，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p><strong>问题二：</strong></p>
<p>而且这个遍历过程是在用户态进行的，用户态判断socket是否有数据还是调用内核的read()方法实现的，这就涉及到用户态和内核态的切换，每遍历一个就要切换一次，开销很大因为这些问题的存在。</p>
<p>优点：不会阻塞在内核的等待数据过程，每次发起的 I&#x2F;O 请求可以立即返回，不用阻塞等待，实时性较好。</p>
<p>缺点：轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I&#x2F;O 模型。</p>
<p>结论：让Linux内核搞定上述需求，我们将一批文件描述符通过一次系统调用传给内核由内核层去遍历，才能真正解决这个问题。IO多路复用应运而生，也即将上述工作直接放进Linux内核，不再两态转换而是直接从内核获得结果，<strong>因为内核是非阻塞的。</strong></p>
<p>非阻塞式IO小总结</p>
<p><img src="/hexo-docs/images/redisImages/image-20250722182156454.png" alt="image-20250722182156454"></p>
<p>问题升级：</p>
<p>如何用单线程处理大量的连接？(使用IO多路复用)</p>
<h4 id="IO-Multiplexing（IO-多路复用）"><a href="#IO-Multiplexing（IO-多路复用）" class="headerlink" title="IO Multiplexing（IO 多路复用）"></a>IO Multiplexing（IO 多路复用）</h4><h5 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h5><p><img src="/hexo-docs/images/redisImages/image-20250723183906773.png" alt="image-20250723183906773"></p>
<p>I&#x2F;O多路复用在英文中其实叫 I&#x2F;O multiplexing </p>
<p><img src="/hexo-docs/images/redisImages/image-20250723183931129.png" alt="image-20250723183931129"></p>
<p>多个Socket复用一根网线这个功能是在内核＋驱动层实现的</p>
<p>I&#x2F;O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I&#x2F;O流)的状态来同时管理多个I&#x2F;O流. 目的是尽量多的提高服务器的吞吐能力。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723183946081.png" alt="image-20250723183946081"></p>
<p>大家都用过nginx，nginx使用epoll接收请求，ngnix会有很多链接进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。redis类似同理</p>
<p><code>FileDescriptor</code></p>
<p> 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184027965.png" alt="image-20250723184027965"></p>
<p>IO 多路复用</p>
<p>视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。可以基于一个阻塞对象并同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程，每次new一个线程)，这样可以大大节省系统资源。所以，I&#x2F;O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select，poll，epoll等函数就可以返回。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184051642.png" alt="image-20250723184051642"></p>
<h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>模拟一个tcp服务器处理30个客户socket，一个监考老师监考多个学生，谁举手就应答谁。</p>
<p>假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择：</p>
<p>第一种选择：按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误,你用循环挨个处理socket，根本不具有并发能力。 </p>
<p>第二种选择：你创建30个分身线程，每个分身线程检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p>
<p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。Linux下的select、poll和epoll就是干这个的。</p>
<p>将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor反应模式。</p>
<h5 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h5><p>Redis 单线程如何处理那么多并发客户端连接，为什么单线程，为什么快</p>
<ul>
<li><p>Redis的IO多路复用</p>
<ul>
<li><p>Redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到事件分派器，事件分派器将事件分发给事件处理器。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184140922.png" alt="image-20250723184140922"></p>
<p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符) </p>
<p>​	所谓 I&#x2F;O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 select 、 poll 、 epoll 来配合。多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p>​	所谓 I&#x2F;O 多路复用机制，就是说通过一种考试监考机制，一个老师可以监视多个考生，一旦某个考生举手想要交卷了，能够通知监考老师进行相应的收卷子或批改检查操作。所以这种机制需要调用班主任(select&#x2F;poll&#x2F;epoll)来配合。多个考生被同一个班主任监考，收完一个考试的卷子再处理其它人，无需等待所有考生，谁先举手就先响应谁，当又有考生举手要交卷，监考老师看到后从讲台走到考生位置，开始进行收卷处理。</p>
</li>
</ul>
</li>
</ul>
<p>Reactor 设计模式</p>
<p>是什么</p>
<ul>
<li><p>​	基于 I&#x2F;O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p>​	Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式。即 I&#x2F;O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184442547.png" alt="image-20250723184442547"></p>
<p>Reactor 模式中有 2 个关键组成：</p>
<p>1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</p>
<p>2）Handlers：处理程序执行 I&#x2F;O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际办理人。Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行非阻塞操作。</p>
</li>
<li><p>每个网络连接其实都对应一个文件描述符</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184529026.png" alt="image-20250723184529026"></p>
<p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。</p>
<p>它的组成结构为4部分：</p>
<p>多个套接字、</p>
<p>IO多路复用程序、</p>
<p>文件事件分派器、</p>
<p>事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型</p>
</li>
</ul>
<h5 id="select、poll、epoll-都是-I-O-多路复用的具体的实现"><a href="#select、poll、epoll-都是-I-O-多路复用的具体的实现" class="headerlink" title="select、poll、epoll 都是 I&#x2F;O 多路复用的具体的实现"></a>select、poll、epoll 都是 I&#x2F;O 多路复用的具体的实现</h5><p>C语言 struct 结构体语法简介</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184740611.png" alt="image-20250723184740611"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184751292.png" alt="image-20250723184751292"></p>
<p>select 方法</p>
<ul>
<li><p>Linux 官网或者 man</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723184834546.png" alt="image-20250723184834546"></p>
<p>select 函数监视的文件描述符分3类，分别是readfds、writefds和exceptfds，将用户传入的数组拷贝到内核空间</p>
<p>调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except）或超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。</p>
<p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/select.2.html">https://man7.org/linux/man-pages/man2/select.2.html</a></p>
<p>select 是第一个实现（1983 左右在BSD里面实现的）</p>
</li>
<li><p>用户态我们自己写的java代码思想</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723185036920.png" alt="image-20250723185036920"></p>
</li>
<li><p>C 语言代码</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723185055165.png" alt="image-20250723185055165"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723185104663.png" alt="image-20250723185104663"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723185113871.png" alt="image-20250723185113871"></p>
</li>
<li><p>优点</p>
<p>select 其实就是把NIO中用户态要遍历的fd数组(我们的每一个socket链接，安装进ArrayList里面的那个)拷贝到了内核态，让内核态来遍历，因为用户态判断socket是否有数据还是要调用内核态的，所有拷贝到内核态后，这样遍历判断的时候就不用一直用户态和内核态频繁切换了</p>
<p>从代码中可以看出，select系统调用后，返回了一个置位后的&amp;rset，这样用户态只需进行很简单的二进制比较，就能很快知道哪些socket需要read数据，有效提高了效率</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723185145446.png" alt="image-20250723185145446"></p>
</li>
<li><p>缺点</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723185221023.png" alt="image-20250723185221023"></p>
<ol>
<li>bitmap最大1024位，一个进程最多只能处理1024个客户端</li>
<li>&amp;rset不可重用，每次socket有数据就相应的位会被置位</li>
<li>文件描述符数组拷贝到了内核态(只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）)，仍然有开销。select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</li>
<li>select并没有通知用户态哪一个socket有数据，仍然需要O(n)的遍历。select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</li>
</ol>
<p>我们自己模拟写的是，RedisServerNIO.java,只不过将它内核化了。</p>
</li>
<li><p>select 小结论</p>
<p>select方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + N次就绪状态的文件描述符的 read 系统调用</p>
</li>
</ul>
<h5 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll 方法"></a>poll 方法</h5><p>Linux 官网或者 man</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190312309.png" alt="image-20250723190312309"></p>
<p>1997 年实现了 poll</p>
<p>官网：<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/poll.2.html">https://man7.org/linux/man-pages/man2/poll.2.html</a></p>
<p>C 语言代码</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190424306.png" alt="image-20250723190424306"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190432890.png" alt="image-20250723190432890"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190445858.png" alt="image-20250723190445858"></p>
<p>优点</p>
<ol>
<li>poll使用pollfd数组来代替select中的bitmap，数组没有1024的限制，可以一次管理更多的client。它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</li>
<li>当pollfds数组中有事件发生，相应的revents置位为1，遍历的时候又置位回零，实现了pollfd数组的重用</li>
</ol>
<p>问题</p>
<p>poll 解决了select缺点中的前两条，其本质原理还是select的方法，还存在select中原来的问题</p>
<ol>
<li>pollfds数组拷贝到了内核态，仍然有开销</li>
<li>poll并没有通知用户态哪一个socket有数据，仍然需要O(n)的遍历</li>
</ol>
<h5 id="epoll-方法"><a href="#epoll-方法" class="headerlink" title="epoll 方法"></a>epoll 方法</h5><p>Linux 官网或者 man</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190615538.png" alt="image-20250723190615538"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190623761.png" alt="image-20250723190623761"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190631959.png" alt="image-20250723190631959"></p>
<table>
<thead>
<tr>
<th>int epoll_create(int size)</th>
<th>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</th>
</tr>
</thead>
<tbody><tr>
<td>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</td>
<td>见上图</td>
</tr>
<tr>
<td>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</td>
<td>等待epfd上的io事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大。</td>
</tr>
</tbody></table>
<p>在2002年被大神 Davide Libenzi (戴维德·利本兹)发明出来了</p>
<p>三步调用</p>
<ul>
<li><p>epoll_create</p>
<ul>
<li><p>创建一个epoll句柄</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190825824.png" alt="image-20250723190825824"></p>
</li>
</ul>
</li>
<li><p>epoll_ctl</p>
<ul>
<li>向内核添加、修改或删除要监控的文件描述符</li>
</ul>
<p><img src="/hexo-docs/images/redisImages/image-20250723190903214.png" alt="image-20250723190903214"></p>
</li>
<li><p>epoll_wait</p>
<ul>
<li><p>类似发起了 select() 调用</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723190948106.png" alt="image-20250723190948106"></p>
</li>
</ul>
</li>
</ul>
<p>C 语言代码</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723191005378.png" alt="image-20250723191005378"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250723191021305.png" alt="image-20250723191021305"></p>
<p>结论</p>
<p>​	多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，</p>
<p>变成了一次系统调用 + 内核层遍历这些文件描述符。</p>
<p>​	epoll是现在最先进的IO多路复用器，Redis、Nginx，linux中的Java NIO都使用的是epoll。</p>
<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</p>
<ol>
<li>一个socket的生命周期中只有一次从用户态拷贝到内核态的过程，开销小</li>
<li>使用event事件通知机制，每次socket中有数据会主动通知内核，并加入到就绪链表中，不需要遍历所有的socket</li>
</ol>
<p>​	在多路复用IO模型中，会有一个内核线程不断地去轮询多个 socket 的状态，只有当真正读写事件发送时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有真正有读写事件进行时，才会使用IO资源，所以它大大减少来资源占用。多路I&#x2F;O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。 采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈</p>
<h5 id="三个方法对比"><a href="#三个方法对比" class="headerlink" title="三个方法对比"></a>三个方法对比</h5><p><img src="/hexo-docs/images/redisImages/image-20250723191111492.png" alt="image-20250723191111492"></p>
<h4 id="5种-I-O-模型总结"><a href="#5种-I-O-模型总结" class="headerlink" title="5种 I&#x2F;O 模型总结"></a>5种 I&#x2F;O 模型总结</h4><p> 多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，</p>
<p>变成了一次系统调用 + 内核层遍历这些文件描述符。 </p>
<p>所谓 I&#x2F;O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 select 、 poll 、 epoll 来配合。多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；</p>
<p><img src="/hexo-docs/images/redisImages/image-20250723191208911.png" alt="image-20250723191208911"></p>
<h4 id="为什么3个都保有"><a href="#为什么3个都保有" class="headerlink" title="为什么3个都保有"></a>为什么3个都保有</h4><p><img src="/hexo-docs/images/redisImages/image-20250723191232748.png" alt="image-20250723191232748"></p>
<h3 id="案例实战（微信抢红包）"><a href="#案例实战（微信抢红包）" class="headerlink" title="案例实战（微信抢红包）"></a>案例实战（微信抢红包）</h3><h4 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h4><p><img src="/hexo-docs/images/redisImages/image-20250724170119462.png" alt="image-20250724170119462"></p>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol>
<li>各种节假日，发红包+抢红包，不说了，100%高并发业务要求，不能用mysql来做</li>
<li>一个总的大红包，会有可能拆分成多个小红包，总金额&#x3D; 分金额1+分金额2+分金额3……分金额N</li>
<li>每个人只能抢一次，你需要有记录，比如100块钱，被拆分成10个红包发出去，总计有10个红包，抢一个少一个，总数显示(10&#x2F;6)直到完，需要记录那些人抢到了红包，重复抢作弊不可以。</li>
<li>有可能还需要你计时，完整抢完，从发出到全部over，耗时多少？</li>
<li>红包过期，或者群主人品差，没人抢红包，原封不动退回。</li>
<li>红包过期，剩余金额可能需要回退到发红包主账户下。</li>
</ol>
<p>由于是高并发不能用mysql来做，只能用redis，那需要要redis的什么数据类型？</p>
<h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>难点：</p>
<ol>
<li>拆分算法如何</li>
</ol>
<p>  红包其实就是金额，拆分算法如何 ？给你100块，分成10个小红包(金额有可能小概率相同，有2个红包都是2.58)，</p>
<p>  如何拆分随机金额设定每个红包里面安装多少钱?</p>
<ol start="2">
<li><p>次数限制</p>
<p>   每个人只能抢一次，次数限制</p>
</li>
<li><p>原子性</p>
</li>
</ol>
<p>  每抢走一个红包就减少一个(类似减库存)，那这个就需要保证库存的———————–原子性，不加锁实现</p>
<p>你认为存在redis什么数据类型里面？set ？hash？ list？</p>
<h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><ul>
<li>发红包</li>
<li>抢红包<ul>
<li>抢，不加锁且原子性，还能支持高并发</li>
<li>每人一次且有抢红包记录</li>
</ul>
</li>
<li>记红包<ul>
<li>记录每个人抢了多少</li>
</ul>
</li>
<li>拆红包<ul>
<li>拆红包算法<ol>
<li>所有人抢到金额之和等于红包金额，不能超过，也不能少于</li>
<li>每个人至少抢到一分钱</li>
<li>要保证所有人抢到金额的几率相等</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><p>抢红包业务通用算法</p>
<p><strong>二倍均值法</strong></p>
<p>剩余红包金额为M，剩余人数为N，那么有如下公式：</p>
<p>每次抢到的金额 &#x3D; 随机区间 （0， (剩余红包金额M ÷ 剩余人数N ) X 2）</p>
<p>这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。</p>
<p>举个例子：</p>
<p>假设有10个人，红包总额100元。</p>
<p>第1次：</p>
<p>100÷10 X2 &#x3D; 20, 所以第一个人的随机范围是（0，20 )，平均可以抢到10元。假设第一个人随机到10元，那么剩余金额是100-10 &#x3D; 90 元。</p>
<p>第2次：</p>
<p>90÷9 X2 &#x3D; 20, 所以第二个人的随机范围同样是（0，20 )，平均可以抢到10元。假设第二个人随机到10元，那么剩余金额是90-10 &#x3D; 80 元。</p>
<p>第3次：</p>
<p>80÷8 X2 &#x3D; 20, 所以第三个人的随机范围同样是（0，20 )，平均可以抢到10元。 以此类推，每一次随机范围的均值是相等的。</p>
<p>数据类型</p>
<table>
<thead>
<tr>
<th align="center">发红包</th>
<th align="center">抢红包</th>
<th align="center">记红包</th>
<th align="center">拆红包算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">list</td>
<td align="center">list</td>
<td align="center">hash</td>
<td align="center">二倍均值法</td>
</tr>
</tbody></table>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>改代码没有<code>service</code>只有<code>controller</code></p>
<p><code>pom</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringBoot通用依赖模块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringBoot与Redis整合依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis 连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7777</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redis_distributed_lock2</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.136</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>controller</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.IdUtil;</span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Ints;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPackageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED_PACKAGE_KEY</span> <span class="operator">=</span> <span class="string">&quot;redPackage:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED_PACKAGE_CONSUMER_KEY</span> <span class="operator">=</span> <span class="string">&quot;redPackage:consumer:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(Integer totalMoney,Integer redPackageNumber)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拆红包，总金额拆分成多少个红包，每个小红包里面包多少钱</span></span><br><span class="line">        Integer[] splitPackages = splitRedPackage(totalMoney, redPackageNumber);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RED_PACKAGE_KEY + IdUtil.simpleUUID();</span><br><span class="line">        <span class="comment">//采用list存储红包并设置过期时间</span></span><br><span class="line">        redisTemplate.opsForList().leftPushAll(key, splitPackages);</span><br><span class="line">        redisTemplate.expire(key,<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        <span class="comment">//将数组转成字符串显示</span></span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;\t\t&quot;</span>+ Ints.asList(Arrays.stream(splitPackages).mapToInt(Integer::valueOf).toArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rob&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redPackage</span><span class="params">(String redPackageKey,String userId)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//验证某个用户是否抢过红包</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">redPackage</span> <span class="operator">=</span> redisTemplate.opsForHash().get(RED_PACKAGE_CONSUMER_KEY + redPackageKey, userId);</span><br><span class="line">        <span class="keyword">if</span> (redPackage != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;errorCode:-2,   message: &quot;</span>+<span class="string">&quot;\t&quot;</span>+userId+<span class="string">&quot; 用户你已经抢过红包了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从 list 里面出队一个红包，抢到一个</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">partRedPackage</span> <span class="operator">=</span> redisTemplate.opsForList().leftPop(RED_PACKAGE_KEY + redPackageKey);</span><br><span class="line">        <span class="keyword">if</span> ( partRedPackage == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;errorCode:-1,红包抢完了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抢到手后，记录进去hash表示谁抢到了多少钱的某一个红包</span></span><br><span class="line">        redisTemplate.opsForHash().put(RED_PACKAGE_CONSUMER_KEY + redPackageKey, userId, partRedPackage);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户: &quot;</span>+userId+<span class="string">&quot;\t 抢到多少钱红包: &quot;</span>+partRedPackage);</span><br><span class="line">        <span class="comment">//TODO 后续异步进mysql或者RabbitMQ进一步处理</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(partRedPackage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拆完红包总金额+每个小红包金额别太离谱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalMoney</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redPackageNumber</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] splitRedPackage(Integer totalMoney,Integer redPackageNumber)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">useMoney</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Integer[] redPackageNumbers = <span class="keyword">new</span> <span class="title class_">Integer</span>[redPackageNumber];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; redPackageNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == redPackageNumber-<span class="number">1</span>) &#123;</span><br><span class="line">                redPackageNumbers[i] = totalMoney - useMoney;<span class="comment">//如果为最后一个红包把剩余的金额放到里面</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//二倍均值算法，每次拆分后塞进子红包的金额 = 随机区间(0,(剩余红包金额M ÷ 未被抢的剩余红包个数N)×2)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">avgMoney</span> <span class="operator">=</span> ((totalMoney-useMoney)/(redPackageNumber-i))*<span class="number">2</span>;</span><br><span class="line">                redPackageNumbers[i] = <span class="number">1</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(avgMoney);</span><br><span class="line">            &#125;</span><br><span class="line">            useMoney += redPackageNumbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redPackageNumbers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>发红包</p>
<p><img src="/hexo-docs/images/redisImages/image-20250724173311185.png" alt="image-20250724173311185"></p>
<p>抢红包</p>
<p><img src="/hexo-docs/images/redisImages/image-20250724173732374.png" alt="image-20250724173732374"></p>
<p>抢完红包</p>
<p><img src="/hexo-docs/images/redisImages/image-20250724173814301.png" alt="image-20250724173814301"></p>
<p>抢过红包</p>
<p><img src="/hexo-docs/images/redisImages/image-20250724173832149.png" alt="image-20250724173832149"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250724173842305.png" alt="image-20250724173842305"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250724173931290.png" alt="image-20250724173931290"></p>
<h4 id="如何批量删除？"><a href="#如何批量删除？" class="headerlink" title="如何批量删除？"></a>如何批量删除？</h4><p>当需要删除符合特定模式的键时，可以结合 <em>KEYS</em> 或 <em>SCAN</em> 命令。</p>
<p><strong>使用 KEYS + xargs：</strong></p>
<p>redis-cli KEYS “pattern*” | xargs redis-cli DEL</p>
<ul>
<li>示例：删除所有以 <em>user:</em> 开头的键：</li>
</ul>
<p>redis-cli KEYS “user:*” | xargs redis-cli DEL</p>
<p><strong>使用 SCAN + xargs（推荐生产环境）：</strong></p>
<p>redis-cli –scan –pattern “cache:*” | xargs -L 1000 redis-cli DEL</p>
<ul>
<li>SCAN 命令避免了 KEYS 的阻塞问题，更适合大规模数据。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs">Lazy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs/2025/08/13/redis/epoll%E5%87%BD%E6%95%B0%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">https://mac2git.github.io/hexo-docs/2025/08/13/redis/epoll函数和IO多路复用深度解析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mac2git.github.io/hexo-docs" target="_blank">Lazy的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/hexo-docs/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://pic.crazytaxii.com/Redis_Logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/replica/" title="Replica(主从复制)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Replica(主从复制)</div></div><div class="info-2"><div class="info-item-1">复制（replica）就是主从复制，master以写为主，slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库 优点：  读写分离 容灾恢复 数据备份 水平扩容支撑高并发  如何使用  配从（库）不配主（库） 权限细节，重要 master 如果配置了 requirepass 参数，需要密码登录 那么 slave 就要配置 masterauth 来设置校验密码，否则的话 master 会拒绝 slave的访问请求      基本操作命令 info replication：可以查看复制节点的主从关系和配置信息 replicaof 主库IP 主库端口：一般写入进 redis.conf 配置文件内 slaveof 主库IP 主库端口 每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜主数据库   slaveof no one：使当前数据库停止与其他数据库的同步，转成...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/pub&amp;sub/" title="pub&amp;sub(发布&amp;订阅)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">pub&sub(发布&订阅)</div></div><div class="info-2"><div class="info-item-1">发布&#x2F;订阅是一种消息通信模式：发送者（publish）发送消息，订阅者（subscribe）接受消息，可以实现进程间的消息传递 Redis  可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。不推荐使用该功能，专业的事情交给专业的中间件，redis就做好分布式缓存功能 能干嘛？  redis 客户端可以订阅任意数量的频道，类似我们微信关注多个公众号   当有新的消息通过 publish 命令发送给频道 channel1 时     总结： 发布&#x2F;订阅其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理实时性较高的异步消息    常用命令  subscribe channel [channel...]   订阅给定的一个或多个频道的信息 推荐先执行订阅后再发布，订阅成功之前发布的消息是收不到的 订阅的客户端每次可以收到一个3个参数的消息 消息的种类 始发频道的名称 实际的消息内容         publish channel message    发布消息到指定的频道    psubscribe pattern[pattern...] ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/RDB+AOF/" title="RDB+AOF"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">RDB+AOF</div></div><div class="info-2"><div class="info-item-1">redis数据数据持久化 为什么要用数据持久化？ 数据持久化可以在内存丢失或其他灾难性故障的情况下实现恢复。 数据持久化的两种方式  AOF：以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写入指令从前到后执行一次以完成数据的恢复工作。 RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。  rdb（redis database）能干嘛？ 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将硬盘快照文件直接读回到内存里。Redis的数据都在内存中，保存备份时它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，一锅端。 Rdb保存的是dump.rdb文件  Redis6.0.16以下  Redis6.2以及Redis-7.0.0  自动触发 redis7版本，按照redis.conf里配置的save&lt;seconds&gt;&lt...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/Redlock%E7%AE%97%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="RedLock算法和底层源码分析和缓存淘汰策略"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">RedLock算法和底层源码分析和缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">上一章自研的redis锁对于一般中小公司，不是特别高并发场景足够用了，单机redis小业务也撑得住。但是对于特别高并发场景的话，就得使用Redisson了 Redis分布式锁-RedLock红锁算法（Distributed locks with Redis）官网：Redis 的分布式锁 |文档 说明：  为什么学习这个？怎样产生的？   线程 1 首先获取锁成功，将键值对写入 redis 的 master 节点，在 redis 将该键值对同步到 slave 节点之前，master 发生了故障；redis 触发故障转移，其中一个 slave 升级为新的 master，此时新上位的master并不包含线程1写入的键值对，因此线程 2 尝试获取锁也可以成功拿到锁，此时相当于有两个线程获取到了锁，可能会导致各种预期之外的情况发生，例如最常见的脏数据。  我们加的是排它独占锁，同一时间只能有一个建redis锁成功并持有锁，严禁出现2个以上的请求线程拿到锁。危险的！ RedLock算法设计理念Redis也提供了Redlock算法，用来实现基于多个实例的分布式锁。锁变量由多个实例维护，即使有实...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/bigkey%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99/" title="BigKey和缓存双写"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">BigKey和缓存双写</div></div><div class="info-2"><div class="info-item-1">Redis为什么是单线程这种问法其实并不严谨，为啥这么说呢? Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。  版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。  版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是开始加了点多线程的东西(异步删除)。—貌似  2020年5月版本的6.0.x后及2022年出的7.0版本后，告别了大家印象中的单线程，用一种全新的多线程来解决问题。—实锤   几个里程碑的redis版本！  5.0版本是直接升级到6.0版本，对于这个激进的升级，Redis之父antirez表现得很有信心和兴奋， 所以第一时间发文来阐述6.0的一些重大功能”Redis 6.0.0 GA is out!” 当然，Redis7.0后版本更加厉害  Redis是单线程 主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/hyperloglogGeoBitmap/" title="HyperLogLog&amp;Geo&amp;Bitmap"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">HyperLogLog&amp;Geo&amp;Bitmap</div></div><div class="info-2"><div class="info-item-1">统计类型有哪些？ 亿级系统中常见的四种统计  聚合统计 统计多个集合元素的聚合结果，就是前面的交集差集等集合统计   排序统计（zset） 在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用ZSet  因为可以使用分页，正反排序  二值统计（bitmap） 集合元素的取值就只有0和1两种，在钉钉上班签到打开的场景中，我们只用记录有签到（1）和没签到（0）  基数统计（hyperloglog） 指 统计一个集合不重复元素个数     HyperLogLog名词解释  什么是UV?  Unique Visitor，独立访客，一般理解为客户端IP 需要去重考虑，例如一个人一天访问了10次网站，一天的UV就是1   什么是PV?  Page View，页面浏览量 不用去重，例如一个人一天访问了10次网站，一天的PV就是10   什么是DAU?  Daily  Active User  日活跃用户量 登录或者使用了某个产品的用户数（去重复登录的用户），避免恶意刷单  常用于反映网站，互联网应用或者网络游戏的运营情况      什么是MAU？  Monthly...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/index/" title="Redis基础"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">Redis基础</div></div><div class="info-2"><div class="info-item-1">什么是Redis？Redis 是一个内存数据存储，被数百万开发者用作缓存、向量数据库、文档数据库、流式引擎和消息代理。Redis 具有内置的复制和不同级别的磁盘持久化。它支持复杂的数据类型（例如，字符串、散列、列表、集合、有序集合和 JSON），并为这些数据类型定义了原子操作。 Redis 通常被称为数据结构服务器。这意味着 Redis 通过一组命令提供对可变数据结构的访问，这些命令通过 TCP 套接字和简单协议使用服务器-客户端模型发送。因此，不同的进程可以以共享的方式查询和修改相同的数据结构。 Redis 实现的数据结构具有一些特殊的属性：  Redis 会将其存储在磁盘上，即使它们总是被服务器内存中读取和修改。这意味着 Redis 速度快，但同时也非易失性。 数据结构的实现强调内存效率，因此 Redis 内部的数据结构可能比使用高级编程语言建模的相同数据结构模型使用更少的内存。 Redis 提供了一系列数据库中常见的功能，如复制、可调的持久性级别、集群和高度可用性。  下载Redis 命名规则： ​	版本号第二位如果是奇数，则为非稳定版本，如2.7、2.9、3.1 ​	版本...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/pub&sub/" title="pub&amp;sub(发布&amp;订阅)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">pub&amp;sub(发布&amp;订阅)</div></div><div class="info-2"><div class="info-item-1">发布&#x2F;订阅是一种消息通信模式：发送者（publish）发送消息，订阅者（subscribe）接受消息，可以实现进程间的消息传递 Redis  可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。不推荐使用该功能，专业的事情交给专业的中间件，redis就做好分布式缓存功能 能干嘛？  redis 客户端可以订阅任意数量的频道，类似我们微信关注多个公众号   当有新的消息通过 publish 命令发送给频道 channel1 时     总结： 发布&#x2F;订阅其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理实时性较高的异步消息    常用命令  subscribe channel [channel...]   订阅给定的一个或多个频道的信息 推荐先执行订阅后再发布，订阅成功之前发布的消息是收不到的 订阅的客户端每次可以收到一个3个参数的消息 消息的种类 始发频道的名称 实际的消息内容         publish channel message    发布消息到指定的频道    psubscribe pattern[pattern...] ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lazy</div><div class="author-info-description">归途也还可爱</div><div class="site-data"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mac2git"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mac2git" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/wx_00ba6ce280" target="_blank" title="Gitee"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客正在施工，请先随便逛逛。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll-%E5%87%BD%E6%95%B0%E5%92%8C-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-text">epoll 函数和 IO 多路复用深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89-epoll-%E5%92%8C-IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B%E5%89%8D"><span class="toc-text">没有 epoll 和 IO 多路复用之前</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">多路复用要解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">IO 多路复用模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%82%A3%E4%B9%88%E5%A4%9A%E5%B9%B6%E5%8F%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9D%97"><span class="toc-text">redis 单线程如何处理那么多并发客户端连接，为什么单线程，为什么块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E3%80%8ARedis-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B"><span class="toc-text">参考《Redis 设计与实现》</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%90%83%E7%B1%B3%E7%BA%BF%E5%BC%80%E5%A7%8B%EF%BC%8C%E8%AF%BB%E8%AF%BBread%E2%80%A6"><span class="toc-text">从吃米线开始，读读read…</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%90%83%E7%B1%B3%E7%BA%BF%E5%BC%80%E5%A7%8B%EF%BC%8C%E8%AF%BB%E8%AF%BBread%E2%80%A6-1"><span class="toc-text">从吃米线开始，读读read…</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-text">同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">同步与异步的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">非阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">阻塞与非阻塞的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unix-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D-IO-%E6%A8%A1%E5%9E%8B"><span class="toc-text">Unix 网络编程中的五种 IO 模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%AA%8C%E8%AF%81"><span class="toc-text">java验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-text">BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%BC%94%E7%A4%BA-accept"><span class="toc-text">先演示 accept</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%BC%94%E7%A4%BA-read"><span class="toc-text">在演示 read</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E6%88%91%E4%BB%AC%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%97%9B%E7%82%B9"><span class="toc-text">目前我们的两个痛点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-text">代码案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">存在的问题和优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-Multiplexing%EF%BC%88IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%89"><span class="toc-text">IO Multiplexing（IO 多路复用）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select%E3%80%81poll%E3%80%81epoll-%E9%83%BD%E6%98%AF-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">select、poll、epoll 都是 I&#x2F;O 多路复用的具体的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll-%E6%96%B9%E6%B3%95"><span class="toc-text">poll 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-%E6%96%B9%E6%B3%95"><span class="toc-text">epoll 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">三个方法对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A7%8D-I-O-%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-text">5种 I&#x2F;O 模型总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%883%E4%B8%AA%E9%83%BD%E4%BF%9D%E6%9C%89"><span class="toc-text">为什么3个都保有</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98%EF%BC%88%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%EF%BC%89"><span class="toc-text">案例实战（微信抢红包）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="toc-text">业务描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="toc-text">如何批量删除？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/24/pay/ali_pay/" title="支付宝沙箱环境支付"><img src="/hexo-docs/images/payImages/alipay.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="支付宝沙箱环境支付"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/24/pay/ali_pay/" title="支付宝沙箱环境支付">支付宝沙箱环境支付</a><time datetime="2025-09-23T16:00:00.000Z" title="发表于 2025-09-24 00:00:00">2025-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/22/nginx/nginx/" title="Nginx"><img src="https://nginx.org/img/nginx_logo.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/22/nginx/nginx/" title="Nginx">Nginx</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/17/docker/docker/" title="Docker"><img src="/hexo-docs/images/dockerImages/docker.webp" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/17/docker/docker/" title="Docker">Docker</a><time datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ"><img src="/hexo-docs/images/rocketmqImages/cover.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/08/29/commit_protocol/index/" title="两阶段提交与三阶段提交"><img src="/hexo-docs/images/commit_protocolImages/img.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="两阶段提交与三阶段提交"/></a><div class="content"><a class="title" href="/hexo-docs/2025/08/29/commit_protocol/index/" title="两阶段提交与三阶段提交">两阶段提交与三阶段提交</a><time datetime="2025-08-28T16:00:00.000Z" title="发表于 2025-08-29 00:00:00">2025-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Lazy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/hexo-docs/js/utils.js"></script><script src="/hexo-docs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="14px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/hexo-docs/js/search/local-search.js"></script></div></div></body></html>