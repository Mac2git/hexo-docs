<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis经典五大类型源码及底层实现 | Lazy的个人博客</title><meta name="author" content="Lazy"><meta name="copyright" content="Lazy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis经典五大类型源码及底层实现本源码基于redis7.0.5 Redis数据类型和底层数据结构  SDS动态字符串 双向链表 压缩列表ziplist 哈希表hashtable 跳表skiplist 整数集合intset 快速列表quicklist 紧凑列表listpack  源码在哪里？ github ：https:&#x2F;&#x2F;github.com&#x2F;redis&#x2F;redis  Redis核心部分src">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis经典五大类型源码及底层实现">
<meta property="og:url" content="https://mac2git.github.io/hexo-docs/2025/08/13/redis/redis%E7%BB%8F%E5%85%B8%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Lazy的个人博客">
<meta property="og:description" content="Redis经典五大类型源码及底层实现本源码基于redis7.0.5 Redis数据类型和底层数据结构  SDS动态字符串 双向链表 压缩列表ziplist 哈希表hashtable 跳表skiplist 整数集合intset 快速列表quicklist 紧凑列表listpack  源码在哪里？ github ：https:&#x2F;&#x2F;github.com&#x2F;redis&#x2F;redis  Redis核心部分src">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.crazytaxii.com/Redis_Logo.png">
<meta property="article:published_time" content="2025-08-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-22T17:03:38.981Z">
<meta property="article:author" content="Lazy">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.crazytaxii.com/Redis_Logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis经典五大类型源码及底层实现",
  "url": "https://mac2git.github.io/hexo-docs/2025/08/13/redis/redis%E7%BB%8F%E5%85%B8%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/",
  "image": "https://pic.crazytaxii.com/Redis_Logo.png",
  "datePublished": "2025-08-12T16:00:00.000Z",
  "dateModified": "2025-08-22T17:03:38.981Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lazy",
      "url": "https://mac2git.github.io/hexo-docs"
    }
  ]
}</script><link rel="shortcut icon" href="/hexo-docs/images/webImages/logo.svg"><link rel="canonical" href="https://mac2git.github.io/hexo-docs/2025/08/13/redis/redis%E7%BB%8F%E5%85%B8%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/hexo-docs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/hexo-docs/',
  algolia: undefined,
  localSearch: {"path":"/hexo-docs/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Lazy","link":"链接: ","source":"来源: Lazy的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis经典五大类型源码及底层实现',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic.crazytaxii.com/Redis_Logo.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/hexo-docs/"><span class="site-name">Lazy的个人博客</span></a><a class="nav-page-title" href="/hexo-docs/"><span class="site-name">Redis经典五大类型源码及底层实现</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis经典五大类型源码及底层实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-12T16:00:00.000Z" title="发表于 2025-08-13 00:00:00">2025-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-22T17:03:38.981Z" title="更新于 2025-08-23 01:03:38">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/hexo-docs/categories/%E5%90%8E%E7%AB%AF-Redis/">后端 Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Redis经典五大类型源码及底层实现"><a href="#Redis经典五大类型源码及底层实现" class="headerlink" title="Redis经典五大类型源码及底层实现"></a>Redis经典五大类型源码及底层实现</h2><p>本源码基于redis7.0.5</p>
<p>Redis数据类型和底层数据结构</p>
<ul>
<li>SDS动态字符串</li>
<li>双向链表</li>
<li>压缩列表ziplist</li>
<li>哈希表hashtable</li>
<li>跳表skiplist</li>
<li>整数集合intset</li>
<li>快速列表quicklist</li>
<li>紧凑列表listpack</li>
</ul>
<p>源码在哪里？</p>
<p>github ：<a target="_blank" rel="noopener" href="https://github.com/redis/redis">https://github.com/redis/redis</a></p>
<p><img src="/hexo-docs/images/redisImages/image-20250716165354378.png" alt="image-20250716165354378"></p>
<h3 id="Redis核心部分"><a href="#Redis核心部分" class="headerlink" title="Redis核心部分"></a>Redis核心部分</h3><p>src源码包下面该如何看？</p>
<h4 id="Redis基本数据结构（骨架）"><a href="#Redis基本数据结构（骨架）" class="headerlink" title="Redis基本数据结构（骨架）"></a>Redis基本数据结构（骨架）</h4><ul>
<li><p>Github官网说明</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716170131856.png" alt="image-20250716170131856"></p>
<ul>
<li>Redis对象object.c</li>
<li>字符串t_string.c</li>
<li>列表t_list.c</li>
<li>字典t_hash.c</li>
<li>集合及有序集合t_set.c和t_zset.c</li>
<li>数据流t_stream.c：Streams的底层实现结构listpack.c和rax.c</li>
</ul>
</li>
<li><p>简单动态字符串sds.c</p>
</li>
<li><p>整数集合intset.c</p>
</li>
<li><p>压缩列表ziplist.c</p>
</li>
<li><p>快速链表quicklist.c</p>
</li>
<li><p>listpack（紧凑列表）</p>
</li>
<li><p>字典dict.c</p>
</li>
</ul>
<h4 id="Redis数据库的实现"><a href="#Redis数据库的实现" class="headerlink" title="Redis数据库的实现"></a>Redis数据库的实现</h4><ul>
<li>数据库的底层实现db.c</li>
<li>持久化rdb.c和aof.c</li>
</ul>
<h4 id="Redis服务端和客户端实现"><a href="#Redis服务端和客户端实现" class="headerlink" title="Redis服务端和客户端实现"></a>Redis服务端和客户端实现</h4><ul>
<li>事件驱动ae.c和ae_epoll.c</li>
<li>网络连接anet.c和networking.c</li>
<li>服务端程序server.c</li>
<li>客户端程序redis-cli.c</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>主从复制replication.c</li>
<li>哨兵sentinel.c</li>
<li>集群cluster.c</li>
<li>其他数据结构，如hyperloglog.c、geo.c等</li>
<li>其他功能，如pub&#x2F;sub、Lua脚本</li>
</ul>
<h2 id="平时说的redis的字典数据库KV键到底是什么"><a href="#平时说的redis的字典数据库KV键到底是什么" class="headerlink" title="平时说的redis的字典数据库KV键到底是什么"></a>平时说的redis的字典数据库KV键到底是什么</h2><ul>
<li><p>怎样实现键值对（key-value）数据库的</p>
<ul>
<li>redis是key-value存储系统<ul>
<li>key一般都是String类型的字符串对象</li>
<li>value类型则为redis对象（redisObject）<ul>
<li>value可以是字符串对象，也可以是集合数据类型的对象，比如List对象、Hash对象、Set对象和Zset对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/hexo-docs/images/redisImages/image-20250716170742811.png" alt="image-20250716170742811"></p>
</li>
<li><p>10大类型说明（粗分）</p>
<ul>
<li><p>传统的5大类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hash</li>
<li>Set</li>
<li>ZSet</li>
</ul>
</li>
<li><p>新介绍的5大类型</p>
<ul>
<li><p>bitmap：实质String</p>
</li>
<li><p>hyperloglog：实质String</p>
</li>
<li><p>GEO：实质Zset</p>
</li>
<li><p>Stream：实质Stream</p>
</li>
<li><p>BITFIELD：看具体key</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716170949148.png" alt="image-20250716170949148"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250716170957043.png" alt="image-20250716170957043"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250716171058106.png" alt="image-20250716171058106"></p>
</li>
</ul>
</li>
<li><p>上帝视角</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716171235555.png" alt="image-20250716171235555"></p>
</li>
<li><p>Redis定义了redisObject结构体来表示string、hash、list、set、zset等数据类型</p>
<ul>
<li><p>C语言struct结构体语法简介</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716171632672.png" alt="image-20250716171632672"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250716171746488.png" alt="image-20250716171746488"></p>
</li>
<li><p>Redis中每个对象都是一个redisObject结构</p>
</li>
<li><p>字典、KV是什么（重点）</p>
<ul>
<li><p>每个键值对都会有一个dictEntry</p>
</li>
<li><p>源码位置：dict.h</p>
</li>
<li><p>重点：从dictEntry到RedisObject</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716171937938.png" alt="image-20250716171937938"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250716171957848.png" alt="image-20250716171957848"></p>
</li>
</ul>
</li>
<li><p>这些键值对是如何保存进Redis并进行读取操作，O(1)复杂度</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716172245094.png" alt="image-20250716172245094"></p>
</li>
<li><p>redisObject+Redis数据类型+Redis所有编码方式（底层实现）三者之间的关系</p>
<p><img src="/hexo-docs/images/redisImages/image-20250716172324587.png" alt="image-20250716172324587"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250716172342336.png" alt="image-20250716172342336"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5大结构底层C语言源码分析"><a href="#5大结构底层C语言源码分析" class="headerlink" title="5大结构底层C语言源码分析"></a>5大结构底层C语言源码分析</h2><p>重点：redis数据类型与数据结构总纲图</p>
<ol>
<li>SDS动态字符串</li>
<li>双向链表</li>
<li>压缩列表ziplist</li>
<li>哈希表hashtable</li>
<li>跳表skiplist</li>
<li>整数集合intset</li>
<li>快速列表quicklist</li>
<li>紧凑列表listpack</li>
</ol>
<p>redis6.0.5</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717175335798.png" alt="image-20250717175335798"></p>
<p>redis7</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717175358840.png" alt="image-20250717175358840"></p>
<p>源码分析总体数据结构大纲</p>
<ul>
<li><p>redisObject操作底层定义来自哪里？</p>
<p>通常我们了解的数据结构有字符串、双端链表、字典、压缩列表、整数集合等，但是Redis为了加快读写速度，并没有直接使用这些数据结构，而是在此基础上又包装了一层称之为RedisObject。</p>
<p>RedisObject 有五种对象：字符串对象（String）、列表对象（List）、哈希对象（Hash）、集合对象（Set）和有序集合对象（ZSet）。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717175715503.png" alt="image-20250717175715503"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250717175735825.png" alt="image-20250717175735825"></p>
</li>
</ul>
<p>每个键值对都会有一个dictEntry</p>
<ul>
<li><p>set hello word为例，因为Redis是KV键值对的数据库，每个键值对都会有一个dictEntry(源码位置：dict.h)，</p>
<p>里面指向了key和value的指针，next 指向下一个 dictEntry。</p>
<p>key 是字符串，但是 Redis 没有直接使用 C 的字符数组，而是存储在redis自定义的 SDS中。</p>
<p><strong>value 既不是直接作为字符串存储，也不是直接存储在 SDS 中，而是存储在redisObject 中</strong>。</p>
<p>实际上五种常用的数据类型的任何一种，都是通过 redisObject 来存储的。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717175910184.png" alt="image-20250717175910184"></p>
<p>看看类型<code>type key</code></p>
<p>​	<img src="/hexo-docs/images/redisImages/image-20250717181148922.png" alt="image-20250717181148922"></p>
<p>看看编码<code>object encoding key</code></p>
</li>
</ul>
<p><img src="/hexo-docs/images/redisImages/image-20250717181253912.png" alt="image-20250717181253912"></p>
<p>redisObject结构的作用</p>
<p>为了便于操作，Redis采用redisObjec结构来统一五种不同的数据类型，这样所有的数据类型就都可以以相同的形式在函数间传递而不用使用特定的类型结构。同时，为了识别不同的数据类型，redisObjec中定义了type和encoding字段对不同的数据类型加以区别。简单地说，redisObjec就是string、hash、list、set、zset的父类，可以在函数间传递时隐藏具体的类型信息，所以作者抽象了redisObjec结构来到达同样的目的。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717181404448.png" alt="image-20250717181404448"></p>
<ul>
<li><p>RedisObject各字段的含义</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717181445493.png" alt="image-20250717181445493"></p>
<ol>
<li>4位的type表示具体的数据类型</li>
<li>4位的encoding表示该类型的物理编码方式见下表，同一种数据类型可能有不同的编码方式。</li>
</ol>
<p>(比如String就提供了3种:int embstr raw)</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717181509011.png" alt="image-20250717181509011"></p>
</li>
</ul>
<ol start="3">
<li><p>lru字段表示当内存超限时采用LRU算法清除内存中的对象。</p>
</li>
<li><p>refcount表示对象的引用计数。</p>
</li>
<li><p>ptr指针指向真正的底层数据结构的指针。</p>
</li>
</ol>
<p>案例</p>
<p><code>set age 17</code></p>
<p><img src="/hexo-docs/images/redisImages/image-20250717181559043.png" alt="image-20250717181559043"></p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">encoding</td>
<td align="center">编码，此处是数字类型</td>
</tr>
<tr>
<td align="center">lru</td>
<td align="center">最近被访问的时间</td>
</tr>
<tr>
<td align="center">refcount</td>
<td align="center">等于1，表示当前对象被引用的次数</td>
</tr>
<tr>
<td align="center">ptr</td>
<td align="center">value值是多少，当前就是17</td>
</tr>
</tbody></table>
<h3 id="经典5大数据结构解析"><a href="#经典5大数据结构解析" class="headerlink" title="经典5大数据结构解析"></a>经典5大数据结构解析</h3><p>各个类型的数据结构的编码映射和定义</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717181734422.png" alt="image-20250717181734422"></p>
<p><code>Debug object key</code></p>
<p>命令</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717181814642.png" alt="image-20250717181814642"></p>
<p>开启前</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717182024992.png" alt="image-20250717182024992"></p>
<p>开启后</p>
<p><img src="/hexo-docs/images/redisImages/image-20250717182218853.png" alt="image-20250717182218853"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250717182429283.png" alt="image-20250717182429283"></p>
<ul>
<li>value at: 内存地址</li>
<li>refcount: 引用次数</li>
<li>encoding: 物理编码类型</li>
<li>serializedlength: 序列化后的长度（注意这里的长度是序列化后的长度，保存为rdb文件时使用了该算法，不是真正存贮在内存的大小),会对字串做一些可能的压缩以便底层优化</li>
<li>lru：记录最近使用时间戳</li>
<li>lru_seconds_idle（秒）：空闲时间</li>
</ul>
<h3 id="String数据结构介绍"><a href="#String数据结构介绍" class="headerlink" title="String数据结构介绍"></a>String数据结构介绍</h3><p>RedisObject内部对应3大物理编码</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718172440375.png" alt="image-20250718172440375"></p>
<h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>保存long型（长整型）的64位（8个字节）有符号整数</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718172632631.png" alt="image-20250718172632631"></p>
<blockquote>
<p>只有整数才会使用int，如果是浮点数，Redis内部其实先将浮点数转化为字符串值，然后在保存。</p>
</blockquote>
<h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>代表<code>embstr</code>格式的 SDS (Simple Dynamic String 简单动态字符串)，保存长度小于44字节的字符串</p>
<p>embstr 顾名思义即：embedded string，表示嵌入式的 String</p>
<h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p>保存长度大于44字节的字符串</p>
<h4 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h4><p><img src="/hexo-docs/images/redisImages/image-20250718173724656.png" alt="image-20250718173724656"> </p>
<h4 id="C语言中字符串的展现"><a href="#C语言中字符串的展现" class="headerlink" title="C语言中字符串的展现"></a>C语言中字符串的展现</h4><p><img src="/hexo-docs/images/redisImages/image-20250718173756472.png" alt="image-20250718173756472"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250718173811739.png" alt="image-20250718173811739"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250718173820486.png" alt="image-20250718173820486"></p>
<p>用空间换取时间</p>
<h4 id="SDS简单动态字符串"><a href="#SDS简单动态字符串" class="headerlink" title="SDS简单动态字符串"></a>SDS简单动态字符串</h4><p>sds.h源码分析</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718173923812.png" alt="image-20250718173923812"></p>
<p>说明</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718173951302.png" alt="image-20250718173951302"></p>
<p>Redis中字符串的实现,SDS有多种结构（sds.h）：</p>
<p>sdshdr5、(2^5&#x3D;32byte)</p>
<p>sdshdr8、(2 ^ 8&#x3D;256byte)</p>
<p>sdshdr16、(2 ^ 16&#x3D;65536byte&#x3D;64KB)</p>
<p>sdshdr32、 (2 ^ 32byte&#x3D;4GB)</p>
<p>sdshdr64，2的64次方byte＝17179869184G用于存储不同的长度的字符串。</p>
<p>len 表示 SDS 的长度，使我们在获取字符串长度的时候可以在 O(1)情况下拿到，而不是像 C 那样需要遍历一遍字符串。</p>
<p>alloc 可以用来计算 free 就是字符串已经分配的未使用的空间，有了这个值就可以引入预分配空间的算法了，而不用去考虑内存分配的问题。</p>
<p>buf 表示字符串数组，真存数据的。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718174421071.png" alt="image-20250718174421071"></p>
<p>官网：<a target="_blank" rel="noopener" href="https://github.com/antirez/sds">https://github.com/antirez/sds</a></p>
<h4 id="Redis为什么重新设计一个SDS数据结构？"><a href="#Redis为什么重新设计一个SDS数据结构？" class="headerlink" title="Redis为什么重新设计一个SDS数据结构？"></a>Redis为什么重新设计一个SDS数据结构？</h4><p><img src="/hexo-docs/images/redisImages/image-20250718174214155.png" alt="image-20250718174214155"></p>
<p>C语言没有Java里面的String类型，只能是靠自己的char[]来实现，字符串在 C 语言中的存储方式，想要获取 「Redis」的长度，需要从头开始遍历，直到遇到 ‘\0’ 为止。所以，Redis 没有直接使用 C 语言传统的字符串标识，而是自己构建了一种名为简单动态字符串 SDS（simple dynamic string）的抽象类型，并将 SDS 作为 Redis 的默认字符串。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718174234621.png" alt="image-20250718174234621"></p>
<table>
<thead>
<tr>
<th>C语言</th>
<th>SDS</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符串长度处理</strong></td>
<td>需要从头开始遍历，直到遇到 ‘\0’ 为止，时间复杂度O(N)</td>
<td>记录当前字符串的长度，直接读取即可，时间复杂度 O(1)</td>
</tr>
<tr>
<td><strong>内存重新分配</strong></td>
<td>分配内存空间超过后，会导致数组下标越级或者内存分配溢出</td>
<td>空间预分配SDS 修改后，len 长度小于 1M，那么将会额外分配与 len 相同长度的未使用空间。如果修改后长度大于 1M，那么将分配1M的使用空间。惰性空间释放有空间分配对应的就有空间释放。SDS 缩短时并不会回收多余的内存空间，而是使用 free 字段将多出来的空间记录下来。如果后续有变更操作，直接使用 free 中记录的空间，减少了内存的分配。</td>
</tr>
<tr>
<td><strong>二进制安全</strong></td>
<td>二进制数据并不是规则的字符串格式，可能会包含一些特殊的字符，比如 ‘\0’ 等。前面提到过，C中字符串遇到 ‘\0’ 会结束，那 ‘\0’ 之后的数据就读取不上了</td>
<td>根据 len 长度来判断字符串结束的，二进制安全的问题就解决了</td>
</tr>
</tbody></table>
<h4 id="3-大物理编码方式"><a href="#3-大物理编码方式" class="headerlink" title="3 大物理编码方式"></a>3 大物理编码方式</h4><p><img src="/hexo-docs/images/redisImages/image-20250718180957953.png" alt="image-20250718180957953"></p>
<h5 id="int-编码格式"><a href="#int-编码格式" class="headerlink" title="int 编码格式"></a>int 编码格式</h5><p><img src="/hexo-docs/images/redisImages/image-20250718181512946.png" alt="image-20250718181512946"></p>
<p>命令示例： set k2 123</p>
<p>当字符串键值的内容可以用一个64位有符号整形来表示时，Redis会将键值转化为long型来进行存储，此时即对应 OBJ_ENCODING_INT 编码类型。内部的内存结构表示如下:</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718181206307.png" alt="image-20250718181206307"></p>
<p>Redis 启动时会预先建立 10000 个分别存储 0<del>9999 的 redisObject 变量作为共享对象，这就意味着如果 set字符串的键值在 0</del>10000 之间的话，则可以 <strong>直接指向共享对象 而不需要再建立新对象，此时键值不占空间！</strong></p>
<p>set k1 123</p>
<p>set k2 123</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718181233064.png" alt="image-20250718181233064"></p>
<p>redis源码：server.h，笔记下面有</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718181534080.png" alt="image-20250718181534080"></p>
<p>redis6源代码：object.c笔记下面还有</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718181635588.png" alt="image-20250718181635588"></p>
<p>redis7源代码：object.c笔记下面还有</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718181709091.png" alt="image-20250718181709091"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250718181718725.png" alt="image-20250718181718725"></p>
<blockquote>
<p>如果值一样，且是int类型的编码格式，就直接引用之前的，不会再去开辟新的空间！前提是值不能超过10000，0~9999才可以！</p>
</blockquote>
<h5 id="embstr-编码格式"><a href="#embstr-编码格式" class="headerlink" title="embstr 编码格式"></a>embstr 编码格式</h5><p><img src="/hexo-docs/images/redisImages/image-20250718181937055.png" alt="image-20250718181937055"></p>
<p>redis源代码：object.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718182001674.png" alt="image-20250718182001674"></p>
<p>对于长度小于 44的字符串，Redis 对键值采用OBJ_ENCODING_EMBSTR 方式，EMBSTR 顾名思义即：embedded string，表示嵌入式的String。从内存结构上来讲 即字符串 sds结构体与其对应的 redisObject 对象分配在同一块连续的内存空间，字符串sds嵌入在redisObject对象之中一样。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718182025751.png" alt="image-20250718182025751"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250718182036492.png" alt="image-20250718182036492"></p>
<p>进一步createEmbddedStringObject方法</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718182445621.png" alt="image-20250718182445621"></p>
<blockquote>
<p>没有申请新的redisObject对象，只是在之前redisObject对象下加了一个1，内存紧凑。实现了内存的高度连续！减少碎片，不占空间</p>
</blockquote>
<h5 id="raw编码格式"><a href="#raw编码格式" class="headerlink" title="raw编码格式"></a>raw编码格式</h5><p><img src="/hexo-docs/images/redisImages/image-20250718182644113.png" alt="image-20250718182644113"></p>
<p>set k3 大于44长度的一个字符串，随便写</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718182732390.png" alt="image-20250718182732390"></p>
<p>当字符串的键值为长度大于44的超长字符串时，Redis 则会将键值的内部编码方式改为OBJ_ENCODING_RAW格式，这与OBJ_ENCODING_EMBSTR编码方式的不同之处在于，此时动态字符串sds的内存与其依赖的redisObject的内存不再连续了</p>
<p><img src="/hexo-docs/images/redisImages/image-20250718182753983.png" alt="image-20250718182753983"></p>
<h5 id="明明没有超过阈值，为什么变成-raw-了"><a href="#明明没有超过阈值，为什么变成-raw-了" class="headerlink" title="明明没有超过阈值，为什么变成 raw 了"></a>明明没有超过阈值，为什么变成 raw 了</h5><p><img src="/hexo-docs/images/redisImages/image-20250718182842208.png" alt="image-20250718182842208"></p>
<p>如果先添加一个字符，在拼接一个字符，直接去最大“raw”</p>
<p>判断不出来，就取最大Raw</p>
<h5 id="转变逻辑图"><a href="#转变逻辑图" class="headerlink" title="转变逻辑图"></a>转变逻辑图</h5><p><img src="/hexo-docs/images/redisImages/image-20250718183008200.png" alt="image-20250718183008200"></p>
<h5 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h5><p>只有整数才会使用 int，如果是浮点数， Redis 内部其实先将浮点数转化为字符串值，然后再保存。</p>
<p>embstr 与 raw 类型底层的数据结构其实都是 SDS (简单动态字符串，Redis 内部定义 sdshdr 一种结构)。</p>
<p>那这两者的区别见下图：</p>
<table>
<thead>
<tr>
<th align="left">1 int</th>
<th align="left">Long类型整数时，RedisObject中的ptr指针直接赋值为整数数据，不再额外的指针再指向整数了，节省了指针的空间开销。</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2 embstr</td>
<td align="left">当保存的是字符串数据且字符串小于等于44字节时，embstr类型将会调用内存分配函数，只分配一块连续的内存空间，空间中依次包含 redisObject 与 sdshdr 两个数据结构，让元数据、指针和SDS是一块连续的内存区域，这样就可以避免内存碎片</td>
</tr>
<tr>
<td align="left">3 raw</td>
<td align="left">当字符串大于44字节时，SDS的数据量变多变大了，SDS和RedisObject布局分家各自过，会给SDS分配多的空间并用指针指向SDS结构，raw 类型将会调用两次内存分配函数，分配两块内存空间，一块用于包含 redisObject结构，而另一块用于包含 sdshdr 结构</td>
</tr>
</tbody></table>
<p><img src="/hexo-docs/images/redisImages/image-20250718183057653.png" alt="image-20250718183057653"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>redis 内部会根据用户给的不同键值而使用不同的编码格式，自适应地选择较优化的内部编码格式，而这一切对用户完全透明！</p>
<h3 id="Hash数据结果介绍"><a href="#Hash数据结果介绍" class="headerlink" title="Hash数据结果介绍"></a>Hash数据结果介绍</h3><h4 id="hash的两种编码格式"><a href="#hash的两种编码格式" class="headerlink" title="hash的两种编码格式"></a>hash的两种编码格式</h4><p>redis6</p>
<ul>
<li>ziplist</li>
<li>hashtable</li>
</ul>
<p>redis7</p>
<ul>
<li>listpack</li>
<li>hashtable</li>
</ul>
<h4 id="redis6（案例）"><a href="#redis6（案例）" class="headerlink" title="redis6（案例）"></a>redis6（案例）</h4><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p><strong>hash-max-ziplist-entries：使用压缩列表保存时哈希集合中的最大元素个数。</strong></p>
<p><strong>hash-max-ziplist-value：使用压缩列表保存时哈希集合中单个元素的最大长度。</strong></p>
<p>Hash类型键的字段个数 小于 hash-max-ziplist-entries 并且每个字段名和字段值的长度 小于 hash-max-ziplist-value 时，</p>
<p>Redis才会使用 OBJ_ENCODING_ZIPLIST来存储该键，前述条件任意一个不满足则会转换为 OBJ_ENCODING_HT（hashtable）的编码方式</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719170734724.png" alt="image-20250719170734724"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719170758547.png" alt="image-20250719170758547">;</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>hash-max-ziplist-entries：使用压缩列表保存时哈希集合中的最大元素个数</p>
<p>hash-max-ziplist-value：使用压缩列表保存时哈希集合中单个元素的最大长度。</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ol>
<li>哈希对象保存的键值对数量小于512个</li>
<li>所有的键值对和值的字符串长度都小于等于64byte（一个英文字母一个字节）时用ziplist，反之用hashtable</li>
</ol>
<p>ziplist升级到hashtable可以，反过来降级不可以</p>
<ul>
<li>一旦从压缩列表转为了哈希表，Hash类型就会一直用哈希表进行保存而不会再转回压缩列表了。</li>
<li>在节省内存空间方面哈希表就没有压缩列表高效了。</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p><img src="/hexo-docs/images/redisImages/image-20250719171909980.png" alt="image-20250719171909980"></p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>t_hash.c</p>
<ul>
<li><p>在 redis 中，hashtable 被称为字典（dictionary），它是一个数组+链表的结构</p>
</li>
<li><p>OBJ_ENCODING_HT（hashtable）编码分析</p>
<ul>
<li><p>OBJ_ENCODING_HT 这种编码方式内部才是真正的哈希表结构，或称为字典结构，其可以实现O(1)复杂度的读写操作，因此效率很高。</p>
<p>在 Redis内部，从 OBJ_ENCODING_HT类型到底层真正的散列表数据结构是一层层嵌套下去的，组织关系见面图：</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172057855.png" alt="image-20250719172057855"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172106542.png" alt="image-20250719172106542"></p>
<p>源代码：dict.h</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172131076.png" alt="image-20250719172131076"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172152713.png" alt="image-20250719172152713"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172207049.png" alt="image-20250719172207049"></p>
<ul>
<li>每个键值对都会有一个dictEntry</li>
</ul>
</li>
</ul>
</li>
<li><p>hset 命令解读</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172335753.png" alt="image-20250719172335753"></p>
<ul>
<li><p>类型</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172409193.png" alt="image-20250719172409193"></p>
</li>
</ul>
</li>
</ul>
<p>ziplist.c</p>
<ul>
<li><p>ziplist，什么样？</p>
<p>源代码：ziplist.c</p>
<p>为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组</p>
<p>ziplist是一个经过特殊编码的双向链表，它不存储指向前一个链表节点prev和指向下一个链表节点的指针next而是存储上一个节点长度和当前节点长度，通过牺牲部分读写性能，来换取高效的内存空间利用率，节约内存，是一种时间换空间的思想。只用在字段个数少，字段值小的场景里面</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172514866.png" alt="image-20250719172514866"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172539546.png" alt="image-20250719172539546"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172556712.png" alt="image-20250719172556712"></p>
<ul>
<li><p>ziplist 各个组成单元什么意思</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719172628534.png" alt="image-20250719172628534"></p>
</li>
</ul>
</li>
<li><p>zlentry，压缩列表节点的构成</p>
<ul>
<li><p>官网源码</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719230633635.png" alt="image-20250719230633635"></p>
</li>
<li><p>zlentry 实体结构解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 再内存中并没有存下下面结构体zlentry的内容，只是为了方便，在代码中定义了这样的结构体，包含了一些其他信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;            <span class="comment">//用来计算前面节点的地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;                          <span class="comment">//本节点的长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;                            <span class="comment">//头部大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;                             <span class="comment">//编码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ziplist 存取情况</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719230929887.png" alt="image-20250719230929887"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250719230939536.png" alt="image-20250719230939536"></p>
<table>
<thead>
<tr>
<th align="center">prevlen</th>
<th align="center">记录了前一个节点的长度；</th>
</tr>
</thead>
<tbody><tr>
<td align="center">encoding</td>
<td align="center">记录了当前节点实际数据的类型以及长度</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">记录了当前节点的实际数据</td>
</tr>
</tbody></table>
<ul>
<li><p>zlentry 解析</p>
<p>压缩列表zlentry节点结构：每个zlentry由前一个节点的长度、encoding和entry-data三部分组成</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719231031510.png" alt="image-20250719231031510"></p>
<p>前节点：(前节点占用的内存字节数)表示前1个zlentry的长度，privious_entry_length有两种取值情况：1字节或5字节。取值1字节时，表示上一个entry的长度小于254字节。虽然1字节的值能表示的数值范围是0到255，但是压缩列表中zlend的取值默认是255，因此，就默认用255表示整个压缩列表的结束，其他表示长度的地方就不能再用255这个值了。所以，当上一个entry长度小于254字节时，prev_len取值为1字节，否则，就取值为5字节。记录长度的好处：占用内存小，1或者5个字节</p>
<p>enncoding：记录节点的content保存数据的类型和长度。</p>
<p>content：保存实际数据内容</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719231058329.png" alt="image-20250719231058329"></p>
</li>
<li><p>为什么 zlentry 这么设计？数组和链表数据结构对比</p>
<p>privious_entry_length，encoding长度都可以根据编码方式推算，真正变化的是content，而content长度记录在encoding里 ，因此entry的长度就知道了。entry总长度 &#x3D; privious_entry_length字节数+encoding字节数+content字节数</p>
<p><img src="/hexo-docs/images/redisImages/image-20250719231153304.png" alt="image-20250719231153304"></p>
<p>为什么entry这么设计？记录前一个节点的长度？</p>
<p>链表在内存中，一般是不连续的，遍历相对比较慢，而ziplist可以很好的解决这个问题。如果知道了当前的起始地址，因为entry是连续的，entry后一定是另一个entry，想知道下一个entry的地址，只要将当前的起始地址加上当前entry总长度。如果还想遍历下一个entry，只要继续同样的操作。</p>
</li>
</ul>
</li>
<li><p><strong>明明有链表了，为什么出来一个压缩链表？</strong></p>
<ol>
<li><p>普通的双向链表会有两个指针，在存储数据很小的情况下，我们存储的实际数据的大小可能还没有指针占用的内存大，得不偿失。ziplist 是一个特殊的双向链表没有维护双向指针:previous next；而是存储上一个 entry的长度和当前entry的长度，通过长度推算下一个元素在什么地方。牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度更费内存。这是典型的“时间换空间”。</p>
</li>
<li><p>链表在内存中一般是不连续的，遍历相对比较慢而ziplist可以很好的解决这个问题，普通数组的遍历是根据数组里存储的数据类型找到下一个元素的(例如int类型的数组访问下一个元素时每次只需要移动一个sizeof(int)就行)，但是ziplist的每个节点的长度是可以不一样的，而我们面对不同长度的节点又不可能直接sizeof(entry)，所以ziplist只好将一些必要的偏移量信息记录在了每一个节点里，使之能跳到上一个节点或下一个节点。</p>
<p>备注:sizeof实际上是获取了数据在内存中所占用的存储空间，以字节为单位来计数。</p>
</li>
<li><p>头节点里有头节点里同时还有一个参数 len，和string类型提到的 SDS 类似，这里是用来记录链表长度的。因此获取链表长度时不用再遍历整个链表，直接拿到len值就可以了，这个时间复杂度是 O(1)</p>
</li>
</ol>
</li>
<li><p>ziplist 总结</p>
<p>ziplist为了节省内存，采用了紧凑的连续存储。</p>
<p>ziplist是一个双向链表，可以在时间复杂度为 O(1) 下从头部、尾部进行 pop 或 push。</p>
<p>新增或更新元素可能会出现连锁更新现象(致命缺点导致被listpack替换)。</p>
<p>不能保存过多的元素，否则查询效率就会降低，数量小和内容小的情况下可以使用。</p>
</li>
</ul>
</li>
</ul>
<h4 id="redis7（案例）"><a href="#redis7（案例）" class="headerlink" title="redis7（案例）"></a>redis7（案例）</h4><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><p><strong>hash-max-listpack-entries：使用压缩列表保存时哈希集合中的最大元素个数。</strong></p>
<p><strong>hash-max-listpack-value：使用压缩列表保存时哈希集合中单个元素的最大长度。</strong></p>
<p>Hash类型键的字段个数 小于 hash-max-listpack-entries且每个字段名和字段值的长度 小于 hash-max-listpack-value 时，</p>
<p>Redis才会使用OBJ_ENCODING_LISTPACK来存储该键，前述条件任意一个不满足则会转换为 OBJ_ENCODING_HT（hashtable）的编码方式 </p>
<p><img src="/hexo-docs/images/redisImages/image-20250720164040253.png" alt="image-20250720164040253"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720164419983.png" alt="image-20250720164419983"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720164515154.png" alt="image-20250720164515154"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720165008568.png" alt="image-20250720165008568"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720165109650.png" alt="image-20250720165109650"></p>
<h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><p>hash-max-listpack-entries：使用紧凑列表保存时哈希集合中的最大元素个数</p>
<p>hash-max-listpack-value：使用紧凑列表保存时哈希集合中单个元素的最大长度</p>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><ol>
<li>哈希对象保存的键值对数量小于512个</li>
<li>所有的键值对的键和值的字符串长度都小于等于64byte（一个英文字母一个字节）时用listpack，反之用hashtable</li>
</ol>
<p>listpack升级到hashtable可以，反过来降级不可以</p>
<h5 id="流程（同redis6，只不过ziplist改为listpack）"><a href="#流程（同redis6，只不过ziplist改为listpack）" class="headerlink" title="流程（同redis6，只不过ziplist改为listpack）"></a>流程（同redis6，只不过ziplist改为listpack）</h5><p><img src="/hexo-docs/images/redisImages/image-20250720165549111.png" alt="image-20250720165549111"></p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>源码说明</p>
<ul>
<li><p>实现：object.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720165652847.png" alt="image-20250720165652847"></p>
</li>
<li><p>实现：listpack.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720165725665.png" alt="image-20250720165725665"></p>
<p>lpNew 函数创建了一个空的 listpack，一开始分配的大小是 LP_HDR_SIZE 再加 1 个字节。LP_HDR_SIZE 宏定义是在 listpack.c 中，它默认是 6 个字节，其中 4 个字节是记录 listpack 的总字节数，2 个字节是记录 listpack 的元素数量。此外，listpack 的最后一个字节是用来标识 listpack 的结束，其默认值是宏定义 LP_EOF。和 ziplist 列表项的结束标记一样，LP_EOF 的值也是 255</p>
</li>
<li><p>实现2：object.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720165803047.png" alt="image-20250720165803047"></p>
</li>
</ul>
<p><strong>明明有了ziplist了，为什么出来一个listpack紧凑列表？</strong></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720165842959.png" alt="image-20250720165842959"></p>
<p>压缩列表里的每个节点中的 prelen 属性都记录了【前一个节点的长度】，而且 prelen 属性的空间大小跟前一个节点长度值有关，比如：</p>
<ul>
<li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prelen 属性需要用 <strong>1字节的空间</strong>来保存这个长度值</li>
<li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prelen 属性需要用 <strong>5字节的空间</strong>来保存这个长度值</li>
</ul>
<p>ziplist的连锁更新问题</p>
<p>​	压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。</p>
<p>案例说明：<strong>压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患</strong></p>
<p>第一步：现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170312513.png" alt="image-20250720170312513"></p>
<p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值，一切OK，O(∩_∩)O哈哈~</p>
<p>第二步：这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为entry1的前置节点，如下图：</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170340969.png" alt="image-20250720170340969"></p>
<p>因为entry1节点的prevlen属性只有1个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作并将entry1节点的prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p>
<p>第三步：连续更新问题出现</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170407334.png" alt="image-20250720170407334"></p>
<p>entry1节点原本的长度在250～253之间，因为刚才的扩展空间，此时entry1节点的长度就大于等于254，因此原本entry2节点保存entry1节点的 prevlen属性也必须从1字节扩展至5字节大小。entry1节点影响entry2节点，entry2节点影响entry3节点……一直持续到结尾。这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</p>
<p>结论</p>
<p>listpack 是 Redis 设计用来取代掉 ziplist 的数据结构，它通过每个节点记录自己的长度且放在节点的尾部，来彻底解决掉了 ziplist 存在的连锁更新的问题</p>
<p>listpack结构</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171528498.png" alt="image-20250720171528498"></p>
<ul>
<li><p>官网：<a target="_blank" rel="noopener" href="https://github.com/antirez/listpack/blob/master/listpack.md">https://github.com/antirez/listpack/blob/master/listpack.md</a></p>
</li>
<li><p>listpack由4部分组成：total Bytes、Num Elem、Entry以及End</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170710779.png" alt="image-20250720170710779"></p>
<table>
<thead>
<tr>
<th>Total Bytes</th>
<th>为整个listpack的空间大小，占用4个字节，每个listpack最多占用4294967295Bytes。</th>
</tr>
</thead>
<tbody><tr>
<td>num-elements</td>
<td>为listpack中的元素个数，即Entry的个数占用2个字节</td>
</tr>
<tr>
<td>element-1~element-N</td>
<td>为每个具体的元素</td>
</tr>
<tr>
<td>listpack-end-byte</td>
<td>为listpack结束标志，占用1个字节，内容为0xFF。</td>
</tr>
</tbody></table>
<p><img src="/hexo-docs/images/redisImages/image-20250720170735027.png" alt="image-20250720170735027"></p>
</li>
<li><p>entry 结构</p>
<ul>
<li><p>当前元素的编码类型（entry-encoding）</p>
</li>
<li><p>元素数据（entry-data）</p>
</li>
<li><p>以及编码类型和元素数据这两部分的长度（entry-len）</p>
</li>
<li><p>listpackEntry结构定义：listpack.h</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170855675.png" alt="image-20250720170855675"></p>
</li>
</ul>
</li>
</ul>
<p>ziplist 内存布局 VS listpack 内存布局</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170930879.png" alt="image-20250720170930879"></p>
<p>和ziplist 列表项类似，listpack 列表项也包含了元数据信息和数据本身。不过，为了避免ziplist引起的连锁更新问题，listpack 中的每个列表项</p>
<p>不再像ziplist列表项那样保存其前一个列表项的长度。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720170952949.png" alt="image-20250720170952949"></p>
<h5 id="hash-的两种编码格式"><a href="#hash-的两种编码格式" class="headerlink" title="hash 的两种编码格式"></a>hash 的两种编码格式</h5><ul>
<li>redis 6<ul>
<li>ziplist</li>
<li>hashtable</li>
</ul>
</li>
<li>redis 7<ul>
<li>listpack</li>
<li>hashtable</li>
</ul>
</li>
</ul>
<h3 id="List-数据结构介绍"><a href="#List-数据结构介绍" class="headerlink" title="List 数据结构介绍"></a>List 数据结构介绍</h3><h4 id="redis-6（案例）"><a href="#redis-6（案例）" class="headerlink" title="redis 6（案例）"></a>redis 6（案例）</h4><p><img src="/hexo-docs/images/redisImages/image-20250720171137367.png" alt="image-20250720171137367"></p>
<ol>
<li><p>ziplist压缩配置：list-compress-depth 0</p>
<p>表示一个quicklist两端不被压缩的节点个数。这里的节点是指quicklist双向链表的节点，而不是指ziplist里面的数据项个数</p>
<p>参数list-compress-depth的取值含义如下：</p>
<p>​	0: 是个特殊值，表示都不压缩。这是Redis的默认值。</p>
<p>​	1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</p>
<p>​	2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</p>
<p>​	3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</p>
</li>
</ol>
<p>依此类推…</p>
<ol start="2">
<li>ziplist中entry配置：list-max-ziplist-size -2</li>
</ol>
<p>​	当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，</p>
<p>每个值含义如下：</p>
<p>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb &#x3D;&gt; 1024 bytes）</p>
<p>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</p>
<p>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</p>
<p>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</p>
<p>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</p>
<h5 id="redis-6版本前的List的一种编码格式"><a href="#redis-6版本前的List的一种编码格式" class="headerlink" title="redis 6版本前的List的一种编码格式"></a>redis 6版本前的List的一种编码格式</h5><p>list用quicklist来存储，quicklist存储了一个双向链表，每个节点都是ziplist</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171355626.png" alt="image-20250720171355626"></p>
<p>在Redis3.0之前，list采用的底层数据结构是ziplist压缩列表+linkedList双向链表</p>
<p>然后在高版本的Redis中底层数据结构是quicklist(替换了ziplist+linkedList)，而quicklist也用到了ziplist</p>
<p>结论：quicklist就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171412731.png" alt="image-20250720171412731"></p>
<h5 id="quicklist总纲"><a href="#quicklist总纲" class="headerlink" title="quicklist总纲"></a>quicklist总纲</h5><p>quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171646305.png" alt="image-20250720171646305"></p>
<p>是 ziplist 和 linkedlist 的结合体</p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><ul>
<li><p>quicklist.h，head和tail指向双向列表的表头和表尾</p>
<ul>
<li><p>quicklist 结构</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171806258.png" alt="image-20250720171806258"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171814235.png" alt="image-20250720171814235"></p>
</li>
<li><p>quicklistNode 结构</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171846382.png" alt="image-20250720171846382"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171856481.png" alt="image-20250720171856481"></p>
</li>
<li><p>quicklistNode 中的 *zl 指向一个 ziplist 一个ziplist 可以存放多个元素</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720171944856.png" alt="image-20250720171944856"></p>
</li>
</ul>
</li>
</ul>
<h4 id="redis-7（案例）"><a href="#redis-7（案例）" class="headerlink" title="redis 7（案例）"></a>redis 7（案例）</h4><p><img src="/hexo-docs/images/redisImages/image-20250720172224873.png" alt="image-20250720172224873"></p>
<p>listpack紧凑列表</p>
<p>是用来替代 ziplist 的新数据结构，在 7.0 版本已经没有 ziplist 的配置了（6.0版本仅部分数据类型作为过渡阶段在使用）</p>
<h5 id="源码说明"><a href="#源码说明" class="headerlink" title="源码说明"></a>源码说明</h5><p>实现：t_list.c</p>
<ul>
<li><p>本图最下方有lpush命令执行后直接调用pushGenericCommand命令</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172316427.png" alt="image-20250720172316427"></p>
<ul>
<li><p>看看 redis 6 的相同文件 t_list.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172457864.png" alt="image-20250720172457864"></p>
</li>
</ul>
</li>
<li><p>实现：object.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172522705.png" alt="image-20250720172522705"></p>
</li>
<li><p>redis 7的 list 的一种编码格式</p>
<ul>
<li><p>list 用 quicklist 来存储，quicklist 存储了一个双向链表，每个节点都是一个listpack</p>
</li>
<li><p>quicklist</p>
<p>是 listpack 和 linkedlist 的结合体</p>
</li>
</ul>
</li>
</ul>
<h3 id="Set-数据结构介绍"><a href="#Set-数据结构介绍" class="headerlink" title="Set 数据结构介绍"></a>Set 数据结构介绍</h3><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>Redis用intset或hashtable存储set。如果元素都是整数类型，就用intset存储。</p>
<p>如果不是整数类型，就用hashtable（数组+链表的存来储结构）。key就是元素的值，value为null。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172727901.png" alt="image-20250720172727901"></p>
<p>set-proc-title 修改进程标题以显示一些运行时信息</p>
<h4 id="Set-的两种编码方式"><a href="#Set-的两种编码方式" class="headerlink" title="Set 的两种编码方式"></a>Set 的两种编码方式</h4><ol>
<li>inset</li>
<li>hashtable</li>
</ol>
<h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4><p>t_set.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172835076.png" alt="image-20250720172835076"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172852165.png" alt="image-20250720172852165"></p>
<h3 id="ZSet-数据结构介绍"><a href="#ZSet-数据结构介绍" class="headerlink" title="ZSet 数据结构介绍"></a>ZSet 数据结构介绍</h3><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><h5 id="redis-6"><a href="#redis-6" class="headerlink" title="redis 6"></a>redis 6</h5><p>当有序集合中包含的元素数量超过服务器属性 server.zset_max_ziplist_entries 的值（默认值为 128 ），</p>
<p>或者有序集合中新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 64 ）时，</p>
<p>redis会使用跳跃表作为有序集合的底层实现。</p>
<p>否则会使用ziplist作为有序集合的底层实现</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172941555.png" alt="image-20250720172941555"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720172954650.png" alt="image-20250720172954650"></p>
<h5 id="redis-7"><a href="#redis-7" class="headerlink" title="redis 7"></a>redis 7</h5><p><img src="/hexo-docs/images/redisImages/image-20250720173025379.png" alt="image-20250720173025379"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720173035219.png" alt="image-20250720173035219"></p>
<h4 id="ZSet-的两种编码格式"><a href="#ZSet-的两种编码格式" class="headerlink" title="ZSet 的两种编码格式"></a>ZSet 的两种编码格式</h4><ul>
<li>redis 6<ul>
<li>ziplist</li>
<li>skiplist</li>
</ul>
</li>
<li>redis 7<ul>
<li>listpack</li>
<li>skiplist</li>
</ul>
</li>
</ul>
<h4 id="redis-6-源码分析"><a href="#redis-6-源码分析" class="headerlink" title="redis 6 源码分析"></a>redis 6 源码分析</h4><p>t_zset.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720173208670.png" alt="image-20250720173208670"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250720173227370.png" alt="image-20250720173227370"></p>
<h4 id="redis-7-源码分析"><a href="#redis-7-源码分析" class="headerlink" title="redis 7 源码分析"></a>redis 7 源码分析</h4><p>t_zset.c</p>
<p><img src="/hexo-docs/images/redisImages/image-20250720173301672.png" alt="image-20250720173301672"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><h4 id="redis-6-类型-物理编码-对应表"><a href="#redis-6-类型-物理编码-对应表" class="headerlink" title="redis 6 类型-物理编码-对应表"></a>redis 6 类型-物理编码-对应表</h4><p><img src="/hexo-docs/images/redisImages/image-20250720173412806.png" alt="image-20250720173412806"></p>
<h4 id="redis-6-数据类型对应的底层数据结构"><a href="#redis-6-数据类型对应的底层数据结构" class="headerlink" title="redis 6 数据类型对应的底层数据结构"></a>redis 6 数据类型对应的底层数据结构</h4><ol>
<li><p>字符串</p>
<p>int：8个字节的长整型。</p>
<p>embstr：小于等于44个字节的字符串。</p>
<p>raw：大于44个字节的字符串。</p>
<p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p>
</li>
<li><p>哈希</p>
<p>ziplist(压缩列表)：当哈希类型元素个数小于hash-max-ziplist-entries 配置(默认512个)、同时所有值都小于hash-max-ziplist-value配置(默认64 字节)时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的 结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</p>
<p>hashtable(哈希表)：当哈希类型无法满足ziplist的条件时，Redis会使 用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O(1)。</p>
</li>
<li><p>列表</p>
<p>ziplist(压缩列表)：当列表的元素个数小于list-max-ziplist-entries配置 (默认512个)，同时列表中每个元素的值都小于list-max-ziplist-value配置时 (默认64字节)，Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</p>
<p>linkedlist(链表)：当列表类型无法满足ziplist的条件时，Redis会使用 linkedlist作为列表的内部实现。quicklist ziplist和linkedlist的结合以ziplist为节点的链表(linkedlist)</p>
</li>
<li><p>集合</p>
<p>intset(整数集合)：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置(默认512个)时，Redis会用intset来作为集合的内部实现，从而减少内存的使用。hashtable(哈希表)：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</p>
</li>
<li><p>有序集合</p>
<p>ziplist(压缩列表)：当有序集合的元素个数小于zset-max-ziplist- entries配置(默认128个)，同时每个元素的值都小于zset-max-ziplist-value配 置(默认64字节)时，Redis会用ziplist来作为有序集合的内部实现，ziplist 可以有效减少内存的使用。</p>
<p>skiplist(跳跃表):当ziplist条件不满足时，有序集合会使用skiplist作 为内部实现，因为此时ziplist的读写效率会下降。</p>
</li>
</ol>
<h4 id="redis-6-数据类型以及数据结构的关系"><a href="#redis-6-数据类型以及数据结构的关系" class="headerlink" title="redis 6 数据类型以及数据结构的关系"></a>redis 6 数据类型以及数据结构的关系</h4><p><img src="/hexo-docs/images/redisImages/image-20250720173713526.png" alt="image-20250720173713526"></p>
<h4 id="redis-7数据类型以及数据结构的关系"><a href="#redis-7数据类型以及数据结构的关系" class="headerlink" title="redis 7数据类型以及数据结构的关系"></a>redis 7数据类型以及数据结构的关系</h4><p><img src="/hexo-docs/images/redisImages/image-20250720173754323.png" alt="image-20250720173754323"></p>
<h4 id="redis-数据类型以及数据结构的时间复杂度"><a href="#redis-数据类型以及数据结构的时间复杂度" class="headerlink" title="redis 数据类型以及数据结构的时间复杂度"></a>redis 数据类型以及数据结构的时间复杂度</h4><p><img src="/hexo-docs/images/redisImages/image-20250720173829537.png" alt="image-20250720173829537"></p>
<h3 id="skiplist面试题"><a href="#skiplist面试题" class="headerlink" title="skiplist面试题"></a>skiplist面试题</h3><h4 id="为什么引出跳表"><a href="#为什么引出跳表" class="headerlink" title="为什么引出跳表"></a>为什么引出跳表</h4><p>先从一个单链表来讲</p>
<ul>
<li><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。</p>
</li>
<li><p>这样查找效率就会很低，时间复杂度会很高O(N)</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162119847.png" alt="image-20250721162119847"></p>
</li>
</ul>
<h4 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h4><p><img src="/hexo-docs/images/redisImages/image-20250721162155118.png" alt="image-20250721162155118"></p>
<p> 解决方法：升维，也叫空间换时间。</p>
<ul>
<li><p>优化 1</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162221385.png" alt="image-20250721162221385"></p>
<p>这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。</p>
</li>
<li><p>优化 2</p>
<ul>
<li><p>画了一个包含 64 个结点的链表，按照前面讲的这种思路，建立了五级索引</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162337117.png" alt="image-20250721162337117"></p>
</li>
</ul>
</li>
</ul>
<h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>跳表是可以实现二分查找的有序链表</p>
<p>skiplist是一种以空间换取时间的结构。</p>
<p>由于链表，无法进行二分查找，因此借鉴数据库索引的思想，提取出链表中关键节点（索引），先在关键节点上查找，再进入下层链表查找，提取多层关键节点，就形成了跳跃表</p>
<p>但是：由于索引也要占据一定空间的，所以，索引添加的越多，空间占用的越多</p>
<blockquote>
<p>总结来讲</p>
<p>​	跳表 &#x3D; 链表 + 多级索引</p>
</blockquote>
<h4 id="跳表时间-空间复杂度介绍"><a href="#跳表时间-空间复杂度介绍" class="headerlink" title="跳表时间+空间复杂度介绍"></a>跳表时间+空间复杂度介绍</h4><ul>
<li><p>跳表的时间复杂度</p>
<p>跳表查询的时间复杂度分析，如果链表里有N个结点，会有多少级索引呢？</p>
<p>按照我们前面讲的，两两取首。每两个结点会抽出一个结点作为上一级索引的结点，以此估算：</p>
<p>第一级索引的结点个数大约就是n&#x2F;2，</p>
<p>第二级索引的结点个数大约就是n&#x2F;4，</p>
<p>第三级索引的结点个数大约就是n&#x2F;8，依次类推……</p>
<p>也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1&#x2F;2，那第k级索引结点的个数就是n&#x2F;(2^k)</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162527062.png" alt="image-20250721162527062"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162534143.png" alt="image-20250721162534143"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162543774.png" alt="image-20250721162543774"></p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162559150.png" alt="image-20250721162559150"></p>
<p>时间复杂度是 O(logN)</p>
</li>
<li><p>跳表的空间复杂度</p>
<p>跳表查询的空间复杂度分析</p>
<p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢？</p>
<p>我们来分析一下跳表的空间复杂度。</p>
<p>第一步：首先原始链表长度为n，</p>
<p>第二步：两两取首，每层索引的结点数：n&#x2F;2, n&#x2F;4, n&#x2F;8 … , 8, 4, 2 每上升一级就减少一半，直到剩下2个结点,以此类推；如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<p><img src="/hexo-docs/images/redisImages/image-20250721162654157.png" alt="image-20250721162654157"></p>
<p>这几级索引的结点总和就是n&#x2F;2+n&#x2F;4+n&#x2F;8…+8+4+2&#x3D;n-2。所以，跳表的空间复杂度是O(n) 。也就是说，如果将包含n个结点的单链表构造成跳表，我们需要额外再用接近n个结点的存储空间。</p>
</li>
<li><p>优缺点</p>
<p><strong>优点：</strong></p>
<p>跳表是一个最典型的空间换时间解决方案，而且只有在数据量较大的情况下才能体现出来优势。而且应该是读多写少的情况下才能使用，所以它的适用范围应该还是比较有限的</p>
<p><strong>缺点：</strong> </p>
<p>维护成本相对要高，</p>
<p>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1) </p>
<p>但是：</p>
<p>新增或者删除时需要把所有索引都更新一遍，为了保证原始链表中数据的有序性，我们需要先找</p>
<p>到要动作的位置，这个查找操作就会比较耗时最后在新增和删除的过程中的更新，时间复杂度也是O(log n)</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs">Lazy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs/2025/08/13/redis/redis%E7%BB%8F%E5%85%B8%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">https://mac2git.github.io/hexo-docs/2025/08/13/redis/redis经典五大类型及底层实现/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mac2git.github.io/hexo-docs" target="_blank">Lazy的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/hexo-docs/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://pic.crazytaxii.com/Redis_Logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="Redis分布式锁"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis分布式锁</div></div><div class="info-2"><div class="info-item-1">redis分布式锁目的：解决多个服务原子性的问题 在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。那具体什么是分布式锁，分布式锁应用在哪些业务场景、如何来实现分布式锁呢？ 锁的种类  单机版同一个jvm虚拟机内，synchronized或者Lock接口 分布式多个不同虚拟机，单机的线程锁机制不再起作用，资源类在不同的服务器之间共享了  一个靠谱分布式锁需要具备的条件和刚需  独占性 OnlyOne，任何时刻只能有且仅有一个线程持有  高可用 若redis集群环境下，不能因为某一个节点挂了而出现获取锁和释放锁失败的情况 高并发请求下，依旧性能ok好使  防死锁 杜绝死锁，必须有超时控制机制或者撤销操作，有个兜底终止跳出方案  不乱抢 不能私下unlock（解）别人的锁，只能自己加锁自己释放  重入性 同一个节点的同一个线程如何获得锁之后，它也可以再次获得这个锁。   分布式锁  案例1使用场景：多个服务间保证同一时刻同一时间段内同一用户只能有一个请求（防止关键业务出现并发攻击） 两个服务，分别是redis_distributed_l...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/replica/" title="Replica(主从复制)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Replica(主从复制)</div></div><div class="info-2"><div class="info-item-1">复制（replica）就是主从复制，master以写为主，slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库 优点：  读写分离 容灾恢复 数据备份 水平扩容支撑高并发  如何使用  配从（库）不配主（库） 权限细节，重要 master 如果配置了 requirepass 参数，需要密码登录 那么 slave 就要配置 masterauth 来设置校验密码，否则的话 master 会拒绝 slave的访问请求      基本操作命令 info replication：可以查看复制节点的主从关系和配置信息 replicaof 主库IP 主库端口：一般写入进 redis.conf 配置文件内 slaveof 主库IP 主库端口 每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜主数据库   slaveof no one：使当前数据库停止与其他数据库的同步，转成...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/RDB+AOF/" title="RDB+AOF"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">RDB+AOF</div></div><div class="info-2"><div class="info-item-1">redis数据数据持久化 为什么要用数据持久化？ 数据持久化可以在内存丢失或其他灾难性故障的情况下实现恢复。 数据持久化的两种方式  AOF：以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写入指令从前到后执行一次以完成数据的恢复工作。 RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。  rdb（redis database）能干嘛？ 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot内存快照，它恢复时再将硬盘快照文件直接读回到内存里。Redis的数据都在内存中，保存备份时它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，一锅端。 Rdb保存的是dump.rdb文件  Redis6.0.16以下  Redis6.2以及Redis-7.0.0  自动触发 redis7版本，按照redis.conf里配置的save&lt;seconds&gt;&lt...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/Redlock%E7%AE%97%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="RedLock算法和底层源码分析和缓存淘汰策略"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">RedLock算法和底层源码分析和缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">上一章自研的redis锁对于一般中小公司，不是特别高并发场景足够用了，单机redis小业务也撑得住。但是对于特别高并发场景的话，就得使用Redisson了 Redis分布式锁-RedLock红锁算法（Distributed locks with Redis）官网：Redis 的分布式锁 |文档 说明：  为什么学习这个？怎样产生的？   线程 1 首先获取锁成功，将键值对写入 redis 的 master 节点，在 redis 将该键值对同步到 slave 节点之前，master 发生了故障；redis 触发故障转移，其中一个 slave 升级为新的 master，此时新上位的master并不包含线程1写入的键值对，因此线程 2 尝试获取锁也可以成功拿到锁，此时相当于有两个线程获取到了锁，可能会导致各种预期之外的情况发生，例如最常见的脏数据。  我们加的是排它独占锁，同一时间只能有一个建redis锁成功并持有锁，严禁出现2个以上的请求线程拿到锁。危险的！ RedLock算法设计理念Redis也提供了Redlock算法，用来实现基于多个实例的分布式锁。锁变量由多个实例维护，即使有实...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/bigkey%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99/" title="BigKey和缓存双写"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">BigKey和缓存双写</div></div><div class="info-2"><div class="info-item-1">Redis为什么是单线程这种问法其实并不严谨，为啥这么说呢? Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。  版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。  版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是开始加了点多线程的东西(异步删除)。—貌似  2020年5月版本的6.0.x后及2022年出的7.0版本后，告别了大家印象中的单线程，用一种全新的多线程来解决问题。—实锤   几个里程碑的redis版本！  5.0版本是直接升级到6.0版本，对于这个激进的升级，Redis之父antirez表现得很有信心和兴奋， 所以第一时间发文来阐述6.0的一些重大功能”Redis 6.0.0 GA is out!” 当然，Redis7.0后版本更加厉害  Redis是单线程 主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/hyperloglogGeoBitmap/" title="HyperLogLog&amp;Geo&amp;Bitmap"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">HyperLogLog&amp;Geo&amp;Bitmap</div></div><div class="info-2"><div class="info-item-1">统计类型有哪些？ 亿级系统中常见的四种统计  聚合统计 统计多个集合元素的聚合结果，就是前面的交集差集等集合统计   排序统计（zset） 在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使用ZSet  因为可以使用分页，正反排序  二值统计（bitmap） 集合元素的取值就只有0和1两种，在钉钉上班签到打开的场景中，我们只用记录有签到（1）和没签到（0）  基数统计（hyperloglog） 指 统计一个集合不重复元素个数     HyperLogLog名词解释  什么是UV?  Unique Visitor，独立访客，一般理解为客户端IP 需要去重考虑，例如一个人一天访问了10次网站，一天的UV就是1   什么是PV?  Page View，页面浏览量 不用去重，例如一个人一天访问了10次网站，一天的PV就是10   什么是DAU?  Daily  Active User  日活跃用户量 登录或者使用了某个产品的用户数（去重复登录的用户），避免恶意刷单  常用于反映网站，互联网应用或者网络游戏的运营情况      什么是MAU？  Monthly...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/index/" title="Redis基础"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">Redis基础</div></div><div class="info-2"><div class="info-item-1">什么是Redis？Redis 是一个内存数据存储，被数百万开发者用作缓存、向量数据库、文档数据库、流式引擎和消息代理。Redis 具有内置的复制和不同级别的磁盘持久化。它支持复杂的数据类型（例如，字符串、散列、列表、集合、有序集合和 JSON），并为这些数据类型定义了原子操作。 Redis 通常被称为数据结构服务器。这意味着 Redis 通过一组命令提供对可变数据结构的访问，这些命令通过 TCP 套接字和简单协议使用服务器-客户端模型发送。因此，不同的进程可以以共享的方式查询和修改相同的数据结构。 Redis 实现的数据结构具有一些特殊的属性：  Redis 会将其存储在磁盘上，即使它们总是被服务器内存中读取和修改。这意味着 Redis 速度快，但同时也非易失性。 数据结构的实现强调内存效率，因此 Redis 内部的数据结构可能比使用高级编程语言建模的相同数据结构模型使用更少的内存。 Redis 提供了一系列数据库中常见的功能，如复制、可调的持久性级别、集群和高度可用性。  下载Redis 命名规则： ​	版本号第二位如果是奇数，则为非稳定版本，如2.7、2.9、3.1 ​	版本...</div></div></div></a><a class="pagination-related" href="/hexo-docs/2025/08/13/redis/pub&sub/" title="pub&amp;sub(发布&amp;订阅)"><img class="cover" src="https://pic.crazytaxii.com/Redis_Logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-13</div><div class="info-item-2">pub&amp;sub(发布&amp;订阅)</div></div><div class="info-2"><div class="info-item-1">发布&#x2F;订阅是一种消息通信模式：发送者（publish）发送消息，订阅者（subscribe）接受消息，可以实现进程间的消息传递 Redis  可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。不推荐使用该功能，专业的事情交给专业的中间件，redis就做好分布式缓存功能 能干嘛？  redis 客户端可以订阅任意数量的频道，类似我们微信关注多个公众号   当有新的消息通过 publish 命令发送给频道 channel1 时     总结： 发布&#x2F;订阅其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理实时性较高的异步消息    常用命令  subscribe channel [channel...]   订阅给定的一个或多个频道的信息 推荐先执行订阅后再发布，订阅成功之前发布的消息是收不到的 订阅的客户端每次可以收到一个3个参数的消息 消息的种类 始发频道的名称 实际的消息内容         publish channel message    发布消息到指定的频道    psubscribe pattern[pattern...] ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lazy</div><div class="author-info-description">归途也还可爱</div><div class="site-data"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mac2git"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mac2git" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/wx_00ba6ce280" target="_blank" title="Gitee"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客正在施工，请先随便逛逛。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BB%8F%E5%85%B8%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redis经典五大类型源码及底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-text">Redis核心部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E9%AA%A8%E6%9E%B6%EF%BC%89"><span class="toc-text">Redis基本数据结构（骨架）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redis数据库的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redis服务端和客户端实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E6%97%B6%E8%AF%B4%E7%9A%84redis%E7%9A%84%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E5%BA%93KV%E9%94%AE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">平时说的redis的字典数据库KV键到底是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%A4%A7%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82C%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">5大结构底层C语言源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B85%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90"><span class="toc-text">经典5大数据结构解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">String数据结构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int"><span class="toc-text">int</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#embstr"><span class="toc-text">embstr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raw"><span class="toc-text">raw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95"><span class="toc-text">案例测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B1%95%E7%8E%B0"><span class="toc-text">C语言中字符串的展现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SDS%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">SDS简单动态字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AASDS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">Redis为什么重新设计一个SDS数据结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%A7%E7%89%A9%E7%90%86%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">3 大物理编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#int-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">int 编码格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#embstr-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">embstr 编码格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#raw%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">raw编码格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%8E%E6%98%8E%E6%B2%A1%E6%9C%89%E8%B6%85%E8%BF%87%E9%98%88%E5%80%BC%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%98%E6%88%90-raw-%E4%BA%86"><span class="toc-text">明明没有超过阈值，为什么变成 raw 了</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E5%8F%98%E9%80%BB%E8%BE%91%E5%9B%BE"><span class="toc-text">转变逻辑图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA"><span class="toc-text">案例结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%BB%8B%E7%BB%8D"><span class="toc-text">Hash数据结果介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">hash的两种编码格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis6%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-text">redis6（案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis7%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-text">redis7（案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-1"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%EF%BC%88%E5%90%8Credis6%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87ziplist%E6%94%B9%E4%B8%BAlistpack%EF%BC%89"><span class="toc-text">流程（同redis6，只不过ziplist改为listpack）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hash-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">hash 的两种编码格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">List 数据结构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-6%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-text">redis 6（案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redis-6%E7%89%88%E6%9C%AC%E5%89%8D%E7%9A%84List%E7%9A%84%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">redis 6版本前的List的一种编码格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#quicklist%E6%80%BB%E7%BA%B2"><span class="toc-text">quicklist总纲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-7%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89"><span class="toc-text">redis 7（案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-text">源码说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">Set 数据结构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">Set 的两种编码方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZSet-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">ZSet 数据结构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redis-6"><span class="toc-text">redis 6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis-7"><span class="toc-text">redis 7</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZSet-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">ZSet 的两种编码格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-6-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">redis 6 源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-7-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">redis 7 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">小总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-6-%E7%B1%BB%E5%9E%8B-%E7%89%A9%E7%90%86%E7%BC%96%E7%A0%81-%E5%AF%B9%E5%BA%94%E8%A1%A8"><span class="toc-text">redis 6 类型-物理编码-对应表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">redis 6 数据类型对应的底层数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">redis 6 数据类型以及数据结构的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">redis 7数据类型以及数据结构的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">redis 数据类型以及数据结构的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skiplist%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">skiplist面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%87%BA%E8%B7%B3%E8%A1%A8"><span class="toc-text">为什么引出跳表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%97%9B%E7%82%B9"><span class="toc-text">痛点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%8B%E7%BB%8D"><span class="toc-text">跳表时间+空间复杂度介绍</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/22/nginx/nginx/" title="Nginx"><img src="https://nginx.org/img/nginx_logo.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/22/nginx/nginx/" title="Nginx">Nginx</a><time datetime="2025-09-21T16:00:00.000Z" title="发表于 2025-09-22 00:00:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/17/docker/docker/" title="Docker"><img src="/hexo-docs/images/dockerImages/docker.webp" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/17/docker/docker/" title="Docker">Docker</a><time datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ"><img src="/hexo-docs/images/rocketmqImages/cover.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/08/29/commit_protocol/index/" title="两阶段提交与三阶段提交"><img src="/hexo-docs/images/commit_protocolImages/img.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="两阶段提交与三阶段提交"/></a><div class="content"><a class="title" href="/hexo-docs/2025/08/29/commit_protocol/index/" title="两阶段提交与三阶段提交">两阶段提交与三阶段提交</a><time datetime="2025-08-28T16:00:00.000Z" title="发表于 2025-08-29 00:00:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/08/26/other/mysql_id/" title="在实际开发过程中Mysql该选用ID什么ID作为主键？"><img src="/hexo-docs/images/mysql_idImages/cover.svg" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="在实际开发过程中Mysql该选用ID什么ID作为主键？"/></a><div class="content"><a class="title" href="/hexo-docs/2025/08/26/other/mysql_id/" title="在实际开发过程中Mysql该选用ID什么ID作为主键？">在实际开发过程中Mysql该选用ID什么ID作为主键？</a><time datetime="2025-08-26T09:24:30.000Z" title="发表于 2025-08-26 17:24:30">2025-08-26</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Lazy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/hexo-docs/js/utils.js"></script><script src="/hexo-docs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="14px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/hexo-docs/js/search/local-search.js"></script></div></div></body></html>