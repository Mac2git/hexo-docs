<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker | Lazy的个人博客</title><meta name="author" content="Lazy"><meta name="copyright" content="Lazy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Docker从0到1">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://mac2git.github.io/hexo-docs/2025/09/17/docker/docker/index.html">
<meta property="og:site_name" content="Lazy的个人博客">
<meta property="og:description" content="Docker从0到1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mac2git.github.io/hexo-docs/images/dockerImages/docker.webp">
<meta property="article:published_time" content="2025-09-16T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-17T00:47:58.630Z">
<meta property="article:author" content="Lazy">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="云原生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mac2git.github.io/hexo-docs/images/dockerImages/docker.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker",
  "url": "https://mac2git.github.io/hexo-docs/2025/09/17/docker/docker/",
  "image": "https://mac2git.github.io/hexo-docs/images/dockerImages/docker.webp",
  "datePublished": "2025-09-16T16:00:00.000Z",
  "dateModified": "2025-09-17T00:47:58.630Z",
  "author": [
    {
      "@type": "Person",
      "name": "Lazy",
      "url": "https://mac2git.github.io/hexo-docs"
    }
  ]
}</script><link rel="shortcut icon" href="/hexo-docs/images/webImages/logo.svg"><link rel="canonical" href="https://mac2git.github.io/hexo-docs/2025/09/17/docker/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/hexo-docs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/hexo-docs/',
  algolia: undefined,
  localSearch: {"path":"/hexo-docs/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Lazy","link":"链接: ","source":"来源: Lazy的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post type-categories" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/hexo-docs/images/dockerImages/docker.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/hexo-docs/"><span class="site-name">Lazy的个人博客</span></a><a class="nav-page-title" href="/hexo-docs/"><span class="site-name">Docker</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo-docs/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo-docs/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/hexo-docs/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo-docs/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/hexo-docs/about"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T00:47:58.630Z" title="更新于 2025-09-17 08:47:58">2025-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/hexo-docs/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">26.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>97分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="为什么会出现Docker？"><a href="#为什么会出现Docker？" class="headerlink" title="为什么会出现Docker？"></a>为什么会出现Docker？</h2><p>当开发的应用依赖于当前的电脑配置和某些配置文件，为了能够尽可能多地在其他本地模拟这些环境而不产生重新创建服务器环境的开销，此时可以使用容器技术。</p>
<p>Docker 之所以发展如此迅速，就是因为它对此给出了一个标准化的解决方案 —— 系统平滑移植，容器虚拟化技术。</p>
<p>当环境配置相当复杂时，人们会想到能不能从根本上解决这个问题，软件可不可以连带着其需要的环境一起安装？也就是在安装软件的时候，一并把原始环境也一模一样地复制过来，开发人员利用 Docker 消除协作编码时产生的「在我的机器上都能跑，怎么你的不行」的问题。</p>
<p>Docker 的出现打破了「程序即应用」的关联，通过镜像（images）将作业系统核心除外，运作应用程序所需要的系统环境由上而下地打包，达到应用程序跨平台的无缝接轨运作。</p>
<p>Docker 是基于 Golang 实现的云开源项目，它的主要目标是「Build, Ship and Run Any App, Anywhere」，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的应用程序及其运行环境能够做到「一次镜像，处处运行」。</p>
<p>Linux 容器技术的出现就解决了这样一个问题，Docker 是在它的基础上发展过来的。将应用打包成镜像，通过镜像成为运行在 Docker 容器上的实例。Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上还能一键部署好，极大简化了操作。</p>
<p>一句话：Docker 是解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
<p>Docker的理念包括容器化、轻量化、隔离性、可移植性和模块化。它利用Linux内核的命名空间、控制组和分层文件系统等技术，实现高效的资源管理和隔离。Docker的核心思想是将应用程序及其所有依赖打包到一个可移植的容器中，从而确保应用在任何环境中都能一致地运行。</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p>
<h2 id="Docker-应用场景及优缺点"><a href="#Docker-应用场景及优缺点" class="headerlink" title="Docker 应用场景及优缺点"></a>Docker 应用场景及优缺点</h2><p>应用场景：</p>
<ul>
<li><strong>微服务架构：</strong>每个服务独立容器化，便于管理和扩展。</li>
<li><strong>CI&#x2F;CD流水线：</strong>与 Jenkins&#x2F;GitLab CI 集成，实现自动化构建和测试。</li>
<li><strong>开发环境标准化：</strong>新成员一键启动全套依赖服务（如数据库、消息队列）。</li>
<li><strong>云原生基础：</strong>Kubernetes 等编排工具基于 Docker 管理容器集群。</li>
</ul>
<p>核心优势：</p>
<ul>
<li><strong>跨平台一致性：</strong>解决”在我机器上能跑”的问题，确保开发、测试、生产环境一致。</li>
<li><strong>资源高效：</strong>容器直接共享主机内核，无需虚拟化整个操作系统，节省内存和 CPU。</li>
<li><strong>快速部署：</strong>秒级启动容器，支持自动化扩缩容。</li>
<li><strong>隔离性：</strong>每个容器拥有独立的文件系统、网络和进程空间。</li>
</ul>
<p>优势：</p>
<ul>
<li><strong>跨平台一致性：</strong>解决”在我机器上能跑”的问题，确保开发、测试、生产环境一致。</li>
<li><strong>资源高效：</strong>容器直接共享主机内核，无需虚拟化整个操作系统，节省内存和 CPU。</li>
<li><strong>快速部署：</strong>秒级启动容器，支持自动化扩缩容。</li>
<li><strong>隔离性：</strong>每个容器拥有独立的文件系统、网络和进程空间。</li>
</ul>
<p>Docker 的缺点主要集中在 <strong>安全性、性能、管理复杂性</strong> 和 <strong>数据持久化</strong> 等方面。尽管如此，通过合理的配置和工具（如 Kubernetes（k8s）），可以在一定程度上缓解这些问题，从而更好地发挥 Docker 的优势！</p>
<p>核心概念：</p>
<ul>
<li><strong>容器（Container）：</strong>轻量化的运行实例，包含应用代码、运行时环境和依赖库。基于镜像创建，与其他容器隔离，共享主机操作系统内核（比虚拟机更高效）。</li>
<li><strong>镜像（Image）：</strong>只读模板，定义了容器的运行环境（如操作系统、软件配置等）。通过分层存储（Layer）优化空间和构建速度。</li>
<li><strong>Dockerfile：</strong>文本文件，描述如何自动构建镜像（例如指定基础镜像、安装软件、复制文件等）。</li>
<li><strong>仓库（Registry）：</strong>存储和分发镜像的平台，如 Docker Hub（官方公共仓库）或私有仓库（如 Harbor）。</li>
</ul>
<h2 id="安装-卸载docker"><a href="#安装-卸载docker" class="headerlink" title="安装&#x2F;卸载docker"></a>安装&#x2F;卸载docker</h2><p>Docker 官网： <a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>Docker Hub 官网：</p>
<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>支持平台</p>
<table>
<thead>
<tr>
<th align="left">平台</th>
<th align="center">x86_64 &#x2F; AMD64</th>
<th align="center">ARM64 &#x2F; AACH64</th>
<th align="center">ARM（32 位）</th>
<th align="center">PPC64LE 系列</th>
<th align="center">S390X 系列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CentOS作系统</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Debian</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Fedora</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center"></td>
<td align="center">✅</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Ubuntu</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。</p>
<p>Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。</p>
<p>因此，Docker 必须部署在 Linux 内核的系统上， 如果有其他系统想要部署 Docker 就必须安装一个 Linux 环境。</p>
<p>查看 Linux 内核信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-realease</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902183750322.png" alt="image-20250902183750322"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>安装<code>yum-utils</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902162615177.png" alt="image-20250902162615177"></p>
</li>
<li><p>设置<code>stable</code>镜像库，如果不设置，容易超时</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo # （中央仓库）容易超时</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #（阿里仓库）</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902163142549.png" alt="image-20250902163142549"></p>
</li>
<li><p>建议更新一下yum索引，怕下载出错！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902163412677.png" alt="image-20250902163412677"></p>
</li>
<li><p>安装<code>docker engine</code>（docker引擎）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902163908627.png" alt="image-20250902163908627"></p>
</li>
<li><p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902164513906.png" alt="image-20250902164513906"></p>
<p>启动docker发现报了个错，说<code>systemctl enable--现在docker.service的dockerJob失败，因为控制进程退出并返回错误代码</code>。</p>
<p>解决办法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/docker/ # 进入到docker目录下</span><br><span class="line">mv daemon.json daemon.conf #修改文件格式为conf类型的</span><br><span class="line">systemctl restart docker # 重新启动docker</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902164834029.png" alt="image-20250902164834029"></p>
<p>没有报错，就是好消息，说明我们的<code>docker</code>启动成功了！</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250902165042223.png" alt="image-20250902165042223"></p>
</li>
<li><p>在linux开启自启docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>


</li>
<li><p>查看安装<code>docker</code>的版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250902165417862.png" alt="image-20250902165417862"></p>
</li>
</ol>
<p>安装时出现的问题</p>
<p>当你在安装或使用 Docker 时，，执行<code>docker info</code>，可能会遇到以下警告：“WARNING: bridge-nf-call-iptables is disabled”。这个警告表示你的系统没有启用 <em>bridge-nf-call-iptables</em>，这可能会导致 Docker 网络功能无法正常工作。</p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<ol>
<li>修改内核参数</li>
</ol>
<p>首先，你需要修改系统的内核参数以启用 <em>bridge-nf-call-iptables</em>。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>打开 <em>&#x2F;etc&#x2F;sysctl.conf</em> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存并退出编辑器。</p>
</li>
</ul>
<ol start="2">
<li><p>使配置生效</p>
<p>执行以下命令使配置生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证配置</p>
<p>你可以通过以下命令验证配置是否生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod | grep br_netfilter</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保重启后配置依然生效</p>
<p>为了确保在系统重启后配置依然生效，可以设置开机自动加载模块的脚本。</p>
<p>步骤：</p>
<ul>
<li><p>在 <em>&#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;</em> 目录下新建文件 <em>br_netfilter.modules</em>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/modules/br_netfilter.modules</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>保存并退出编辑器，然后给文件授权：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/sysconfig/modules/br_netfilter.modules</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>通过以上步骤，你可以解决 “bridge-nf-call-iptables is disabled” 的警告，确保 Docker 网络功能正常工作。</p>
<h3 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h3>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker # 停止docker</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io # 卸载docker引擎</span><br><span class="line">rm -rf /var/lib/docker # 删除docker目录</span><br><span class="line">rm -rf /var/lib/containerd # 删除容器目录</span><br></pre></td></tr></table></figure>

<h2 id="永远的-hello-world"><a href="#永远的-hello-world" class="headerlink" title="永远的 hello-world"></a>永远的 hello-world</h2><p><img src="/hexo-docs/images/dockerImages/image-20250902165748769.png" alt="image-20250902165748769"></p>
<p>添加一下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [</span><br><span class="line">   &quot;https://proxy.1panel.live&quot;,</span><br><span class="line">   &quot;https://docker.1panel.top&quot;,</span><br><span class="line">   &quot;https://docker.m.daocloud.io&quot;,</span><br><span class="line">   &quot;https://docker.1ms.run&quot;,</span><br><span class="line">   &quot;https://docker.ketches.cn&quot;,</span><br><span class="line">   &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">   &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">   &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>在执行一下<code>docker run hello-world</code></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250902171337051.png" alt="image-20250902171337051"></p>
<p>当<code>docker run</code>时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[开始] --&gt; B[Docker 在本机中寻找镜像]</span><br><span class="line">    B --&gt; C&#123;本机是否有镜像&#125;</span><br><span class="line">    C --&gt;|是| D[以该镜像为模板生产容器实例运行]</span><br><span class="line">    D --&gt; E[结束]</span><br><span class="line">    C --&gt;|否| F[去 Docker Hub 上查找该镜像]</span><br><span class="line">    F --&gt; G&#123;Docker Hub 上能否找到&#125;</span><br><span class="line">    G --&gt;|是| H[下载该镜像到本地]</span><br><span class="line">    H --&gt; D</span><br><span class="line">    G --&gt;|否| I[返回失败错误，查不到该镜像]</span><br><span class="line">    I --&gt; E</span><br></pre></td></tr></table></figure>



<h2 id="Docker为什么比虚拟机快？"><a href="#Docker为什么比虚拟机快？" class="headerlink" title="Docker为什么比虚拟机快？"></a>Docker为什么比虚拟机快？</h2><p>Docker 是一种容器化技术，虚拟机（VM）是通过软件模拟硬件环境来运行操作系统的技术，Docker 比虚拟机快，主要原因如下：</p>
<h3 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h3><ul>
<li><strong>Docker</strong>：Docker 容器启动时，不需要像虚拟机那样启动整个操作系统内核。它共享宿主机的内核，仅需启动应用程序及其依赖项，启动过程类似启动一个进程，所以速度非常快，通常可以在秒级甚至毫秒级完成启动 。</li>
<li><strong>虚拟机</strong>：虚拟机在启动时，需要加载完整的客户机操作系统内核，包括初始化硬件驱动、系统服务等一系列操作，这一过程相对复杂且耗时，启动时间可能需要几十秒甚至数分钟 。</li>
</ul>
<h3 id="资源占用"><a href="#资源占用" class="headerlink" title="资源占用"></a>资源占用</h3><ul>
<li><strong>Docker</strong>：由于容器共享宿主机内核，不需要额外模拟硬件环境，因此占用的系统资源较少。每个容器仅包含应用程序及其运行所需的依赖项，内存占用通常在 MB 级别 。</li>
<li><strong>虚拟机</strong>：虚拟机需要模拟完整的硬件环境，包括 CPU、内存、硬盘、网卡等，并且运行独立的操作系统，因此会占用大量的系统资源，内存占用往往在 GB 级别 。</li>
</ul>
<h3 id="存储开销"><a href="#存储开销" class="headerlink" title="存储开销"></a>存储开销</h3><ul>
<li><strong>Docker</strong>：采用分层存储的机制，多个容器可以共享基础镜像层，只有在对镜像进行修改时，才会创建新的层。这种机制大大减少了存储占用，多个相关容器可以高效地复用底层文件系统，节省存储空间。</li>
<li><strong>虚拟机</strong>：每个虚拟机都需要有独立的虚拟磁盘文件来存储操作系统和数据，即使多个虚拟机运行相同的操作系统，也无法像 Docker 那样共享底层存储资源，会造成较大的存储开销 。</li>
</ul>
<h3 id="性能损耗"><a href="#性能损耗" class="headerlink" title="性能损耗"></a>性能损耗</h3><ul>
<li><strong>Docker</strong>：容器直接运行在宿主机内核上，与宿主机之间的交互几乎没有额外的性能损耗，应用程序的性能表现接近直接运行在宿主机上。</li>
<li><strong>虚拟机</strong>：虚拟机通过 Hypervisor（虚拟机监视器）模拟硬件环境，客户机操作系统与硬件之间增加了一层软件抽象。在进行 CPU、内存、I&#x2F;O 等操作时，都需要经过 Hypervisor 的处理和调度，这会带来一定的性能损耗</li>
</ul>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 架构是基于客户端-服务器模式的，其中包括多个关键组件，确保容器化应用的高效构建、管理和运行。</p>
<p>Docker 的架构设计使得开发者能够轻松地将应用程序与其所有依赖封装在一个可移植的容器中，并在不同的环境中一致地运行。</p>
<p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th align="left">Docker</th>
<th align="left">面向对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器</td>
<td align="left">对象</td>
</tr>
<tr>
<td align="left">镜像</td>
<td align="left">类</td>
</tr>
</tbody></table>
<p>Docker 架构示意图（入门版）</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250902175954241.png" alt="image-20250902175954241"></p>
<p>Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p>
<p><img src="/hexo-docs/images/dockerImages/image-20250903112653978.png" alt="image-20250903112653978"></p>
<p>docker 架构图（架构版）</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250903112832763.png" alt="image-20250903112832763"></p>
<h3 id="Docker-架构的工作流程"><a href="#Docker-架构的工作流程" class="headerlink" title="Docker 架构的工作流程"></a>Docker 架构的工作流程</h3><ul>
<li><strong>构建镜像</strong>：使用 <code>Dockerfile</code> 创建镜像。</li>
<li><strong>推送镜像到注册表</strong>：将镜像上传到 Docker Hub 或私有注册表中。</li>
<li><strong>拉取镜像</strong>：通过 <code>docker pull</code> 从注册表中拉取镜像。</li>
<li><strong>运行容器</strong>：使用镜像创建并启动容器。</li>
<li><strong>管理容器</strong>：使用 Docker 客户端命令管理正在运行的容器（例如查看日志、停止容器、查看资源使用情况等）。</li>
<li><strong>网络与存储</strong>：容器之间通过 Docker 网络连接，数据通过 Docker 卷或绑定挂载进行持久化。</li>
</ul>
<p>接下来让我们深入探讨 Docker 的核心组件及其工作机制。</p>
<h3 id="1、Docker-客户端（Docker-Client）"><a href="#1、Docker-客户端（Docker-Client）" class="headerlink" title="1、Docker 客户端（Docker Client）"></a>1、<strong>Docker 客户端（Docker Client）</strong></h3><p>Docker 客户端是用户与 Docker 守护进程交互的命令行界面（CLI）。它是用户与 Docker 系统的主要交互方式，用户通过 Docker CLI 发出命令，这些命令被发送到 Docker 守护进程，由守护进程执行相应的操作。</p>
<ul>
<li><strong>功能</strong>：允许用户使用命令与 Docker 守护进程通信，如创建容器、构建镜像、查看容器状态等。</li>
<li><strong>交互方式</strong>：Docker 客户端与 Docker 守护进程之间通过 REST API 或 Unix 套接字通信。常用的命令行工具是 <code>docker</code>，通过它，用户可以发出各种 Docker 操作命令。</li>
</ul>
<h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><ul>
<li><code>docker run</code>：运行容器。</li>
<li><code>docker ps</code>：列出正在运行的容器。</li>
<li><code>docker build</code>：构建 Docker 镜像。</li>
<li><code>docker exec</code>：在容器中执行命令。</li>
</ul>
<h3 id="2、Docker-守护进程（Docker-Daemon）"><a href="#2、Docker-守护进程（Docker-Daemon）" class="headerlink" title="2、Docker 守护进程（Docker Daemon）"></a>2、<strong>Docker 守护进程（Docker Daemon）</strong></h3><p>Docker 守护进程（通常是 <code>dockerd</code>）是 Docker 架构的核心，负责管理容器生命周期、构建镜像、分发镜像等任务。</p>
<p>守护进程通常以后台进程的方式运行，等待来自 Docker 客户端的 API 请求。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>启动和停止容器。</li>
<li>构建、拉取和推送镜像。</li>
<li>管理容器的网络和存储。</li>
<li>启动、停止、查看容器日志等。</li>
<li>与 Docker 注册表进行通信，管理镜像的存储与分发。</li>
</ul>
<p>Docker 守护进程监听来自 Docker 客户端的请求，并且通过 Docker API 执行这些请求。守护进程将负责容器、镜像等 Docker 对象的管理，并根据请求的参数启动容器、删除容器、修改容器配置等。</p>
<p>启动 Docker 守护进程（通常是自动启动的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="3、Docker-引擎-API（Docker-Engine-API）"><a href="#3、Docker-引擎-API（Docker-Engine-API）" class="headerlink" title="3、Docker 引擎 API（Docker Engine API）"></a>3、<strong>Docker 引擎 API（Docker Engine API）</strong></h3><p>Docker 引擎 API 是 Docker 提供的 RESTful 接口，允许外部客户端与 Docker 守护进程进行通信。通过这个 API，用户可以执行各种操作，如启动容器、构建镜像、查看容器状态等。API 提供了 HTTP 请求的接口，支持跨平台调用。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>向 Docker 守护进程发送 HTTP 请求，实现容器、镜像的管理。</li>
<li>提供 RESTful 接口，允许通过编程与 Docker 进行交互。</li>
</ul>
<p>可以通过 <code>curl</code> 或其他 HTTP 客户端访问 Docker 引擎 API。例如，查询当前 Docker 守护进程的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/version</span><br></pre></td></tr></table></figure>

<h3 id="4、Docker-容器（Docker-Containers）"><a href="#4、Docker-容器（Docker-Containers）" class="headerlink" title="4、Docker 容器（Docker Containers）"></a>4、<strong>Docker 容器（Docker Containers）</strong></h3><p>容器是 Docker 的执行环境，它是轻量级、独立且可执行的软件包。容器是从 Docker 镜像启动的，包含了运行某个应用程序所需的一切——从操作系统库到应用程序代码。容器在运行时与其他容器和宿主机共享操作系统内核，但容器之间的文件系统和进程是隔离的。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>提供独立的运行环境，确保应用程序在不同的环境中具有一致的行为。</li>
<li>容器是临时的，通常在任务完成后被销毁。</li>
</ul>
<p>容器的生命周期是由 Docker 守护进程管理的。容器可以在任何地方运行，因为它们不依赖于底层操作系统的配置，所有的运行时依赖已经封装在镜像中。</p>
<p>启动一个容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="5、Docker-镜像（Docker-Images）"><a href="#5、Docker-镜像（Docker-Images）" class="headerlink" title="5、Docker 镜像（Docker Images）"></a>5、<strong>Docker 镜像（Docker Images）</strong></h3><p>Docker 镜像是容器的只读模板。每个镜像都包含了应用程序运行所需的操作系统、运行时、库、环境变量和应用代码等。镜像是静态的，用户可以根据镜像启动容器。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>镜像是构建容器的基础，每个容器实例化时都会使用镜像。</li>
<li>镜像是只读的，不同容器使用同一个镜像时，容器中的文件系统层是独立的。</li>
</ul>
<p>Docker 镜像可以通过 <code>docker pull</code> 从 Docker Hub 或私有注册表拉取，也可以通过 <code>docker build</code> 从 Dockerfile 构建。</p>
<p>拉取 Ubuntu 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="6-Docker-仓库（Docker-Registries）"><a href="#6-Docker-仓库（Docker-Registries）" class="headerlink" title="6. Docker 仓库（Docker Registries）"></a>6. <strong>Docker 仓库（Docker Registries）</strong></h3><p>Docker 仓库是用来存储 Docker 镜像的地方，最常用的公共仓库是 <strong>Docker Hub</strong>。用户可以从 Docker Hub 下载镜像，也可以上传自己的镜像分享给其他人。除了公共仓库，用户也可以部署自己的私有 Docker 仓库来管理企业内部的镜像。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>存储 Docker 镜像。</li>
<li>提供镜像的上传和下载功能。</li>
</ul>
<p>Docker Hub 提供了大量官方和社区维护的镜像，如 Ubuntu、Nginx、MySQL 等。</p>
<p>推送镜像到 Docker Hub：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7、Docker-Compose"><a href="#7、Docker-Compose" class="headerlink" title="7、Docker Compose"></a>7、<strong>Docker Compose</strong></h3><p>Docker Compose 是一个用于定义和运行多容器 Docker 应用的工具。通过 Compose，用户可以使用一个 <code>docker-compose.yml</code> 配置文件定义多个容器（服务），并可以通过一个命令启动这些容器。Docker Compose 主要用于开发、测试和部署多容器的应用。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>定义和运行多个容器组成的应用。</li>
<li>通过 YAML 文件来配置应用的服务、网络和卷等。</li>
</ul>
<p>创建一个简单的 <code>docker-compose.yml</code> 文件来配置一个包含 Web 服务和数据库服务的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:80&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: example</span><br></pre></td></tr></table></figure>

<p>启动 Compose 定义的所有服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<h3 id="8、Docker-Swarm"><a href="#8、Docker-Swarm" class="headerlink" title="8、Docker Swarm"></a>8、<strong>Docker Swarm</strong></h3><p>Docker Swarm 是 Docker 提供的集群管理和调度工具。它允许将多个 Docker 主机（节点）组织成一个集群，并通过 Swarm 集群管理工具来调度和管理容器。Swarm 可以实现容器的负载均衡、高可用性和自动扩展等功能。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>管理多节点 Docker 集群。</li>
<li>通过调度器管理容器的部署和扩展。</li>
</ul>
<p>初始化 Swarm 集群：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure>

<h3 id="9、Docker-网络（Docker-Networks）"><a href="#9、Docker-网络（Docker-Networks）" class="headerlink" title="9、Docker 网络（Docker Networks）"></a>9、<strong>Docker 网络（Docker Networks）</strong></h3><p>Docker 网络允许容器之间相互通信，并与外部世界进行连接。Docker 提供了多种网络模式来满足不同的需求，如 <code>bridge</code> 网络（默认）、<code>host</code> 网络和 <code>overlay</code> 网络等。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>管理容器间的网络通信。</li>
<li>支持不同的网络模式，以适应不同场景下的需求。</li>
</ul>
<p>创建一个自定义网络并将容器连接到该网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network create my_network</span><br><span class="line">docker run -d --network my_network ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="10-Docker-卷（Docker-Volumes）"><a href="#10-Docker-卷（Docker-Volumes）" class="headerlink" title="10. Docker 卷（Docker Volumes）"></a>10. <strong>Docker 卷（Docker Volumes）</strong></h3><p>Docker 卷是一种数据持久化机制，允许数据在容器之间共享，并且独立于容器的生命周期。与容器文件系统不同，卷的内容不会随着容器的销毁而丢失，适用于数据库等需要持久存储的应用。</p>
<p><strong>功能</strong>：</p>
<ul>
<li>允许容器间共享数据。</li>
<li>保证数据持久化，独立于容器的生命周期。</li>
</ul>
<p>创建并挂载卷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker volume create my_volume</span><br><span class="line">docker run -d -v my_volume:/data ubuntu</span><br></pre></td></tr></table></figure>

<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="帮助-启动类命令"><a href="#帮助-启动类命令" class="headerlink" title="帮助&amp;启动类命令"></a>帮助&amp;启动类命令</h3><p>启动docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>停止docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>重启docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>查看docker状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>开机启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>查看docker概要信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>查看docker总体帮助文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<p>查看docker命令帮助文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure>

<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p>列出本地主题上的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images </span><br><span class="line">docker images -a # 列出本地所有镜像（含历史镜像）</span><br><span class="line">docker images -q # 只显示镜像id</span><br><span class="line">docker images -qa # 列出本地所有镜像，只显示镜像id</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250903113554113.png" alt="image-20250903113554113"></p>
<p>参数说明：</p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签版本号</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<blockquote>
<p>同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest(Ubuntu，最新版本) 镜像</p>
</blockquote>
<h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br><span class="line">docker search --limit 5 镜像名 #搜索结果只显示5条</span><br></pre></td></tr></table></figure>

<p>默认去：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 上搜索的，但是我们配置了阿里云镜像，所以去阿里云上搜</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250903205958279.png" alt="image-20250903205958279"></p>
<p>docker search 的时候报这个错，先切换镜像试试，如果镜像没问题的话，可以这样写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search register.librax.org/镜像名 </span><br><span class="line">docker search register.librax.org/镜像名 --limit 5 </span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250903210155592.png" alt="image-20250903210155592"></p>
<p>或者直接搜索然后，复制想要下载的，搜索地址：<a target="_blank" rel="noopener" href="https://register.librax.org/">https://register.librax.org/</a></p>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名:TAG # 没有TAG默认就是最新版，TAG就是镜像名的版本号，例如：mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250903212603583.png" alt="image-20250903212603583"></p>
<h4 id="查看镜像-容器-数据卷所占的空间"><a href="#查看镜像-容器-数据卷所占的空间" class="headerlink" title="查看镜像&#x2F;容器&#x2F;数据卷所占的空间"></a>查看镜像&#x2F;容器&#x2F;数据卷所占的空间</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df </span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250903212758262.png" alt="image-20250903212758262"></p>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像名||镜像ID # 删除镜像</span><br><span class="line">docker rmi -f 镜像名||镜像ID # 强制删除镜像</span><br><span class="line">docker rmi -f (镜像名||镜像ID):TAG (镜像名||镜像ID):TAG # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -qa) # 删除全部镜像</span><br></pre></td></tr></table></figure>

<h4 id="谈谈docker虚悬镜像是什么"><a href="#谈谈docker虚悬镜像是什么" class="headerlink" title="谈谈docker虚悬镜像是什么"></a>谈谈docker虚悬镜像是什么</h4><p>仓库名、标签都是&lt;none&gt;的镜像，俗称虚悬镜像 dangling image</p>
<p>长什么样？</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250903213238443.png" alt="image-20250903213238443"></p>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>有镜像才能创建容器，这个根本前提（下载一个centos或ubuntu镜像演示）</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250904170742222.png" alt="image-20250904170742222"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>

<p>本次我们使用<code>ubuntu</code>演示</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250904171029668.png" alt="image-20250904171029668"></p>
<h4 id="新建-启动容器"><a href="#新建-启动容器" class="headerlink" title="新建+启动容器"></a>新建+启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] image [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS说明（常用）：</span><br><span class="line"></span><br><span class="line">    有些是一个减号，有些是两个减号</span><br><span class="line"></span><br><span class="line">    --name=&quot;容器新名字&quot;       为容器指定一个名称；</span><br><span class="line"></span><br><span class="line">    -d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</span><br><span class="line"></span><br><span class="line">    -i：以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line"></span><br><span class="line">    -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line"></span><br><span class="line">    -it 也即启动交互式容器(前台有伪终端，等待交互)；</span><br><span class="line"></span><br><span class="line">    -P: 随机端口映射，大写P</span><br><span class="line"></span><br><span class="line">    -p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250904171450698.png" alt="image-20250904171450698"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250904171732047.png" alt="image-20250904171732047"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span></span><br><span class="line"></span><br><span class="line">docker run -it centos /bin/bash </span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-i: 交互式操作。</span><br><span class="line">-t: 终端。</span><br><span class="line">centos : centos 镜像。</span><br><span class="line">/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</span><br><span class="line">要退出终端，直接输入 exit:</span><br></pre></td></tr></table></figure>

<h4 id="进入容器后退出容器"><a href="#进入容器后退出容器" class="headerlink" title="进入容器后退出容器"></a>进入容器后退出容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl+p+q # 这种不会真正的退出，后台会保留</span><br><span class="line">exit # 会kill后台进程</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250905145329152.png" alt="image-20250905145329152"></p>
<p>因为没有指定names，系统会随机分配一个names</p>
<h4 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有正在运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS说明（常用）：</span><br><span class="line">    -a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line"></span><br><span class="line">    -l :显示最近创建的容器。</span><br><span class="line"></span><br><span class="line">    -n：显示最近n个创建的容器。</span><br><span class="line"></span><br><span class="line">    -q :静默模式，只显示容器编号。</span><br></pre></td></tr></table></figure>

<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><p>两种退出方式</p>
<p><code>exit</code></p>
<ul>
<li>run进去容器，exit退出，容器停止</li>
</ul>
<p><code>ctrl+p+q</code></p>
<ul>
<li>run进去容器，<code>ctrl+p+q</code>退出，容器不停止</li>
</ul>
<h4 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器ID或容器名</span><br></pre></td></tr></table></figure>

<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker kill 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<h4 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器ID或容器名</span><br></pre></td></tr></table></figure>

<p>一次性删除多个容器实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line">docker ps -a -q | xargs docker rm # xargs 是 | 左边的参数，给到竖线右面删除</span><br></pre></td></tr></table></figure>

<h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><p>有镜像才能创建容器，这里根本前提（下载一个redis镜像演示）</p>
<h5 id="启动守护式容器（后台服务器）"><a href="#启动守护式容器（后台服务器）" class="headerlink" title="启动守护式容器（后台服务器）"></a>启动守护式容器（后台服务器）</h5><p>在大部分的场景下，我们希望docker的服务是在后台运行的，我们可以过 -d 指定容器的后台运行模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用镜像centos:latest以后台模式启动一个容器</span></span><br><span class="line"></span><br><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：然后docker ps -a 进行查看, 会发现容器已经退出</span><br><span class="line"></span><br><span class="line">很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.</span><br><span class="line"></span><br><span class="line">容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,</span><br><span class="line"></span><br><span class="line">我们配置启动服务只需要启动响应的service即可。例如service nginx start</span><br><span class="line"></span><br><span class="line">但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,</span><br><span class="line"></span><br><span class="line">这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.</span><br><span class="line"></span><br><span class="line">所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，</span><br><span class="line"></span><br><span class="line">常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~</span><br></pre></td></tr></table></figure>

<h5 id="redis前后台启动演示"><a href="#redis前后台启动演示" class="headerlink" title="redis前后台启动演示"></a>redis前后台启动演示</h5><p>前台交互式启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it redis</span><br></pre></td></tr></table></figure>

<p>后台守护式启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d redis</span><br></pre></td></tr></table></figure>

<h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器ID</span><br></pre></td></tr></table></figure>

<h5 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>

<h5 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<h5 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250905143035844.png" alt="image-20250905143035844"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905143225732.png" alt="image-20250905143225732"></p>
<h5 id="重新进入"><a href="#重新进入" class="headerlink" title="重新进入"></a>重新进入</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>

<h5 id="上述两个区别"><a href="#上述两个区别" class="headerlink" title="上述两个区别"></a>上述两个区别</h5><ul>
<li><p>attach 直接进入容器启动命令的终端，不会启动新的进程。用exit 退出，会导致容器的停止。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905144455210.png" alt="image-20250905144455210"></p>
</li>
<li><p>exec 是在容器中打开新的终端，并且可以启动新的进程。用exit退出，不会导致容器的停止。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905144910061.png" alt="image-20250905144910061"></p>
</li>
</ul>
<p>推荐使用<code>docker exec</code>命令，因为退出容器终端，不会导致容器的停止</p>
<h5 id="使用redis容器实例进入试试"><a href="#使用redis容器实例进入试试" class="headerlink" title="使用redis容器实例进入试试"></a>使用redis容器实例进入试试</h5><p>进入redis服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID bash</span><br><span class="line">docker exec -it 容器ID redis-cli</span><br></pre></td></tr></table></figure>

<p>一般使用<code>-d</code>后台启动的程序，再用exec 进入对应容器实例</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905145943303.png" alt="image-20250905145943303"></p>
<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><p>容器 -&gt; 主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250905150207592.png" alt="image-20250905150207592"></p>
<h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><p><code>export</code>导出容器的内容留作为一个tar归档文件[对应import命令]</p>
<p><code>import</code>从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</p>
<p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker export 容器ID&gt;文件名.tar</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250905150637041.png" alt="image-20250905150637041"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat 文件名.tar | docker import -镜像用户/镜像名:镜像版本号</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250905151402163.png" alt="image-20250905151402163"></p>
<h4 id="总结（常用命令）"><a href="#总结（常用命令）" class="headerlink" title="总结（常用命令）"></a>总结（常用命令）</h4><p><img src="/hexo-docs/images/dockerImages/image-20250905151656459.png" alt="image-20250905151656459"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit    Create a new image from a container changes   # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history   Show the history of an image                  # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images    List images                                   # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line"></span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi       Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line"></span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line"></span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>

<h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul>
<li><p>是什么</p>
<p><strong>镜像</strong>：是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p>
<p>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p>
</li>
<li><p>分层的镜像</p>
<p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905155505396.png" alt="image-20250905155505396"></p>
</li>
<li><p>UnionFS(l联合文件系统)</p>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<font color="red">对文件系统的修改作为一次提交来一层层的叠加</font>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<font color="styblue">镜像可以通过分层来进行继承</font>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905155558486.png" alt="image-20250905155558486"></p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
</li>
<li><p>Docker 镜像加载原理</p>
<p> Docker镜像加载原理：docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel（linux 内核）, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905155829366.png" alt="image-20250905155829366"></p>
<p> 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</p>
<p>​	对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
</li>
<li><p>为什么 docker 镜像要采用这种分层结构呢？</p>
<p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p>
<p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host（docker宿主机） 只需在磁盘上保存一份 base 镜像；</p>
<p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
</li>
</ul>
<h4 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h4><p><font color="red">Docker 镜像层都是只读的，容器层是可写的。</font>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”。“ 容器层 ”之下的都叫“镜像层”。</p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905160308780.png" alt="image-20250905160308780"></p>
<h4 id="Docker-镜像-commit-操作案例"><a href="#Docker-镜像-commit-操作案例" class="headerlink" title="Docker 镜像 commit 操作案例"></a>Docker 镜像 commit 操作案例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器副本使之后成为一个新的镜像</span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p>案例演示Ubuntu安装vim</p>
<ul>
<li><p>从Hub上下在Ubuntu镜像到本地并成功运行</p>
</li>
<li><p>原始的默认Ubuntu镜像是不带vim命令的</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905160701918.png" alt="image-20250905160701918"></p>
</li>
<li><p>外网连通的情况下，安装vim</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先更新我们的包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后安装我们需要的vim</span></span><br><span class="line">apt-get -y install vim</span><br></pre></td></tr></table></figure>

<p>当<code>apt-get update</code>命令是报<code>Some index files failed to download. They have been ignored, or old ones used instead.</code>改变容器网络模式解决</p>
<p>例如</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905170204615.png" alt="image-20250905170204615"></p>
</li>
<li><p>安装完成后，commit我们自己的新镜像</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905170525105.png" alt="image-20250905170525105"></p>
</li>
<li><p>启动我们的新镜像并和原来的对比</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Docker中的镜像分层，<font color="red">支持通过扩展现有镜像，创建新的镜像</font>。类似Java继承于一个Base基础类，自己再按需扩展。</p>
<p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905160953280.png" alt="image-20250905160953280"></p>
<h3 id="本地镜像发布到阿里云"><a href="#本地镜像发布到阿里云" class="headerlink" title="本地镜像发布到阿里云"></a>本地镜像发布到阿里云</h3><p>流程</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163306229.png" alt="image-20250906163306229"></p>
<p>将本地镜像推送到阿里云，网址：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances">https://cr.console.aliyun.com/cn-hangzhou/instances</a></p>
<ol>
<li><p>创建仓库镜像</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163438927.png" alt="image-20250906163438927"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163516663.png" alt="image-20250906163516663"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163607172.png" alt="image-20250906163607172"></p>
</li>
<li><p>创建命名空间</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163639146.png" alt="image-20250906163639146"></p>
</li>
<li><p>创建镜像仓库</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163718339.png" alt="image-20250906163718339"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163744101.png" alt="image-20250906163744101"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163814306.png" alt="image-20250906163814306"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163842327.png" alt="image-20250906163842327"></p>
</li>
<li><p>推送到阿里云仓库</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906164329275.png" alt="image-20250906164329275"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906164359539.png" alt="image-20250906164359539"></p>
</li>
</ol>
<h3 id="将阿里云的镜像下载到本地"><a href="#将阿里云的镜像下载到本地" class="headerlink" title="将阿里云的镜像下载到本地"></a>将阿里云的镜像下载到本地</h3><p><img src="/hexo-docs/images/dockerImages/image-20250906164510710.png" alt="image-20250906164510710"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906165022590.png" alt="image-20250906165022590"></p>
<p>镜像拉取成功！</p>
<h3 id="将本地发布到私有库-下载发布的私有库"><a href="#将本地发布到私有库-下载发布的私有库" class="headerlink" title="将本地发布到私有库&amp;下载发布的私有库"></a>将本地发布到私有库&amp;下载发布的私有库</h3><p>流程</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906163306229.png" alt="image-20250906163306229"></p>
<p>是什么?</p>
<ol>
<li>官方Docker Hub地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E8%AE%BF%E9%97%AE%E5%A4%AA%E6%85%A2%E4%BA%86%E4%B8%94%E5%87%86%E5%A4%87%E8%A2%AB%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%96%E4%BB%A3%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%8C%E4%B8%8D%E5%A4%AA%E4%B8%BB%E6%B5%81%E3%80%82">https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</a></li>
<li>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜</li>
</ol>
<p>Docker Registry是官方提供的工具，可以用于构建私有镜像仓库</p>
<h4 id="将本地镜像发布到私有库"><a href="#将本地镜像发布到私有库" class="headerlink" title="将本地镜像发布到私有库"></a>将本地镜像发布到私有库</h4><ol>
<li><p>下载镜像<code>Docker Registry</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906171507391.png" alt="image-20250906171507391"></p>
</li>
<li><p>运行私有库Registry，相当于本地有个私有Docker Hub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /lazy/myregistry/:/tmp/registry --privileged=true registry</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不写 /lazy/myregistry/:/tmp/registry 默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906171942962.png" alt="image-20250906171942962"></p>
</li>
<li><p>案例演示创建一个新镜像，Ubuntu安装ifconfig命令</p>
<ol>
<li><p>从Docker Hub 上下载Ubuntu镜像到本地并成功运行</p>
</li>
<li><p>原始的Ubuntu镜像是不带ifconfig命令的</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906172157447.png" alt="image-20250906172157447"></p>
</li>
<li><p>外网连通的情况下，安装ifconfig命令并测试通过</p>
<p>docker 容器内执行下述这两条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update # 更新包管理器</span><br><span class="line">apt-get install net-tools # 安装网络工具</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906172444669.png" alt="image-20250906172444669"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906172457152.png" alt="image-20250906172457152"></p>
</li>
<li><p>安装完成之后，commit我们自己的新镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令：在容器外执行，记得</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906172829160.png" alt="image-20250906172829160"></p>
</li>
<li><p>启动我们新的镜像并和原来的镜像对比</p>
<ol>
<li>官网是默认下载的Ubuntu没有ifconfig命令、</li>
<li>我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。</li>
</ol>
<p>没有安装ifconfig</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906173158672.png" alt="image-20250906173158672"></p>
<p>安装ifconfig</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906173143791.png" alt="image-20250906173143791"></p>
</li>
</ol>
</li>
<li><p>curl（发送get请求）验证私服库上有什么镜像</p>
<p>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET http://registry的ip地址:5000（刚才启动registry映射的端口号）/v2/_catalog</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906173701418.png" alt="image-20250906173701418"></p>
</li>
<li><p>将新的镜像<code>myubuntu:1.2</code>修改符合私服规范的tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag myubuntu:版本号 ip地址:刚才启动registry映射的端口号/myubuntu:1.2</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906173950758.png" alt="image-20250906173950758"></p>
</li>
<li><p>修改配置文件使之支持http</p>
<p>vim命令新增如下内容：<code>vim /etc/docker/daemon.json</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;insecure-registries&quot;: [&quot;registry的ip地址:5000&quot;]</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906174241723.png" alt="image-20250906174241723"></p>
<p>添加完成之后重启docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>docker重启后，需要重新运行<code>registry</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /lazy/myregistry/:/tmp/registry --privileged=true registry</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不写 /lazy/myregistry/:/tmp/registry 默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>push推送到私服库，并使用curl验证私服库上是否有刚刚推送的镜像</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906175222163.png" alt="image-20250906175222163"></p>
</li>
</ol>
<h4 id="将私服库pull到本地运行"><a href="#将私服库pull到本地运行" class="headerlink" title="将私服库pull到本地运行"></a>将私服库pull到本地运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull ip地址:刚才启动registry映射的端口号/myubuntu:1.2</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250906175520314.png" alt="image-20250906175520314"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250906175550026.png" alt="image-20250906175550026"></p>
<p>成功将私服库pull到本地，并运行</p>
<h3 id="Docker-容器数据卷"><a href="#Docker-容器数据卷" class="headerlink" title="Docker 容器数据卷"></a>Docker 容器数据卷</h3><p>容器卷记得加入<code>--privileged=true</code></p>
<p>为什么？</p>
<ul>
<li>因为Docker挂载主机目录访问如果出现cannot open directory .: Permission denied（没有权限）</li>
</ul>
<p>解决办法</p>
<ul>
<li>解决办法：在挂载目录后多加一个<code>--privileged=true</code>参数即可</li>
</ul>
<p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p>
<h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p>卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p>
<p>一句话就是有点类似于我们Redis里面的rdb和aof文件</p>
<p>docker容器内的数据可以保存进宿主机的硬盘中，实现宿主机和我们的docker容器目录共享</p>
<p>运行一个带有容器卷存储功能的容器实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名 	# 如果宿主机或容器内目录没有写的那个目录，会自动创建一个目录</span><br></pre></td></tr></table></figure>

<h4 id="能干嘛？"><a href="#能干嘛？" class="headerlink" title="能干嘛？"></a>能干嘛？</h4><p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的</p>
<p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</p>
<p>为了能保存数据在docker中我们使用卷。</p>
<p>特点：</p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接实时生效，宿主机和容器可以实现共享目录</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<h4 id="数据卷案例"><a href="#数据卷案例" class="headerlink" title="数据卷案例"></a>数据卷案例</h4><h5 id="1-宿主机vs容器之间映射添加容器卷"><a href="#1-宿主机vs容器之间映射添加容器卷" class="headerlink" title="1.宿主机vs容器之间映射添加容器卷"></a>1.宿主机vs容器之间映射添加容器卷</h5><p>直接命令添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名 /bin/bash或bash # privileged=true 容器数据卷的权限开启</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250907154254209.png" alt="image-20250907154254209"></p>
<p>查看数据卷是否挂在成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250907154313167.png" alt="image-20250907154313167"></p>
<p>容器和宿主机之间数据共享</p>
<ol>
<li><p>容器创建文件，宿主机同步</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907154520596.png" alt="image-20250907154520596"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907154548824.png" alt="image-20250907154548824"></p>
</li>
<li><p>宿主机修改文件，容器同步</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907154818643.png" alt="image-20250907154818643"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907154856258.png" alt="image-20250907154856258"></p>
</li>
<li><p>如果容器被stop掉了，宿主机修改，容器重启看数据是否同步。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907155052660.png" alt="image-20250907155052660"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907155224716.png" alt="image-20250907155224716"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907155457367.png" alt="image-20250907155457367"></p>
</li>
</ol>
<h5 id="2-读写规则映射添加说明"><a href="#2-读写规则映射添加说明" class="headerlink" title="2.读写规则映射添加说明"></a>2.读写规则映射添加说明</h5><p>读写（默认）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在容器启动的时候，添加读写（默认）</span></span><br><span class="line">docker run -it --privilege=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名 bash</span><br></pre></td></tr></table></figure>

<p>默认就是rw，<code>rw=read+write</code>（读写）</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907160559088.png" alt="image-20250907160559088"></p>
<p>只读(ro&#x3D;read only)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privilege=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 bash</span><br></pre></td></tr></table></figure>



<p>容器内部被限制，只能读取不能写</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907161438086.png" alt="image-20250907161438086"></p>
<p>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p>
<h5 id="3-卷的继承和共享"><a href="#3-卷的继承和共享" class="headerlink" title="3.卷的继承和共享"></a>3.卷的继承和共享</h5><p>容器1完成和宿主机的映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=true -v /tmp/ubuntuData:/tmp/ubuntu --name u1 ubuntu bash</span><br></pre></td></tr></table></figure>

<p>容器2继承容器1的卷规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=true --volumes-from 父类容器id或父类名字 --name u2 ubuntu bash</span><br></pre></td></tr></table></figure>

<p>u1</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163547987.png" alt="image-20250907163547987"></p>
<p>u2继承了u1</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163623047.png" alt="image-20250907163623047"></p>
<p>我在u1创建个文件，看看u2是否有</p>
<p>u1</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163721934.png" alt="image-20250907163721934"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163740886.png" alt="image-20250907163740886"></p>
<p>我在u2创建个文件，看看u1是否有</p>
<p>u2</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163840476.png" alt="image-20250907163840476"></p>
<p>u1</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163907035.png" alt="image-20250907163907035"></p>
<p>看看主机是否有，u1和u2创建的文件</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907163953898.png" alt="image-20250907163953898"></p>
<p>在主机上创建个文件，看看u1和u2是否都有</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907164125207.png" alt="image-20250907164125207"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907164153136.png" alt="image-20250907164153136"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250907164234577.png" alt="image-20250907164234577"></p>
<blockquote>
<p>如果一个子类（u2）集成了一个父类（u1），u1被stop掉了，u2创建个文件。等到u1 start会同步u2的数据！</p>
</blockquote>
<h3 id="Docker-常规安装简介"><a href="#Docker-常规安装简介" class="headerlink" title="Docker 常规安装简介"></a>Docker 常规安装简介</h3><p>总体步骤：</p>
<ul>
<li>搜索镜像</li>
<li>拉取镜像</li>
<li>查看镜像</li>
<li>启动镜像</li>
<li>停止容器</li>
<li>移除容器</li>
</ul>
<h4 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h4><blockquote>
<p>必须要有jdk环境，后面有个没有jdk环境的，自行下载！</p>
</blockquote>
<p>下载镜像</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908144539956.png" alt="image-20250908144539956"></p>
<p><code>docker images</code> 查看是否有拉取到的tomcat</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908145115363.png" alt="image-20250908145115363"></p>
<p>使用tomcat镜像创建容器实例（也叫运行镜像）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat:10.1.44</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 小写，主机端口:docker 容器端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-P 大写，随机分配端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i:交互</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">t:终端</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">d:后台</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908145502765.png" alt="image-20250908145502765"></p>
<p>访问tomcat首页</p>
<ul>
<li><p>问题</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908145543298.png" alt="image-20250908145543298"></p>
</li>
<li><p>解决</p>
<ol>
<li><p>可能没有映射端口或者没有关闭防火墙</p>
</li>
<li><p>把webapps.dist目录换成webapps</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908150145962.png" alt="image-20250908150145962"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908150926402.png" alt="image-20250908150926402"></p>
<p>刷新一下</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908150951514.png" alt="image-20250908150951514"></p>
</li>
</ol>
</li>
</ul>
<p>免修改版说明</p>
<ul>
<li><p>如果不想下载jdk就想使用tomcat，就使用这个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name t1 billygoo/tomcat8-jdk8 </span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908151539815.png" alt="image-20250908151539815"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908151551581.png" alt="image-20250908151551581"></p>
</li>
</ul>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><h5 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h5><p>下载mysql:8.0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8.0</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908154427233.png" alt="image-20250908154427233"></p>
<p>启动mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0</span><br></pre></td></tr></table></figure>

<p>先看看端口号是否被占用</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908154732214.png" alt="image-20250908154732214"></p>
<p>进入mysql</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908154849038.png" alt="image-20250908154849038"></p>
<p>建库建表，并且插入数据</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908155031476.png" alt="image-20250908155031476"></p>
<p>在外部window10连接运行docker上的mysql容器实例服务</p>
<blockquote>
<p>记得关闭防火墙，否则连不上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld # 永久关闭防火墙</span><br><span class="line">systemctl stop firewalld  # 关闭临时防火墙</span><br></pre></td></tr></table></figure>


</blockquote>
<p><img src="/hexo-docs/images/dockerImages/image-20250908160230091.png" alt="image-20250908160230091"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908160253972.png" alt="image-20250908160253972"></p>
<p>问题</p>
<ul>
<li><p>插入中文试试</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908160509868.png" alt="image-20250908160509868"></p>
<p>去看看容器实例有没有</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908160534009.png" alt="image-20250908160534009"></p>
<p>容器实例显示乱码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;character%&#x27;; #看看容器编码格式</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908160636437.png" alt="image-20250908160636437"></p>
<p>使用的是latin1文</p>
</li>
<li><p>删除容器后，里面的mysql数据怎么办？</p>
</li>
</ul>
<h5 id="实战版"><a href="#实战版" class="headerlink" title="实战版"></a>实战版</h5><p>使用容器卷保存数据</p>
<p>新建mysql容器实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=true \</span><br><span class="line">-v /tmp/mysql/log:/var/log/mysql \</span><br><span class="line">-v /tmp/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /tmp/mysql/conf:/etc/mysql/conf.d \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql mysql:8.0</span><br></pre></td></tr></table></figure>

<p>新建my.cnf文件</p>
<ul>
<li><p>通过容器卷同步给mysql容器实例</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">default_character_set</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">collation_server</span> = <span class="string">utf8_general_ci</span></span><br><span class="line"><span class="attr">character_set_server</span> = <span class="string">utf8</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908161414376.png" alt="image-20250908161414376"></p>
<blockquote>
<p>这个my.cnf文件的目录要和，启动mysql配置的配置文件目录要一致！</p>
</blockquote>
</li>
</ul>
<p>重新启动mysql容器实例再重新进入并查看字符编码</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908161602323.png" alt="image-20250908161602323"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908161706244.png" alt="image-20250908161706244"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908161837817.png" alt="image-20250908161837817"></p>
<p>可以看到刚才创建的库已经没了！</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908161950647.png" alt="image-20250908161950647"></p>
<p>已经不乱码了！</p>
<p>问题：</p>
<ul>
<li><p>如果将当前的实例删除后还会有数据吗？</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908162402951.png" alt="image-20250908162402951"></p>
<blockquote>
<p>会，因为，创建的数据会同步到linux本地中，如果启动的时候不使用容器卷会导致数据丢失！建议使用mysql的时候，加上容器卷。防止数据丢失！</p>
</blockquote>
</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>mysql5.7和8.0版本运行的时候不一样</p>
<p>5.7版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=true \</span><br><span class="line">-v /tmp/mysql/log:/var/log/mysql \</span><br><span class="line">-v /tmp/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /tmp/mysql/conf:/etc/mysql \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql mysql:8.0</span><br></pre></td></tr></table></figure>

<p>8.0版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=true \</span><br><span class="line">-v /tmp/mysql/log:/var/log/mysql \</span><br><span class="line">-v /tmp/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /tmp/mysql/conf:/etc/mysql/conf.d \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql mysql:8.0</span><br></pre></td></tr></table></figure>

<p>这就是为什么运行docker ps命令的时候不显示mysql了！</p>
<h4 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h4><p>  安装redis命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis:7.0</span><br></pre></td></tr></table></figure>

<p>为了，防止我们的redis数据丢失，或者不加载默认的配置文件，我们要用容器卷启动redis</p>
<p>在<code>/app/docker_data</code>新建redis文件夹</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250908165233707.png" alt="image-20250908165233707"></p>
<p>将redis.conf文件拷贝或写入到里面</p>
<p>默认的redis.conf：<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/operate/oss_and_stack/management/config">https://redis.io/docs/latest/operate/oss_and_stack/management/config</a> 对应版本号自行下载</p>
<p>修改redis.conf 文件</p>
<ol>
<li><p>开启redis验证密码 可选</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">requirepass 密码</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许redis外地连接 必须（要不然你的idea无法连接你的redis）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">注释掉 # bind 127.0.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>daemonize no</p>
</li>
</ol>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">将daemonize yes 注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>开启redis数据持久化 appendonly yes 可选</p>
</li>
<li><p>开启数据持久化，可选</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">开启redis数据持久化  appendonly yes  可选</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭保护模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protected-mode  yes 改为  protected-mode  no </span><br></pre></td></tr></table></figure>
</li>
<li><p>测试：修改redis.conf 库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">databases 10 # 设置默认库为10个，一会测试使用</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908170446883.png" alt="image-20250908170446883"></p>
</li>
</ol>
<h5 id="运行redis容器实例"><a href="#运行redis容器实例" class="headerlink" title="运行redis容器实例"></a>运行redis容器实例</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis --privileged=true \</span><br><span class="line">-v /app/docker_data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /app/docker_data/redis/data:/data \</span><br><span class="line">-d redis:7.0 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250908173749395.png" alt="image-20250908173749395"></p>
<h3 id="Docker复杂安装详说"><a href="#Docker复杂安装详说" class="headerlink" title="Docker复杂安装详说"></a>Docker复杂安装详说</h3><h4 id="安装mysql主从复制"><a href="#安装mysql主从复制" class="headerlink" title="安装mysql主从复制"></a>安装mysql主从复制</h4><p>主从复制原理</p>
<p><strong>主从复制</strong>是MySQL数据库中的一种机制，它允许从一个数据库服务器（主服务器）复制数据到一个或多个数据库服务器（从服务器）。这种机制的核心在于保持数据的一致性和可用性，同时提供负载均衡和数据备份的功能。</p>
<p>主从复制的工作流程</p>
<p>主从复制的工作流程涉及三个关键的线程：</p>
<ol>
<li><strong>主服务器上的二进制日志线程（Binary Log Thread）</strong>：当从服务器连接到主服务器时，主服务器会创建一个二进制日志线程，用于发送二进制日志的内容。这些日志记录了主服务器上发生的所有更改。</li>
<li><strong>从服务器上的I&#x2F;O线程</strong>：从服务器上的I&#x2F;O线程负责与主服务器建立连接，并请求主服务器上更新的二进制日志。接收到的日志会被保存在从服务器本地的中继日志（Relay Log）中。</li>
<li><strong>从服务器上的SQL线程</strong>：SQL线程负责读取中继日志中的内容，并将其解析成具体的操作在从服务器上执行，以此来保证主从服务器数据的一致性。</li>
</ol>
<p>主从复制的同步方式</p>
<p>主从复制有三种同步方式：</p>
<ol>
<li><strong>异步复制</strong>：这是MySQL的默认复制方式，其中主服务器在写入二进制日志后即可返回成功，无需等待日志传递给从服务器。这种方式效率最高，但可能会导致数据不一致。</li>
<li><strong>同步复制</strong>：在这种模式下，主服务器在将事件发送给从服务器并得到所有从服务器的确认后，才会向客户端返回成功。这是最安全的复制方式，但效率最低。</li>
<li><strong>半同步复制</strong>：半同步复制是介于异步和同步之间的一种方式，主服务器在至少一个从服务器确认接收到数据后才会继续操作。这种方式提高了数据一致性，但仍可能存在延迟。</li>
</ol>
<p>搭建步骤</p>
<ol>
<li><p>新建主服务器容器实例 3307</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /app/docker_data/mysql_master/log:/var/log/mysql \</span><br><span class="line">-v /app/docker_data/mysql_master/data:/var/lib/mysql \</span><br><span class="line">-v /app/docker_data/mysql_master/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>/app/docker_data/mysql_master/conf</code>目录，创建my.cnf文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">## 设置server_id，同一局域网中需要唯一</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="string">101 </span></span><br><span class="line"><span class="comment">## 指定不需要同步的数据库名称</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">mysql  </span></span><br><span class="line"><span class="comment">## 开启二进制日志功能</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">mall-mysql-bin  </span></span><br><span class="line"><span class="comment">## 设置二进制日志使用内存大小（事务）</span></span><br><span class="line"><span class="attr">binlog_cache_size</span>=<span class="string">1M  </span></span><br><span class="line"><span class="comment">## 设置使用的二进制日志格式（mixed,statement,row）</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">mixed  </span></span><br><span class="line"><span class="comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span><br><span class="line"><span class="attr">expire_logs_days</span>=<span class="string">7  </span></span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line"><span class="attr">slave_skip_errors</span>=<span class="string">1062</span></span><br><span class="line"><span class="attr">collation_server</span> = <span class="string">utf8_general_ci</span></span><br><span class="line"><span class="attr">character_set_server</span> = <span class="string">utf8</span></span><br><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">default_character_set</span>=<span class="string">utf8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改完配置后重启master实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入mysql-master容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-master bash</span><br><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>master 容器实例内创建数据同步用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER&#x27;slave&#x27;@&#x27;%&#x27;IDENTIFIED BY&#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE,REPLICATION CLIENT ON*.*TO&#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250909132534039.png" alt="image-20250909132534039"></p>
</li>
<li><p>新建从服务器容器实例 3308</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /app/docker_data/mysql_slave/log:/var/log/mysql \</span><br><span class="line">-v /app/docker_data/mysql_slave/data:/var/lib/mysql \</span><br><span class="line">-v /app/docker_data/mysql_slave/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>/app/docker_data/mysql_slave/conf</code>目录下新建my.cnf</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">## 设置server_id，同一局域网中需要唯一</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="string">102</span></span><br><span class="line"><span class="comment">## 指定不需要同步的数据库名称</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">mysql  </span></span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">mall-mysql-slave1-bin  </span></span><br><span class="line"><span class="comment">## 设置二进制日志使用内存大小（事务）</span></span><br><span class="line"><span class="attr">binlog_cache_size</span>=<span class="string">1M  </span></span><br><span class="line"><span class="comment">## 设置使用的二进制日志格式（mixed,statement,row）</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">mixed  </span></span><br><span class="line"><span class="comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span><br><span class="line"><span class="attr">expire_logs_days</span>=<span class="string">7  </span></span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line"><span class="attr">slave_skip_errors</span>=<span class="string">1062  </span></span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line"><span class="attr">relay_log</span>=<span class="string">mall-mysql-relay-bin  </span></span><br><span class="line"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class="line"><span class="attr">log_slave_updates</span>=<span class="string">1  </span></span><br><span class="line"><span class="comment">## slave设置为只读（具有super权限的用户除外）</span></span><br><span class="line"><span class="attr">read_only</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">collation_server</span> = <span class="string">utf8_general_ci</span></span><br><span class="line"><span class="attr">character_set_server</span> = <span class="string">utf8</span></span><br><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">default_character_set</span>=<span class="string">utf8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成之后重启slave实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主数据库中查看主从同步状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250909133237452.png" alt="image-20250909133237452"></p>
</li>
<li><p>进入mysql-slave容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-slave bash</span><br><span class="line">mysql -u root -p123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从数据库中配置主从复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;宿主机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">options 参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_host：主数据库的IP地址；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_port：主数据库的运行端口；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_user：在主数据库创建的用于同步数据的用户账号；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_password：在主数据库创建的用于同步数据的用户密码；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master_connect_retry：连接失败重试的时间间隔，单位为秒。</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250909133555264.png" alt="image-20250909133555264"></p>
</li>
<li><p>在从数据中查看主从同步状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G; </span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250909133642315.png" alt="image-20250909133642315"></p>
<p>代表没有开启主从同步</p>
</li>
<li><p>在从数据库中开启主从同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250909133849748.png" alt="image-20250909133849748"></p>
</li>
<li><p>查看从数据库状态发现已经同步</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250909170748248.png" alt="image-20250909170748248"></p>
</li>
<li><p>主从复制测试</p>
<p>master</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250909135048125.png" alt="image-20250909135048125"></p>
<p>slave</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250909183526245.png" alt="image-20250909183526245"></p>
</li>
</ol>
<p>​    </p>
<h4 id="安装redis集群"><a href="#安装redis集群" class="headerlink" title="安装redis集群"></a>安装redis集群</h4><p>1~2亿条数据需要缓存，如何设计这个存储案例</p>
<ul>
<li>单机100%不可能，肯定是分布式redis，用redis如何落地？</li>
</ul>
<p>三种解决方案</p>
<h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p><img src="/hexo-docs/images/dockerImages/image-20250910192230682.png" alt="image-20250910192230682"></p>
<p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p>
<p>优点：</p>
<p> 简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>
<p>缺点：</p>
<p>  原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p>
<p>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p>
<h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p>是什么</p>
<ul>
<li><p>一致性Hash算法背景</p>
<p>一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决<strong>分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了。</strong></p>
</li>
</ul>
<p>能干嘛</p>
<ul>
<li>提出一致性hash解决方案。目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。</li>
</ul>
<p>3大步骤</p>
<p>算法构建一致性哈希环</p>
<ul>
<li><p>一致性哈希环</p>
<p>​	一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。</p>
<p>​	它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910193824616.png" alt="image-20250910193824616"></p>
</li>
<li><p>服务器IP节点映射</p>
<p>节点映射</p>
<p>  将集群中各个IP节点映射到环上的某一个位置。</p>
<p>  将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下： </p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910193900266.png" alt="image-20250910193900266"></p>
</li>
<li><p>key落到服务器端的落键规则</p>
<p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>
<p>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910193939524.png" alt="image-20250910193939524"></p>
</li>
</ul>
<p>优点</p>
<ul>
<li><p>一致性哈希算法的容错性</p>
<p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910194028681.png" alt="image-20250910194028681"></p>
</li>
<li><p>一致性哈希算法的拓展性</p>
<p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</p>
<p>不会导致hash取余全部数据重新洗牌。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910194057750.png" alt="image-20250910194057750"></p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>一致性哈希算法的数据倾斜问题</p>
<p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p>
<p>例如系统中只有两台服务器：</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910194141149.png" alt="image-20250910194141149"></p>
</li>
</ul>
<p>小总结</p>
<p>为了在节点数目发生改变时尽可能少的迁移数据 </p>
<p>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。</p>
<p>而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。 </p>
<p>优点</p>
<p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>
<p>缺点 </p>
<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>
<blockquote>
<p>为什么一致性哈希算法是0~2的32次方-1</p>
<ul>
<li>IPv4是有4组8位二进制数组成，所有用2的32次方可以保证每个IP地址会有唯一的映射。</li>
<li>IPv4的长度是2的32次方-1，所以一致性的哈希算法就是2的32次方-1，正好能够装下所有IPv4</li>
</ul>
</blockquote>
<h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p>为什么出现？</p>
<p>解决一致性哈希算法的<strong>数据倾斜</strong>问题</p>
<p>哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。</p>
<p>能干嘛？</p>
<p>解决均匀分配的问题，<strong>在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系</strong>，现在就相当于节点上放的是槽，槽里放的是数据。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910194319287.png" alt="image-20250910194319287"></p>
<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>
<p>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p>
<p> 多少个hash槽？</p>
<p>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
<p>哈希槽计算</p>
<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910194411935.png" alt="image-20250910194411935"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250910194420511.png" alt="image-20250910194420511"></p>
<h5 id="redis3主3从配置"><a href="#redis3主3从配置" class="headerlink" title="redis3主3从配置"></a>redis3主3从配置</h5><ol>
<li><p>关闭防火墙+启动docker后台服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建6个docker容器redis实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /app/docker_data/redis/redis-node-1:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /app/docker_data/redis/redis-node-2:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /app/docker_data/redis/redis-node-3:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /app/docker_data/redis/redis-node-4:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /app/docker_data/redis/redis-node-5:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /app/docker_data/redis/redis-node-6:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6386</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run ： 创建并运行docker容器实例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name redis-node-6 ： 容器名字</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--net host ： 使用宿主机的IP和端口，默认</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--privilege=<span class="literal">true</span> ：获取宿主机root用户权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v /app/docker_data/redis/redis-node-6:/data ： 容器卷，宿主机地址:docker内部地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis:7.0  ： redis镜像和版本号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cluster-enabled <span class="built_in">yes</span> ：开启redis集群</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--appendonly <span class="built_in">yes</span> ： 开启持久化</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--port 6386 ：redis端口号</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911175836547.png" alt="image-20250911175836547"></p>
</li>
<li><p>进入容器<code>redis-node-1</code>并为6台机器构建集群</p>
<ol>
<li><p>进入容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-node-1 bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建主从关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.0.140:6381 192.168.0.140:6382 192.168.0.140:6383 192.168.0.140:6384 192.168.0.140:6385 192.168.0.140:6386 --cluster-replicas 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cluster-replicas 1 表示为每个master创建一个slave节点</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911180418171.png" alt="image-20250911180418171"></p>
<table>
<thead>
<tr>
<th align="center">master</th>
<th align="center">slave</th>
</tr>
</thead>
<tbody><tr>
<td align="center">6381</td>
<td align="center">6384</td>
</tr>
<tr>
<td align="center">6382</td>
<td align="center">6385</td>
</tr>
<tr>
<td align="center">6383</td>
<td align="center">6386</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>链接进入6381作为切入点，<strong>查看集群状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster info</span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911180924762.png" alt="image-20250911180924762"></p>
</li>
</ol>
<h5 id="主从容错切换案例"><a href="#主从容错切换案例" class="headerlink" title="主从容错切换案例"></a>主从容错切换案例</h5><p>数据读写存储</p>
<ul>
<li><p>进入到redis，以6381为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6381 -c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 端口号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c 集群方式</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911181225344.png" alt="image-20250911181225344"></p>
</li>
<li><p>查看集群信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.0.140:6381</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911181404707.png" alt="image-20250911181404707"></p>
</li>
</ul>
<h5 id="容错切换案例"><a href="#容错切换案例" class="headerlink" title="容错切换案例"></a>容错切换案例</h5><ul>
<li><p>主6381和从机切换，先停止主机6381</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911181726726.png" alt="image-20250911181726726"></p>
<blockquote>
<p>6381作为1号主机分配的从机，以实际情况为准，具体几号机器就是几号机器</p>
</blockquote>
</li>
<li><p>再把6381启动了，看看会不会6381从新上位</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911182124143.png" alt="image-20250911182124143"></p>
</li>
</ul>
<blockquote>
<p>如果停止6381了，但是还能看到6381的话，就稍等一下，因为他有发送心跳包的机制</p>
</blockquote>
<h5 id="主从扩容案例"><a href="#主从扩容案例" class="headerlink" title="主从扩容案例"></a>主从扩容案例</h5><ul>
<li><p>新建6387、6388两个节点+新建后启动+查看是否有8个节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v /app/docker_data/redis/redis-node-7:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /app/docker_data/redis/redis-node-8:/data redis:7.0 --cluster-enabled yes --appendonly yes --port 6388</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911182448335.png" alt="image-20250911182448335"></p>
</li>
<li><p>进入6387容器实例内部</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-node-7 bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>将新增的6387节点（空槽号）作为master节点加入原集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.0.140:6387 192.168.0.140:6381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6387 就是将要作为master新增节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911182757187.png" alt="image-20250911182757187"></p>
</li>
<li><p>检查集群情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.0.140:6381</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911182857955.png" alt="image-20250911182857955"></p>
</li>
<li><p>重新分配槽号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.0.140:6381</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911183609231.png" alt="image-20250911183609231"></p>
</li>
<li><p>检查集群情况第2次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.0.140:6381</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911183839008.png" alt="image-20250911183839008"></p>
</li>
<li><p>查看以前存的数据是否还存在</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911183937405.png" alt="image-20250911183937405"></p>
<p>可以看到我们的数据没丢失</p>
</li>
<li><p>为主节点6387分配从节点6388</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 192.168.0.140:6388 192.168.0.140:6387 --cluster-slave --cluster-master-id e1f9fde09b842e497ed32cba3147609172dc8652</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e1f9fde09b842e497ed32cba3147609172dc8652：这个是6387的编号，按照自己实际情况</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911184207956.png" alt="image-20250911184207956"></p>
</li>
<li><p>检查集群情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.0.140:6381</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911184315872.png" alt="image-20250911184315872"></p>
<p>可以看到我们的6388的master是6387</p>
</li>
</ul>
<p>我们的主从扩容案例已经完成了！</p>
<h5 id="主从缩容案例"><a href="#主从缩容案例" class="headerlink" title="主从缩容案例"></a>主从缩容案例</h5><p>我们的目的就是让6387、6388下载，让槽号重新回到各个master里面</p>
<ul>
<li><p>检查集群情况，获得6388的节点id</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911184535793.png" alt="image-20250911184535793"></p>
</li>
<li><p>将6388从集群中删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.0.140:6388 9f59b8554c2575e9f7a15bf44e1e12bda4414cd0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9f59b8554c2575e9f7a15bf44e1e12bda4414cd0 6388 节点<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911184712261.png" alt="image-20250911184712261"></p>
<p>可以看到我们的6388从集群中删除了</p>
</li>
<li><p>将6387的槽号情况，重新分配给6382节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.0.140:6382</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.0.140:6382: 要分配的 ip地址:端口</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250911190245140.png" alt="image-20250911190245140"></p>
<blockquote>
<p>如果要平均分配的话就要<code>redis-cli --cluster reshard</code>执行多次</p>
</blockquote>
</li>
<li><p>检查集群分配情况</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911190538153.png" alt="image-20250911190538153"></p>
</li>
<li><p>将6387删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node 192.168.0.140:6387 e1f9fde09b842e497ed32cba3147609172dc8652</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e1f9fde09b842e497ed32cba3147609172dc8652 6387 节点<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次检查集群节点分配情况</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911190722299.png" alt="image-20250911190722299"></p>
</li>
<li><p>看看刚刚写的数据是否存在</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250911190813728.png" alt="image-20250911190813728"></p>
</li>
<li><p>最后从docker下载redis-node-7和redis-node-8</p>
</li>
</ul>
<p>我们的主从缩容不会使数据丢失！</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h4><p>Docker 是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚步。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250912151709867.png" alt="image-20250912151709867"></p>
<p>例如：在一个操作系统里面，装了<code>vim</code>命令，就可以使用<code>Dockerfile</code>构建新的镜像，而且可以把新的镜像发送到远程，一起使用！</p>
<p>官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/">https://docs.docker.com/reference/dockerfile/</a></p>
<p>构建三步骤：</p>
<ol>
<li>编写<code>Dockerfile</code>文件</li>
<li>使用docker build命令构建镜像</li>
<li>docker run镜像运行容器实例</li>
</ol>
<h4 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h4><ul>
<li><p>DockerFile内容基础知识</p>
<ol>
<li>每条保留字指令<strong>必须为大写字母（不是必须，因为规范）</strong>且后面要至少跟随一个参数</li>
<li>Dockerfile文件的第一条指令必须以FROM开头，这可能是在<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#parser-directives">解析器指令 </a>、<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#format"> 注释</a>和全局作用域之后 <a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/#arg">ARG 的 ARG</a> 中。<code>FROM</code> 指令指定要从中构建的<a target="_blank" rel="noopener" href="https://docs.docker.com/glossary/#base-image">基础映像 </a>。<code>FROM</code> 之前只能有一个或多个 <code>ARG</code> 指令，这些指令声明在 Dockerfile 的 <code>FROM</code> 行中使用的参数。</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>在执行 Dockerfile 指令之前，注释行将被删除</li>
<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>
</ol>
</li>
<li><p>Docker执行Dockerfile的大致流程</p>
<ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
</li>
<li><p>小总结</p>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<p>*  Dockerfile是软件的原材料</p>
<p>*  Docker镜像是软件的交付品</p>
<p>*  Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</p>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250912152957406.png" alt="image-20250912152957406"></p>
<ol>
<li><p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p>
</li>
<li><p>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</p>
</li>
<li><p>Docker容器，容器是直接提供服务的。</p>
</li>
</ol>
</li>
</ul>
<h4 id="DockerFile-常用保留字指令"><a href="#DockerFile-常用保留字指令" class="headerlink" title="DockerFile 常用保留字指令"></a>DockerFile 常用保留字指令</h4><ul>
<li><p>FROM：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模版，<strong>第一条必须是from</strong></p>
</li>
<li><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p>
</li>
<li><p>RUN：容器构建是需要运行的命令</p>
<ul>
<li><p>两种格式</p>
<ul>
<li><p>shell格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br><span class="line">RUN yum -y install vim</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RUN [<span class="string">&quot;./test.php&quot;</span>, <span class="string">&quot;dev&quot;</span>, <span class="string">&quot;offline&quot;</span>] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>RUN是在docker build（docker构建）时运行的</p>
</li>
<li><p>EXPOSE：当前容器对外暴露的端口</p>
</li>
<li><p>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</p>
</li>
<li><p>USER：指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p>
</li>
<li><p>ENV：用来在构建镜像过程中设置环境变量</p>
<p>ENV MY_PATH &#x2F;usr&#x2F;mytest</p>
<p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</p>
<p>也可以在其它指令中直接使用这些环境变量，</p>
<p>比如：WORKDIR $MY_PATH</p>
</li>
<li><p>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p>
</li>
<li><p>COPY：类型ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY src dest # src 源路径 dest 目的路径</span><br><span class="line">COPY [&quot;src&quot;,&quot;dest&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;src源路径&gt;：源文件或者源目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;dest目标路径&gt;：容器内的指定路径，该路径不用实现建好，如果路径不存在的话，会自动创建。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>VOLUME：容器数据卷，用于数据保存和持久化工作</p>
</li>
<li><p>CMD：指定容器启动后要干的事情</p>
<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
</ul>
<p>它和前面RUN命令的区别</p>
<ul>
<li>CMD 是在docker run时运行的</li>
<li>RUN  是在docker build时运行的</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li><p>Dockerfile中可以有多个CMD 指令，<font color="red">但只有最后一个生效，CMD会被docker run之后的参数替换</font></p>
</li>
<li><p>docker&#x2F;tomcat官网最后一行命令</p>
</li>
</ul>
<p> <img src="/hexo-docs/images/dockerImages/image-20250912154930839.png" alt="image-20250912154930839"></p>
<p> 我们演示自己的覆盖操作</p>
<ul>
<li><p>正常操作</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250912155145663.png" alt="image-20250912155145663"></p>
</li>
<li><p>演示的操作</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250912155257191.png" alt="image-20250912155257191"></p>
</li>
<li><p>这就是 bash 覆盖了，CMD的操作命令，本来要启动<code>catalina.sh</code> 的，结果启动成了bash！</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="自定义镜像mycentosjava8"><a href="#自定义镜像mycentosjava8" class="headerlink" title="自定义镜像mycentosjava8"></a>自定义镜像mycentosjava8</h5><p>前提：</p>
<ul>
<li><p>docker里面下载了Centos7镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos:centos7</span><br></pre></td></tr></table></figure></li>
</ul>
<p>要求：</p>
<ul>
<li>Centos7镜像具备vim+ifconfig+jdk8</li>
<li>JDK的下载地址：<a target="_blank" rel="noopener" href="https://mirrors.yangxingzhen.com/jdk/">https://mirrors.yangxingzhen.com/jdk/</a></li>
</ul>
<p>编写</p>
<ul>
<li><p>编写Dockerfile文件（D必须大写）</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lazy&lt;lazy@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum clean all &amp;&amp; yum makecache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装ifconfig命令查看网络IP</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装java8及lib库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install glibc.i686</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /usr/local/java</span></span><br><span class="line"><span class="comment">#ADD 是相对路径jar,把 jdk-8u421-linux-i586.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u221-linux-x64.tar.gz /usr/local/java/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_421</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;success--------------ok&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/hexo-docs/images/dockerImages/image-20250912160927973.png" alt="image-20250912160927973"></p>
<blockquote>
<p>Dockerfile和jdk8必须放到一个文件夹下</p>
</blockquote>
<p>构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 新镜像名字:TAG .</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250912161300756.png" alt="image-20250912161300756"></p>
<blockquote>
<p>注意，上面TAG后面有个空格，有个点，点不能省略</p>
</blockquote>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG bash</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250912164412161.png" alt="image-20250912164412161"></p>
<h4 id="文件联合系统（UnionFS）"><a href="#文件联合系统（UnionFS）" class="headerlink" title="文件联合系统（UnionFS）"></a>文件联合系统（UnionFS）</h4><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下</strong>(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250905155558486.png" alt="image-20250905155558486"></p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>是什么？</p>
<ul>
<li><p>仓库名、标签都是&lt;none&#x2F;&gt;的镜像，俗称dangling image（虚悬镜像）</p>
</li>
<li><p>使用Dockerfile写一个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from ubuntu</span><br><span class="line">CMD echo &#x27;action is success&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250912165012867.png" alt="image-20250912165012867"></p>
</li>
</ul>
<p>查看虚悬镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images ls -f dangling=true</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250912165012867.png" alt="image-20250912165012867"></p>
<p>删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>

<p>虚悬镜像已经失去存在价值，可以删除</p>
<h3 id="Docker-微服务实战"><a href="#Docker-微服务实战" class="headerlink" title="Docker 微服务实战"></a>Docker 微服务实战</h3><ol>
<li><p>通过idea创建一个普通的微服务模块，并打包成jar包</p>
<p>省略</p>
</li>
<li><p>通过dockerfile发布微服务部署到docker容器</p>
<ol>
<li><p>将编写好的jar包上传到linux上</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914151801322.png" alt="image-20250914151801322"></p>
</li>
<li><p>在同级目录编写Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像使用java</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span>-jdk</span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lazy</span><br><span class="line"><span class="comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名为my_docker.jar</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> docker_boot-3.2.4.jar my_docker.jar</span></span><br><span class="line"><span class="comment"># 运行jar包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;touch /my_docker.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/my_docker.jar&quot;</span>]</span></span><br><span class="line"><span class="comment">#暴露9090端口作为微服务,这个和你编写好的jar，暴露的端口要一致</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914151847681.png" alt="image-20250914151847681"></p>
</li>
<li><p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_docker:1.0 .</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914152821760.png" alt="image-20250914152821760"></p>
</li>
<li><p>运行容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:9090 my_docker:1.0</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914152936712.png" alt="image-20250914152936712"></p>
</li>
<li><p>访问测试</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914152948463.png" alt="image-20250914152948463"></p>
</li>
</ol>
<blockquote>
<p>注意：运行的时候必须在上传jar包的目录构建！不然找不到你上传jar包的路径</p>
</blockquote>
</li>
</ol>
<h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><h4 id="是什么？-2"><a href="#是什么？-2" class="headerlink" title="是什么？"></a>是什么？</h4><p>docker不启动，默认网络情况</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914170953916.png" alt="image-20250914170953916"></p>
<ul>
<li><p>ens33</p>
<p><strong>ens33（以太网接口）</strong> <em>ens33</em>是系统中的<strong>以太网接口（Ethernet Interface）</strong>，用于实际的网络通信。它通常对应于物理网卡或虚拟机中的虚拟网卡。在CentOS 7及之后的版本中，网卡名称采用了<em>Predictable Network Interface Names</em>规则，默认以<em>ensXX</em>（如<em>ens33</em>）命名，而在CentOS 6及之前的版本中，网卡名称通常是<em>eth0</em>。</p>
</li>
<li><p>lo</p>
<p><strong>lo（环回接口）</strong> <em>lo</em>是系统的<strong>环回接口（Loopback Interface）</strong>，主要用于本地通信。它的IP地址通常是<em>127.0.0.1</em>，也被称为“localhost”。环回接口的作用是让本机上的进程之间进行通信或测试网络服务，而无需通过实际的网络硬件。即使没有物理网络连接，<em>lo</em>接口也始终存在。</p>
</li>
<li><p>virbr0</p>
<p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。</p>
<p>我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove libvirt-libs.x86_64</span><br></pre></td></tr></table></figure></li>
</ul>
<p>docker启动后，网络情况</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914171651023.png" alt="image-20250914171651023"></p>
<p>查看docker网络模式命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914171827856.png" alt="image-20250914171827856"></p>
<h4 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h4><p>All命令</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914171918370.png" alt="image-20250914171918370"></p>
<p>查看网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p>查看网络源数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network inspect 网络名字</span><br></pre></td></tr></table></figure>

<p>删除网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network rm 网络名字</span><br></pre></td></tr></table></figure>

<p>案例</p>
<ul>
<li><p>创建一个名叫lazy_network的网络，再删除</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914172332882.png" alt="image-20250914172332882"></p>
</li>
</ul>
<p>可以看到默认创建网络模式是bridge（桥接模式）</p>
<h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ol>
<li>docker网络可以实现容器间的互联和通信以及端口映射</li>
<li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li>
</ol>
<h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p>总体介绍：</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914172618820.png" alt="image-20250914172618820"></p>
<ul>
<li>bridge模式：使用 –network bridge指定，默认使用docker0</li>
<li>host模式：使用 –network host指定</li>
<li>none模式：使用 –network none指定</li>
<li>container模式：使用 –network container:NAME 或容器ID指定</li>
</ul>
<p>容器实例内默认网络IP生成规则</p>
<ul>
<li><p>说明</p>
<ol>
<li><p>先启动两个Ubuntu容器实例</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914173042847.png" alt="image-20250914173042847"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914173053906.png" alt="image-20250914173053906"></p>
</li>
<li><p>docker inspect 容器id或容器名字</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914173242537.png" alt="image-20250914173242537"></p>
</li>
<li><p>关闭u2实例，新建u3，查看ip变化</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914173523897.png" alt="image-20250914173523897"></p>
</li>
</ol>
<p>可以看到我们的ip地址是跟着变化的</p>
<p>结论：docker容器内部的ip是有可能会发生改变的</p>
</li>
</ul>
<h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h4><ul>
<li><p>bridge</p>
<ul>
<li><p>是什么</p>
<p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 bridge 网络的详细信息，并通过 grep 获取名称项</span></span><br><span class="line">docker network inspect bridge | grep name</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914173825712.png" alt="image-20250914173825712"></p>
<p>ifconfig</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914173853521.png" alt="image-20250914173853521"></p>
</li>
<li><p>案例</p>
<p>说明</p>
<ol>
<li><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p>
</li>
<li><p>docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p>
</li>
<li><p>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p>
<ol>
<li><p>整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</p>
</li>
<li><p>每个容器实例内部也有一块网卡，每个接口叫eth0；</p>
</li>
<li><p>docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p>
<p> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p>
</li>
</ol>
<p><img src="/hexo-docs/images/dockerImages/image-20250914174014942.png" alt="image-20250914174014942"></p>
</li>
</ol>
<p>代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914174612807.png" alt="image-20250914174612807"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914175053664.png" alt="image-20250914175053664"></p>
</li>
</ul>
</li>
<li><p>host</p>
<p>是什么：直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p>
<p>案例</p>
<ul>
<li><p>说明</p>
<p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914175225226.png" alt="image-20250914175225226"></p>
</li>
<li><p>代码</p>
<ul>
<li><p>警告</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914175447820.png" alt="image-20250914175447820"></p>
<p>问题：</p>
<p>   docke启动时总是遇见标题中的警告</p>
<p>原因：</p>
<p>  docker启动时指定–network&#x3D;host或-net&#x3D;host，如果还指定了-p映射端口，那这个时候就会有此警告，</p>
<p>并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p>
<p>解决:</p>
<p>  解决的办法就是使用docker的其他网络模式，例如–network&#x3D;bridge，这样就可以解决问题，或者直接无视。。。。O(∩_∩)O哈哈~</p>
</li>
<li><p>正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>无之前的配对显示了，看容器实例内部</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914175644265.png" alt="image-20250914175644265"></p>
</li>
<li><p>没有设置 -p的端口映射了，如何访问启动tomcat83？？</p>
<p>http:&#x2F;&#x2F;宿主机IP:8080&#x2F;</p>
<p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，</p>
<p>所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914180226102.png" alt="image-20250914180226102"></p>
</li>
</ul>
</li>
<li><p>none</p>
<ul>
<li><p>是什么：</p>
<p>在none模式下，并不为Docker容器进行任何网络配置。 </p>
<p>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo</p>
<p>需要我们自己为Docker容器添加网卡、配置IP等。</p>
<ul>
<li>禁用网络功能，只有lo标识（就是127.0.0.1表示本地回环）</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914180717728.png" alt="image-20250914180717728"></p>
</li>
</ul>
</li>
<li><p>container⽹络模式 </p>
<ul>
<li><p>是什么</p>
<p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914180807680.png" alt="image-20250914180807680"></p>
</li>
<li><p>案例（错）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8085:8080 --name tomcat85 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat86 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914181325091.png" alt="image-20250914181325091"></p>
<p>相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突</p>
<p>本案例用tomcat演示不合适。。。演示坑。。。。。。o(╥﹏╥)o </p>
<p>换一个镜像给演示</p>
</li>
<li><p>案例2</p>
<ul>
<li><p>Alpine操作系统是一个面向安全的轻型linux发行版</p>
<p>Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M的大小，所以特别适合容器打包。</p>
</li>
<li><p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name alpine1 alpine /bin/sh</span><br><span class="line">docker run -it --network container:alpine1 --name alpine2 alpine /bin/sh</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914182130185.png" alt="image-20250914182130185"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914182140549.png" alt="image-20250914182140549"></p>
</li>
<li><p>关闭alpine1，再看看alpin2</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914182346865.png" alt="image-20250914182346865"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914182408969.png" alt="image-20250914182408969"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><h5 id="没有自定义网络"><a href="#没有自定义网络" class="headerlink" title="没有自定义网络"></a>没有自定义网络</h5><p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p>上述成功启动并用docker exec进入各自容器实例内部</p>
<p>问题</p>
<p>安装ip地址ping是ok的，可惜我们的ip地址是会变的，但是我们的服务名不会变</p>
<p>ping服务名试试</p>
<ul>
<li>tomcat81 ping tomcat82</li>
</ul>
<p><img src="/hexo-docs/images/dockerImages/image-20250914185414636.png" alt="image-20250914185414636"></p>
<ul>
<li>tomcat82 ping tomcat81</li>
</ul>
<p><img src="/hexo-docs/images/dockerImages/image-20250914185453678.png" alt="image-20250914185453678"></p>
<ul>
<li>安装服务名ping的结果？</li>
</ul>
<p><img src="/hexo-docs/images/dockerImages/image-20250914185635927.png" alt="image-20250914185635927"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914185643788.png" alt="image-20250914185643788"></p>
<h5 id="有自定义网络"><a href="#有自定义网络" class="headerlink" title="有自定义网络"></a>有自定义网络</h5><h6 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h6><ul>
<li><p>自定义桥接网络，自定义网络默认使用的是桥接网络bridge</p>
</li>
<li><p>新建自定义网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create lazy_network</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250914185951794.png" alt="image-20250914185951794"></p>
</li>
<li><p>新建容器加入上一步新建的自定义网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --network lazy_network --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --network lazy_network --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>
</li>
<li><p>互相ping测试</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914190147276.png" alt="image-20250914190147276"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914190159546.png" alt="image-20250914190159546"></p>
</li>
</ul>
<h6 id="问题结论"><a href="#问题结论" class="headerlink" title="问题结论"></a>问题结论</h6><ol>
<li>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</li>
<li>默认桥接网络，容器名或服务名不会自动添加到DNS中。自定义bridge网络启用了Docker内置的DNS服务，Docker会自动将容器名注册到网络的DNS中。不支持DNS服务名解析。</li>
<li>容器之间通信必须依赖IP，除非你手动配置–link（已过时），因此可以用容器名（也就是服务名）进行域名解析</li>
<li>早起bridge不支持dns，后来才支持的，所以只有自定义网络支持dns</li>
</ol>
<h4 id="Docker-平台架构图解"><a href="#Docker-平台架构图解" class="headerlink" title="Docker 平台架构图解"></a>Docker 平台架构图解</h4><p>整体说明：</p>
<p>从其架构和运行流程来看，Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p>
<p>Docker 运行的基本流程为：</p>
<ol>
<li>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</li>
<li>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</li>
<li>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</li>
<li>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</li>
<li>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</li>
<li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</li>
<li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</li>
</ol>
<p>整体架构</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250914190345495.png" alt="image-20250914190345495"></p>
<h3 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h3><h4 id="是什么？-3"><a href="#是什么？-3" class="headerlink" title="是什么？"></a>是什么？</h4><ul>
<li>Compose 是 Docker 公司推出的一个工具软件（开源项目），可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，<strong>写好多个容器之间的调用关系</strong>。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器。</li>
</ul>
<h4 id="能干嘛？-1"><a href="#能干嘛？-1" class="headerlink" title="能干嘛？"></a>能干嘛？</h4><p>docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p>
<ul>
<li><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</p>
</li>
<li><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。</p>
</li>
<li><p>Compose允许用户通过一个单独的<strong>docker-compose.yml模板文件</strong>（YAML 格式）来定义<strong>一组相关联的应用容器为一个项目（project）</strong>。</p>
</li>
<li><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>
</li>
</ul>
<h4 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h4><p>官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/compose-file/">https://docs.docker.com/reference/compose-file/</a></p>
<p>下载：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/linux/#install-the-plugin-manually">https://docs.docker.com/compose/install/linux/#install-the-plugin-manually</a></p>
<p>安装步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<p>卸载步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose # 使用curl安装</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250915161404502.png" alt="image-20250915161404502"></p>
<h4 id="Compose核心概念"><a href="#Compose核心概念" class="headerlink" title="Compose核心概念"></a>Compose核心概念</h4><ul>
<li><p>一文件：docker-compose.yml</p>
</li>
<li><p>两要素</p>
<ul>
<li><p>服务（service）</p>
<p>一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p>
</li>
<li><p>工程（project）</p>
<p>由一组关联的应用容器组成的一个<strong>完整业务单元</strong>，在docker-compose文件中定义。</p>
</li>
</ul>
</li>
</ul>
<h4 id="Compose使用的三个步骤"><a href="#Compose使用的三个步骤" class="headerlink" title="Compose使用的三个步骤"></a>Compose使用的三个步骤</h4><ul>
<li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li>
<li>使用docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li>
<li>最后，执行docker-compose up命令来启动并运行整个应用程序，完成一键部署上线</li>
</ul>
<h4 id="Compose常用命令"><a href="#Compose常用命令" class="headerlink" title="Compose常用命令"></a>Compose常用命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -h                           # 查看帮助</span><br><span class="line">docker-compose up                           # 启动所有docker-compose服务</span><br><span class="line">docker-compose up -d                        # 启动所有docker-compose服务并后台运行</span><br><span class="line">docker-compose down                         # 停止并删除容器、网络、卷、镜像。</span><br><span class="line">docker-compose exec  yml里面的服务id                 # 进入容器实例内部  docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</span><br><span class="line">docker-compose ps                      # 展示当前docker-compose编排过的运行的所有容器</span><br><span class="line">docker-compose top                     # 展示当前docker-compose编排过的容器进程 </span><br><span class="line">docker-compose logs  yml里面的服务id     # 查看容器输出日志</span><br><span class="line">docker-compose config     # 检查配置</span><br><span class="line">docker-compose config -q  # 检查配置，有问题才有输出</span><br><span class="line">docker-compose restart   # 重启服务</span><br><span class="line">docker-compose start     # 启动服务</span><br><span class="line">docker-compose stop      # 停止服务</span><br></pre></td></tr></table></figure>

<h4 id="Componse编排微服务"><a href="#Componse编排微服务" class="headerlink" title="Componse编排微服务"></a>Componse编排微服务</h4><h5 id="不用Compose"><a href="#不用Compose" class="headerlink" title="不用Compose"></a>不用Compose</h5><p>改造我们的docker_boot，添加mysql和redis</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springdoc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis-flex --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mybatis-flex<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-flex-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mybatis-flex<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-flex-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">docker_boot</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.0.140:3306/db2025?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.140</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">mybatis-flex:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.lazy.docker_boot.pojo</span></span><br><span class="line"><span class="attr">springdoc:</span></span><br><span class="line">  <span class="attr">swagger-ui:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/swagger-ui.html</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">api-docs:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/api-json</span></span><br><span class="line">    <span class="attr">groups:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 扫描controller</span></span><br><span class="line">  <span class="attr">packages-to-scan:</span> <span class="string">com.lazy.docker_boot.controller</span></span><br></pre></td></tr></table></figure>

<p>RedisConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置redis序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lettuceConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line">        <span class="comment">//设置key的序列化方式string</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//设置value序列化方式json</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringdocConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.ExternalDocumentation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Contact;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.License;</span><br><span class="line"><span class="keyword">import</span> org.springdoc.core.models.GroupedOpenApi;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringdocConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">orderApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .pathsToMatch(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">openAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(apiInfo())</span><br><span class="line">                .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">                        .description(<span class="string">&quot;SpringDoc文档&quot;</span>)</span><br><span class="line">                        .url(<span class="string">&quot;https://springdoc.org/&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Info <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                .title(<span class="string">&quot;接口文档标题&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;SpringBoot3 集成 Springdoc&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>()</span><br><span class="line">                        .name(<span class="string">&quot;lazy&quot;</span>)</span><br><span class="line">                        .url(<span class="string">&quot;www.lazy.com&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .license(<span class="keyword">new</span> <span class="title class_">License</span>()</span><br><span class="line">                        .name(<span class="string">&quot;Apache 2.0&quot;</span>)</span><br><span class="line">                        .url(<span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatisflex.annotation.Column;</span><br><span class="line"><span class="keyword">import</span> com.mybatisflex.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> com.mybatisflex.annotation.KeyType;</span><br><span class="line"><span class="keyword">import</span> com.mybatisflex.annotation.Table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id(keyType = KeyType.Auto)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别 0=女 1=男</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Byte sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除标志，默认0不删除，1删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Byte deleted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Column(value = &quot;update_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Column(value = &quot;create_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> username - 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置用户名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> password - 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取性别 0=女 1=男</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> sex - 性别 0=女 1=男</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Byte <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置性别 0=女 1=男</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sex 性别 0=女 1=男</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(Byte sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取删除标志，默认0不删除，1删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deleted - 删除标志，默认0不删除，1删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Byte <span class="title function_">getDeleted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置删除标志，默认0不删除，1删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleted 删除标志，默认0不删除，1删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDeleted</span><span class="params">(Byte deleted)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deleted = deleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取更新时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> update_time - 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getUpdateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> updateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置更新时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateTime 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUpdateTime</span><span class="params">(Date updateTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateTime = updateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取创建时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> create_time - 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置创建时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> createTime 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Date createTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lazy.docker_boot.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.mybatisflex.core.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lazy.docker_boot.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.lazy.docker_boot.pojo.User;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_KEY_USER=<span class="string">&quot;user:&quot;</span>;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="comment">//先保存进mysql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">        <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//需要再次查询一下mysql将数据捞回来并ok</span></span><br><span class="line">            user = userMapper.selectOneById(user.getId());</span><br><span class="line">            <span class="comment">//将捞出来的user存进redis，完成新增功能的数据一致性。</span></span><br><span class="line">            redisTemplate.opsForValue().set(CACHE_KEY_USER+user.getId(),user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">selectById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_KEY_USER+id;</span><br><span class="line">        <span class="comment">// 先从redis里面查询，如果有直接返回结果，如果没有再去查询mysql</span></span><br><span class="line">        user = (User) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//redis无，再查mysql</span></span><br><span class="line">        user = userMapper.selectOneById(id);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//redis+mysql 都无数据</span></span><br><span class="line">            <span class="comment">//你具体细化，防止多次穿透，我们规定，记录下导致穿透的这个key回写redis</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//mysql有，需要将数据写回redis，保证下一次的缓存命中率</span></span><br><span class="line">            redisTemplate.opsForValue().set(CACHE_KEY_USER+id,user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.IdUtil;</span><br><span class="line"><span class="keyword">import</span> com.lazy.docker_boot.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.lazy.docker_boot.service.UserService;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.Operation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.tags.Tag;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;userController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;添加3个用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;lazy&quot;</span>+i);</span><br><span class="line">            user.setPassword(IdUtil.simpleUUID().substring(<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line">            user.setSex((<span class="type">byte</span>) <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">2</span>));</span><br><span class="line">            user.setDeleted((<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">            userService.addUser(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询1条记录&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user/find/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DockerBootApplicaiton</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lazy.docker_boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.lazy.docker_boot.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerBootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DockerBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE db2025;</span><br><span class="line">USE db2025;</span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line"></span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line">  `username` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;,</span><br><span class="line"></span><br><span class="line">  `password` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line"></span><br><span class="line">  `sex` tinyint(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;,</span><br><span class="line"></span><br><span class="line">  `deleted` tinyint(4) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;,</span><br><span class="line"></span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line"></span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line"></span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>

<p>打包写好的项目，并发送到Linux上（省略）</p>
<p>启动mysql、redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql57 --privileged=true -v /app/docker_data/mysql/conf:/etc/mysql/conf.d -v /app/docker_data/mysql/logs:/logs -v /app/docker_data/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -p 6379:6379 --name redis --privileged=true \</span><br><span class="line">-v /app/docker_data/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /app/docker_data/redis/data:/data \</span><br><span class="line">-d redis:7.0 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<p>在linux上编写Dockerfile文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像使用java</span></span><br><span class="line"><span class="keyword">FROM</span> docker.<span class="number">1</span>ms.run/library/openjdk:<span class="number">17</span></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lazy</span><br><span class="line"><span class="comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名为my_docker.jar</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> docker_boot.jar my_docker.jar</span></span><br><span class="line"><span class="comment"># 运行jar包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;touch /my_docker.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/my_docker.jar&quot;</span>]</span></span><br><span class="line"><span class="comment">#暴露9090端口作为微服务,这个和你编写好的jar，暴露的端口要一致</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>

<p>如果不行就pull下来</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915175330866.png" alt="image-20250915175330866"></p>
<p>构建镜像，并运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_docker:1.0 .</span><br><span class="line"></span><br><span class="line">docker run -d -p 9090:9090 my_docker:1.0</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250915181557886.png" alt="image-20250915181557886"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915181613868.png" alt="image-20250915181613868"></p>
<p>成功了！有哪些问题？</p>
<ul>
<li>先后顺序要求固定，先mysql+redis才能微服务访问成功</li>
<li>多个run命令</li>
<li>容器间的启停或宕机，有可能导致IP地址对应的容器实例变换，映射出错</li>
<li>要么生成IP写死（可以但是不推荐），要么通过服务调用</li>
</ul>
<h5 id="使用Compose"><a href="#使用Compose" class="headerlink" title="使用Compose"></a>使用Compose</h5><p>编写Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础镜像使用java</span></span><br><span class="line">FROM docker.1ms.run/library/openjdk:17</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作者</span></span><br><span class="line">MAINTAINER lazy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将jar包添加到容器中并更名为zzyy_docker.jar</span></span><br><span class="line">ADD docker_boot.jar my_docker.jar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行jar包</span></span><br><span class="line">RUN bash -c &#x27;touch /my_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/my_docker.jar&quot;]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">暴露9090端口作为微服务</span></span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure>



<p>编写docker-compose.yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">microService:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my_docker:1.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ms01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/docker_data/springboot:/data</span> </span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">lazy_net</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:7.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/docker_data/myredis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/docker_data/myredis/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">lazy_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2025&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;lazy&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;lazy&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/docker_data/mysql/db:/var/lib/mysql</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/docker_data/mysql/conf/my.cnf:/etc/my.cnf</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">/app/docker_data/mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lazy_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment">#解决外部无法访问</span></span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">   <span class="attr">lazy:</span> </span><br></pre></td></tr></table></figure>

<p>修改docker_boot</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915182345102.png" alt="image-20250915182345102"></p>
<p>使用这个命令打包，要不然找不到mysql和redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>

<p>重新打包，并上传到linux上</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915182953892.png" alt="image-20250915182953892"></p>
<p>必须在一个目录下，构建并运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_docker:1.0 .</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250915184835523.png" alt="image-20250915184835523"></p>
<p>新建查询，把刚才的表写进去</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db2025;</span><br><span class="line">USE db2025;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `t_user` (</span><br><span class="line"></span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `sex` tinyint(<span class="number">4</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别 0=女 1=男 &#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `deleted` tinyint(<span class="number">4</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志，默认0不删除，1删除&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line"></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p><img src="/hexo-docs/images/dockerImages/image-20250915185617142.png" alt="image-20250915185617142"></p>
<p>测试</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915185700246.png" alt="image-20250915185700246"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915185716165.png" alt="image-20250915185716165"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250915185729125.png" alt="image-20250915185729125"></p>
<p>关闭docker-compose</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>

<h3 id="Docker轻量级可视化工具Portainer"><a href="#Docker轻量级可视化工具Portainer" class="headerlink" title="Docker轻量级可视化工具Portainer"></a>Docker轻量级可视化工具Portainer</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>官网：<a target="_blank" rel="noopener" href="https://www.portainer.io/%EF%BC%8Chttps://docs.portainer.io/start/install-ce/server/docker/linux">https://www.portainer.io/，https://docs.portainer.io/start/install-ce/server/docker/linux</a></p>
<p>Portainer BE 和 CE的区别</p>
<p>Portainer目前分为两个大的版本，分别为Portainer CE和Portainer BE（portainer-ee）。</p>
<p>Portainer CE (Community Edition) 和 Portainer BE (Business Edition) 有以下主要区别：</p>
<p><strong>Portainer CE</strong>：</p>
<ul>
<li>Portainer CE 是开源版本，广泛受到全球家庭实验室用户的喜爱，可以免费安装。</li>
<li>它是一个轻量级的服务交付平台，适用于容器化应用程序，可用于管理 Docker，Swarm，Kubernetes 和 ACI 环境。设计上，旨在简单部署和使用。该应用程序允许你通过一个“智能”图形用户界面和&#x2F;或一个广泛的 API 来管理所有的编排器资源（如容器、镜像、卷、网络等）。</li>
<li>Portainer CE 为个人提供了一个通用的管理工具集，可以轻松地部署和管理容器本地应用程序，运营成本低，而且无需专门投资任何单一的编排器或 Kubernetes 分发版本。</li>
</ul>
<p><strong>Portainer BE</strong>：</p>
<ul>
<li>Portainer BE 建立在开源基础之上，并包括一系列高级功能和功能，如角色基础访问控制（RBAC）和支持，这些都是商业用户的特定需求。</li>
<li>Portainer BE 提供的特性包括身份和访问管理，外部认证系统，基于角色的访问控制，Kubernetes-as-a-Service (KaaS) 和 MicroK8s 的设置和配置，配额管理，安全治理（如单点登录，认证和活动日志），丰富的可观察性，成本管理，以及灾难恢复等。</li>
<li>购买 Portainer Business 许可证时，会包含支持服务，有明确的服务级别协议；提供 9x5 的次日支持或针对关键环境的 24x7 支持。五个节点的免费许可证只通过社区论坛提供支持。</li>
</ul>
<p>总的来说，Portainer CE 是一个功能齐全的开源容器管理工具，适合个人和小团队使用。而 Portainer BE 则提供了更高级的功能，适合需要更细粒度控制和支持的商业用户。</p>
<p>因此正常来说，我们一般选择拉取portainer-ce的镜像即可。</p>
<p>步骤：</p>
<p>docker命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:lts</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--restart=always docker重启后portainer也会跟着重启</span></span><br></pre></td></tr></table></figure>

<p>第一次登录需创建admin，访问地址<code>ip地址:9443</code></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916151520217.png" alt="image-20250916151520217"></p>
<p>报了个错！官网解释</p>
<p>当您尝试使用 HTTP 协议访问 Portairer 的 HTTPS URL（端口 9443）时，会出现此错误：这是因为端口 9443 只接受 HTTPS 协议，不接受 HTTP 请求。换成https访问</p>
<p>设置admin用户和密码后首次登录（密码为3个admin）</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916151814628.png" alt="image-20250916151814628"></p>
<p>点击创建</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916151912918.png" alt="image-20250916151912918"></p>
<p>重启portainer</p>
<p>选择Get started选项卡后本地docker详细信息展示</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916152156314.png" alt="image-20250916152156314"></p>
<p>在选择local</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916152240788.png" alt="image-20250916152240788"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916152539109.png" alt="image-20250916152539109"></p>
<p>上一步对应的命令是什么？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250916152628694.png" alt="image-20250916152628694"></p>
<p>那个stack是什么？点进去看看</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916152706287.png" alt="image-20250916152706287"></p>
<p>这不是我们使用docker-compose创建的镜像吗</p>
<p>使用Portainer安装nginx</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916152858192.png" alt="image-20250916152858192"></p>
<p>下载好右上角会有个提示</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916153320805.png" alt="image-20250916153320805"></p>
<p>运行nginx，点击containers，再点击add container</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916154555213.png" alt="image-20250916154555213"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916154721488.png" alt="image-20250916154721488"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916155215508.png" alt="image-20250916155215508"></p>
<p>点击部署</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916155301391.png" alt="image-20250916155301391"></p>
<h3 id="Docker容器监控之CAdvisor-InfluxDB-Granfana"><a href="#Docker容器监控之CAdvisor-InfluxDB-Granfana" class="headerlink" title="Docker容器监控之CAdvisor+InfluxDB+Granfana"></a>Docker容器监控之CAdvisor+InfluxDB+Granfana</h3><h4 id="原生命令"><a href="#原生命令" class="headerlink" title="原生命令"></a>原生命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250916173926383.png" alt="image-20250916173926383"></p>
<p>问题</p>
<p>通过<code>docker stats</code>命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，一般小公司够用了。。。。</p>
<p>但是，<code>docker stats</code>统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能</p>
<h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h4><p>容器监控3剑客</p>
<ul>
<li><p>一句话：CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916174044161.png" alt="image-20250916174044161"></p>
</li>
<li><p>CAdvisor</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916174143908.png" alt="image-20250916174143908"></p>
</li>
<li><p>InfluxDB</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916174201123.png" alt="image-20250916174201123"></p>
</li>
<li><p>Granfana</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916174214980.png" alt="image-20250916174214980"></p>
</li>
<li><p>总结</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916174230873.png" alt="image-20250916174230873"></p>
</li>
</ul>
<h4 id="compose容器编排，一套带走"><a href="#compose容器编排，一套带走" class="headerlink" title="compose容器编排，一套带走"></a>compose容器编排，一套带走</h4><p>新建目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir cig</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250916174409244.png" alt="image-20250916174409244"></p>
<p>新建3件套组合的docker-compose.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定Docker Compose配置文件版本为3.1</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="comment"># 定义数据卷，用于持久化存储服务数据</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="comment"># 存储Grafana的配置和数据，实现数据持久化</span></span><br><span class="line">  <span class="attr">grafana_data:</span> &#123;&#125;  </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># InfluxDB服务：时序数据库，用于存储监控指标数据</span></span><br><span class="line">  <span class="attr">influxdb:</span></span><br><span class="line">    <span class="comment"># 使用tutum提供的InfluxDB 0.9版本镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tutum/influxdb</span></span><br><span class="line">    <span class="comment"># 容器退出时总是自动重启</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 预先创建名为cadvisor的数据库，用于存储cAdvisor收集的数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PRE_CREATE_DB=cadvisor</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="comment"># 映射InfluxDB的管理界面端口到主机</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span> </span><br><span class="line">      <span class="comment"># 映射InfluxDB的API端口到主机，用于数据写入和查询</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="comment"># 将主机当前目录下的data/influxdb目录挂载到容器的/data目录，持久化InfluxDB数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/influxdb:/data</span> </span><br><span class="line">  <span class="comment"># cAdvisor服务：容器监控工具，用于收集主机和容器的资源使用信息</span></span><br><span class="line">  <span class="attr">cadvisor:</span></span><br><span class="line">   <span class="comment"># 使用cAdvisor镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">google/cadvisor</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="comment"># 链接到influxdb服务，并起别名为influxsrv，便于网络访问</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line">    <span class="comment"># 启动命令：配置cAdvisor将收集的数据存储到InfluxDB</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-storage_driver=influxdb</span> <span class="string">-storage_driver_db=cadvisor</span> <span class="string">-storage_driver_host=influxsrv:8086</span></span><br><span class="line">    <span class="comment"># 容器启动总是自动重启</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 映射cAdvisor的Web界面端口到主机，可通过该端口查看监控数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="comment"># 挂载主机根目录到容器，只读模式，用于收集主机文件系统信息</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span> </span><br><span class="line">        <span class="comment"># 挂载/var/run目录，读写模式，用于访问容器运行时信息</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line">       <span class="comment"># 挂载/sys目录，只读模式，用于收集系统硬件信息</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span> </span><br><span class="line">       <span class="comment"># 挂载Docker数据目录，只读模式，用于收集容器详细信息</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span> </span><br><span class="line">  <span class="comment"># Grafana服务：数据可视化工具，用于将InfluxDB中的监控数据以图表形式展示</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">   <span class="comment"># 指定运行Grafana的用户ID（104是默认的grafana用户ID）</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&quot;104&quot;</span> </span><br><span class="line">     <span class="comment"># 使用官方Grafana镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line">    <span class="comment"># 容器退出时总是自动重启</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="comment"># 链接到influxdb服务，便于访问数据库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 映射Grafana的Web界面端口到主机，通过该端口访问可视化面板</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="comment"># 使用前面定义的grafana_data数据卷，持久化Grafana配置和面板数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grafana_data:/var/lib/grafana</span> </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="comment"># Grafana的默认管理员用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_USER=admin</span>  </span><br><span class="line">       <span class="comment"># Grafana的默认管理员密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PASS=admin</span> </span><br><span class="line">       <span class="comment"># 配置InfluxDB的主机地址（使用前面定义的别名）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_HOST=influxsrv</span> </span><br><span class="line">        <span class="comment"># 配置InfluxDB的端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_PORT=8086</span></span><br><span class="line">        <span class="comment"># 配置要连接的InfluxDB数据库名称</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_NAME=cadvisor</span></span><br><span class="line">      <span class="comment"># 连接InfluxDB的用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_USER=root</span> </span><br><span class="line">       <span class="comment"># 连接InfluxDB的密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_PASS=root</span> </span><br></pre></td></tr></table></figure>

<p>如果下载的时候有问题的话，建议一个一个下载到本地再试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull tutum/influxdb</span><br><span class="line">docker pull grafana/grafana</span><br><span class="line">docker pull google/cadvisor</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250916182037297.png" alt="image-20250916182037297"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182132538.png" alt="image-20250916182132538"></p>
<p>查看三个服务是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/hexo-docs/images/dockerImages/image-20250916182205772.png" alt="image-20250916182205772"></p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>浏览cAdvisor<strong>收集</strong>服务，<a target="_blank" rel="noopener" href="http://ip:8080/">http://ip:8080</a></p>
<ul>
<li>第一次访问慢，请稍等</li>
<li>cadvisor也有基础的图形展现功能，这里主要用它来做数据采集</li>
</ul>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182350800.png" alt="image-20250916182350800"></p>
<p>浏览influxdb<strong>存储</strong>服务，<a target="_blank" rel="noopener" href="http://ip:8083/">http://ip:8083</a></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182322643.png" alt="image-20250916182322643"></p>
<p>浏览grafana<strong>展现</strong>服务，<a target="_blank" rel="noopener" href="http://ip:3000/">http://ip:3000</a></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182418611.png" alt="image-20250916182418611"></p>
<ul>
<li><p>ip+3000端口的方式访问，默认账户密码（admin&#x2F;admin）</p>
</li>
<li><p>配置步骤</p>
<ul>
<li><p>配置数据源</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182619723.png" alt="image-20250916182619723"></p>
</li>
<li><p>选择influxdb数据源</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182721011.png" alt="image-20250916182721011"></p>
</li>
<li><p>配置细节</p>
<p>ip地址不要写死了，因为ip是会变化的</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916182850810.png" alt="image-20250916182850810"></p>
<p>账号密码都是root</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916183503369.png" alt="image-20250916183503369"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916183519925.png" alt="image-20250916183519925"></p>
</li>
<li><p>配置面板panel</p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916183642989.png" alt="image-20250916183642989"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916183724869.png" alt="image-20250916183724869"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916184028869.png" alt="image-20250916184028869"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916184203415.png" alt="image-20250916184203415"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916192419658.png" alt="image-20250916192419658"></p>
<p><img src="/hexo-docs/images/dockerImages/image-20250916185135910.png" alt="image-20250916185135910"></p>
</li>
</ul>
</li>
</ul>
<p>CAdvisor+InfluxDB+Granfana就部署完成了！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs">Lazy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mac2git.github.io/hexo-docs/2025/09/17/docker/docker/">https://mac2git.github.io/hexo-docs/2025/09/17/docker/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mac2git.github.io/hexo-docs" target="_blank">Lazy的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/hexo-docs/tags/Docker/">Docker</a><a class="post-meta__tags" href="/hexo-docs/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a></div><div class="post-share"><div class="social-share" data-image="/hexo-docs/images/dockerImages/docker.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ"><img class="cover" src="/hexo-docs/images/rocketmqImages/cover.png" onerror="onerror=null;src='/hexo-docs/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RocketMQ</div></div><div class="info-2"><div class="info-item-1">深入降级RocketMQ的原理，应用场景，及实践，集成SpringBoot</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/hexo-docs/images/webImages/avatar.jpg" onerror="this.onerror=null;this.src='/hexo-docs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Lazy</div><div class="author-info-description">归途也还可爱</div><div class="site-data"><a href="/hexo-docs/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/hexo-docs/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/hexo-docs/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mac2git"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mac2git" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/wx_00ba6ce280" target="_blank" title="Gitee"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客正在施工，请先随便逛逛。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0Docker%EF%BC%9F"><span class="toc-text">为什么会出现Docker？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">Docker 应用场景及优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BDdocker"><span class="toc-text">安装&#x2F;卸载docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90"><span class="toc-text">安装前提</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD-Docker"><span class="toc-text">卸载 Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B8%E8%BF%9C%E7%9A%84-hello-world"><span class="toc-text">永远的 hello-world</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%EF%BC%9F"><span class="toc-text">Docker为什么比虚拟机快？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-text">启动速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8"><span class="toc-text">资源占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%80%E9%94%80"><span class="toc-text">存储开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97"><span class="toc-text">性能损耗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E6%9E%B6%E6%9E%84"><span class="toc-text">Docker 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">Docker 架构的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Docker-%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88Docker-Client%EF%BC%89"><span class="toc-text">1、Docker 客户端（Docker Client）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-text">常用命令：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Docker-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%88Docker-Daemon%EF%BC%89"><span class="toc-text">2、Docker 守护进程（Docker Daemon）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Docker-%E5%BC%95%E6%93%8E-API%EF%BC%88Docker-Engine-API%EF%BC%89"><span class="toc-text">3、Docker 引擎 API（Docker Engine API）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Docker-%E5%AE%B9%E5%99%A8%EF%BC%88Docker-Containers%EF%BC%89"><span class="toc-text">4、Docker 容器（Docker Containers）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Docker-%E9%95%9C%E5%83%8F%EF%BC%88Docker-Images%EF%BC%89"><span class="toc-text">5、Docker 镜像（Docker Images）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Docker-%E4%BB%93%E5%BA%93%EF%BC%88Docker-Registries%EF%BC%89"><span class="toc-text">6. Docker 仓库（Docker Registries）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Docker-Compose"><span class="toc-text">7、Docker Compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Docker-Swarm"><span class="toc-text">8、Docker Swarm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Docker-%E7%BD%91%E7%BB%9C%EF%BC%88Docker-Networks%EF%BC%89"><span class="toc-text">9、Docker 网络（Docker Networks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Docker-%E5%8D%B7%EF%BC%88Docker-Volumes%EF%BC%89"><span class="toc-text">10. Docker 卷（Docker Volumes）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-text">帮助&amp;启动类命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-text">镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="toc-text">搜索镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-text">下载镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%89%80%E5%8D%A0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-text">查看镜像&#x2F;容器&#x2F;数据卷所占的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-text">删除镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88docker%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">谈谈docker虚悬镜像是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA-%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">新建+启动容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%90%8E%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">进入容器后退出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">列出当前所有正在运行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">退出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">启动已停止运行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-text">重启容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">强制停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">删除已停止的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81"><span class="toc-text">重要</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-text">启动守护式容器（后台服务器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis%E5%89%8D%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%E6%BC%94%E7%A4%BA"><span class="toc-text">redis前后台启动演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-text">查看容器日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">查看容器内运行的进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-text">查看容器内部细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92"><span class="toc-text">进入正在运行的容器并以命令行交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5"><span class="toc-text">重新进入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%88%AB"><span class="toc-text">上述两个区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8redis%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E8%BF%9B%E5%85%A5%E8%AF%95%E8%AF%95"><span class="toc-text">使用redis容器实例进入试试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A"><span class="toc-text">从容器内拷贝文件到主机上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">导入和导出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%88%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="toc-text">总结（常用命令）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F"><span class="toc-text">Docker 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3"><span class="toc-text">重点理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F-commit-%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B"><span class="toc-text">Docker 镜像 commit 操作案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-text">本地镜像发布到阿里云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-text">将阿里云的镜像下载到本地</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%AC%E5%9C%B0%E5%8F%91%E5%B8%83%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93-%E4%B8%8B%E8%BD%BD%E5%8F%91%E5%B8%83%E7%9A%84%E7%A7%81%E6%9C%89%E5%BA%93"><span class="toc-text">将本地发布到私有库&amp;下载发布的私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93"><span class="toc-text">将本地镜像发布到私有库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%A7%81%E6%9C%8D%E5%BA%93pull%E5%88%B0%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C"><span class="toc-text">将私服库pull到本地运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-text">Docker 容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="toc-text">能干嘛？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%A1%88%E4%BE%8B"><span class="toc-text">数据卷案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%BF%E4%B8%BB%E6%9C%BAvs%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="toc-text">1.宿主机vs容器之间映射添加容器卷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E8%AF%B4%E6%98%8E"><span class="toc-text">2.读写规则映射添加说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8D%B7%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-text">3.卷的继承和共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%B8%B8%E8%A7%84%E5%AE%89%E8%A3%85%E7%AE%80%E4%BB%8B"><span class="toc-text">Docker 常规安装简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85tomcat"><span class="toc-text">安装tomcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85mysql"><span class="toc-text">安装mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88"><span class="toc-text">基础版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%89%88"><span class="toc-text">实战版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85redis"><span class="toc-text">安装redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Credis%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">运行redis容器实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%A4%8D%E6%9D%82%E5%AE%89%E8%A3%85%E8%AF%A6%E8%AF%B4"><span class="toc-text">Docker复杂安装详说</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">安装mysql主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4"><span class="toc-text">安装redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA"><span class="toc-text">哈希取余分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%88%86%E5%8C%BA"><span class="toc-text">一致性哈希算法分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-text">哈希槽分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis3%E4%B8%BB3%E4%BB%8E%E9%85%8D%E7%BD%AE"><span class="toc-text">redis3主3从配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E6%A1%88%E4%BE%8B"><span class="toc-text">主从容错切换案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E6%A1%88%E4%BE%8B"><span class="toc-text">容错切换案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-text">主从扩容案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-text">主从缩容案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DockerFile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">DockerFile构建过程解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DockerFile-%E5%B8%B8%E7%94%A8%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4"><span class="toc-text">DockerFile 常用保留字指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8Fmycentosjava8"><span class="toc-text">自定义镜像mycentosjava8</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%81%94%E5%90%88%E7%B3%BB%E7%BB%9F%EF%BC%88UnionFS%EF%BC%89"><span class="toc-text">文件联合系统（UnionFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="toc-text">虚悬镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98"><span class="toc-text">Docker 微服务实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%BD%91%E7%BB%9C"><span class="toc-text">Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2"><span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">常用基本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">网络模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">案例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">自定义网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">没有自定义网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-text">有自定义网络</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%BB%93%E8%AE%BA"><span class="toc-text">问题结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3"><span class="toc-text">Docker 平台架构图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-compose"><span class="toc-text">Docker-compose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-3"><span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B%EF%BC%9F-1"><span class="toc-text">能干嘛？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E5%93%AA%E4%B8%8B"><span class="toc-text">去哪下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compose%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">Compose核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compose%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-text">Compose使用的三个步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">Compose常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Componse%E7%BC%96%E6%8E%92%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">Componse编排微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8Compose"><span class="toc-text">不用Compose</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Compose"><span class="toc-text">使用Compose</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7Portainer"><span class="toc-text">Docker轻量级可视化工具Portainer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-1"><span class="toc-text">安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7%E4%B9%8BCAdvisor-InfluxDB-Granfana"><span class="toc-text">Docker容器监控之CAdvisor+InfluxDB+Granfana</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%91%BD%E4%BB%A4"><span class="toc-text">原生命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compose%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%EF%BC%8C%E4%B8%80%E5%A5%97%E5%B8%A6%E8%B5%B0"><span class="toc-text">compose容器编排，一套带走</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/17/docker/docker/" title="Docker"><img src="/hexo-docs/images/dockerImages/docker.webp" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/17/docker/docker/" title="Docker">Docker</a><time datetime="2025-09-16T16:00:00.000Z" title="发表于 2025-09-17 00:00:00">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ"><img src="/hexo-docs/images/rocketmqImages/cover.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/hexo-docs/2025/09/01/rocketmq/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2025-08-31T16:00:00.000Z" title="发表于 2025-09-01 00:00:00">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/08/29/commit_protocol/index/" title="两阶段提交与三阶段提交"><img src="/hexo-docs/images/commit_protocolImages/img.png" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="两阶段提交与三阶段提交"/></a><div class="content"><a class="title" href="/hexo-docs/2025/08/29/commit_protocol/index/" title="两阶段提交与三阶段提交">两阶段提交与三阶段提交</a><time datetime="2025-08-28T16:00:00.000Z" title="发表于 2025-08-29 00:00:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/08/26/other/mysql_id/" title="在实际开发过程中Mysql该选用ID什么ID作为主键？"><img src="/hexo-docs/images/mysql_idImages/cover.svg" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="在实际开发过程中Mysql该选用ID什么ID作为主键？"/></a><div class="content"><a class="title" href="/hexo-docs/2025/08/26/other/mysql_id/" title="在实际开发过程中Mysql该选用ID什么ID作为主键？">在实际开发过程中Mysql该选用ID什么ID作为主键？</a><time datetime="2025-08-26T09:24:30.000Z" title="发表于 2025-08-26 17:24:30">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo-docs/2025/08/26/other/Linux_ext2~ext4example/" title="linux ext2~ext4介绍"><img src="/hexo-docs/images/webImages/default_top_img.jpeg" onerror="this.onerror=null;this.src='/hexo-docs/img/404.jpg'" alt="linux ext2~ext4介绍"/></a><div class="content"><a class="title" href="/hexo-docs/2025/08/26/other/Linux_ext2~ext4example/" title="linux ext2~ext4介绍">linux ext2~ext4介绍</a><time datetime="2025-08-26T09:17:00.000Z" title="发表于 2025-08-26 17:17:00">2025-08-26</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Lazy</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/hexo-docs/js/utils.js"></script><script src="/hexo-docs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="14px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/hexo-docs/js/search/local-search.js"></script></div></div></body></html>